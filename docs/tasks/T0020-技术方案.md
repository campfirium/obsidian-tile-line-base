
---

# T0020-技术方案

## 一、整体架构设计

### 1.1 架构分层

```
┌─────────────────────────────────────────────────┐
│          用户交互（左键/右键点击）                │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│      StatusCellRenderer (自定义渲染器)          │
│  - 渲染 5 种状态图标                              │
│  - 监听左键点击（todo ↔ done）                   │
│  - 触发状态变更回调                               │
│  - 提供 title/aria-label 以提升可访问性           │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│         AgGridAdapter (AG Grid 封装层)          │
│  - 配置 status 列使用 StatusCellRenderer         │
│  - 配置右键菜单（getContextMenuItems）            │
│  - 配置行/列样式规则（rowClassRules/cellClassRules）│
│  - editable: false (屏蔽 AG Grid 编辑行为)       │
│  - suppressClickEdit/suppressCellSelection 全局禁用│
│  - getRowId 提供稳定 ID                          │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│          TableView (数据管理层)                  │
│  - 自动添加 status 内置列                        │
│  - 新行初始化 status='todo'                      │
│  - 状态变更回调：通过 rowId → blockIndex 映射更新 │
│  - 同时更新 statusChanged 时间戳                 │
│  - 使用 setDataValue 增量刷新                    │
│  - 调用 scheduleSave() 触发持久化                │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│         H2Block[] (内存数据结构)                 │
│  blocks[i].data['status'] = 'done'              │
│  blocks[i].data['statusChanged'] = '2025-...'   │
│  blocks[i].data['__id'] = 'uuid-like稳定id'      │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│      blocksToMarkdown() (持久化层)               │
│  - status 作为普通 key:value 输出                │
│  - statusChanged 作为压缩属性输出                │
└─────────────────────────────────────────────────┘
```

### 1.2 数据流设计

**关键原则**：AG Grid 只作为**视图层**，数据的唯一真实来源是 `this.blocks` 数组。

```typescript
// 状态变更流程（避免 AG Grid 干扰）
用户点击状态图标
  → StatusCellRenderer.onClick()
  → 回调 onStatusChange(rowId, newStatus)
  → TableView.onStatusChange()
      → 根据 rowId → index 映射找到对应 block
      → 修改 block.data['status'] = newStatus
      → 修改 block.data['statusChanged'] = ISO 时间戳
      → 调用 gridApi.setDataValue(rowId, 'status', newStatus) 增量刷新
      → 调用 this.scheduleSave() 防抖保存到文件
```

---

## 二、核心技术难点与解决方案

### 难点 1：屏蔽 AG Grid 的默认编辑/选择行为

* **问题**：AG Grid 默认会在单击/双击单元格时进入编辑模式或触发选择闪烁。
* **解决方案**：

  * `editable: false` 禁止编辑。
  * 全局 `suppressClickEdit: true` 和 `suppressCellSelection: true`。
  * `colDef.suppressNavigable = true` 防止键盘聚焦。
  * 渲染器点击事件中 `e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();`。

---

### 难点 2：左键点击切换状态

* **问题**：需要在渲染器里切换状态，但避免触发 grid 自身事件。
* **解决方案**：

  * 使用 `rowId`（稳定 ID）而不是 blockIndex，避免排序/过滤错位。
  * 点击逻辑：todo ↔ done，其它状态统一变为 done。
  * 节流：避免双击抖动。

---

### 难点 3：右键菜单显示完整状态选项

* **问题**：需要展示所有 5 种状态。
* **解决方案**：

  * 在 `getContextMenuItems` 中，若当前列是 `status`，返回自定义状态菜单。
  * 使用 `normalizeStatus(node.data.status)`，而不是 `params.value`。
  * 状态菜单与行菜单互斥，避免混乱。

---

### 难点 4：状态变更必须直接写入 blocks

* **问题**：只改 grid 数据会丢失，必须更新 blocks。
* **解决方案**：

  * 维护 `rowId → blockIndex` 的 Map。
  * 在 TableView 回写时直接修改 blocks，再用 `gridApi.setDataValue()` 局部刷新。

---

### 难点 5：视觉反馈（半透明 + 删除线）

* **问题**：done/canceled 的行需要特殊样式。
* **解决方案**：

  * `rowClassRules` 控制整行半透明。
  * `cellClassRules` 只对标题列加删除线（通过 `colId: 'title'` 定位，而不是 CSS first-of-type）。

---

### 难点 6：时间戳持久化

* **问题**：statusChanged 不显示列，但要存文件。
* **解决方案**：

  * `blocksToMarkdown()` 输出压缩属性。
  * `parseH2Blocks()` 同步解析。
  * 确保使用统一冒号字符和 key 名。

---

## 三、关键改进点总结

1. **rowId 稳定标识**：不要依赖 index。
2. **增量刷新**：用 `setDataValue` 替代 `updateData()`，避免闪烁。
3. **normalizeStatus 工具函数**：全局唯一。
4. **样式规则**：用 colId 定位标题列。
5. **可访问性**：渲染器加 `title` 和 `aria-label`，导出时输出文字。
6. **右键菜单隔离**：status 菜单与行菜单互斥。

---

## 四、实现步骤（修正版）

### 阶段 1：StatusCellRenderer

* 渲染 5 种状态图标（☐ ☑ ⊟ ⏸ ☒）。
* 左键点击切换，调用回调 `onStatusChange(rowId, newStatus)`。
* 添加 `title` 和 `aria-label`。

### 阶段 2：AgGridAdapter

* 定义 `getRowId`。
* 在 status 列配置：`editable: false`、`suppressNavigable: true`、`cellRenderer: StatusCellRenderer`。
* 配置 `rowClassRules` 和 `cellClassRules`。
* 配置 `getContextMenuItems`，仅对 status 列启用状态菜单。

### 阶段 3：TableView

* 为新行生成唯一 `__id`。
* 在渲染后重建 `idToIndex` 映射。
* onStatusChange：通过 rowId 定位 block，修改 status + statusChanged，调用 `gridApi.setDataValue()` 更新单元格。
* `blocksToMarkdown` 输出压缩属性。

### 阶段 4：CSS 样式

```css
.tlb-status-cell { text-align: center; cursor: pointer; font-size: 14px; }
.tlb-row-completed { opacity: 0.5; }
.tlb-title-strike { text-decoration: line-through; }
```

---

## 五、测试清单（修正版）

* [ ] 新文件自动有 status 列，默认值 todo。
* [ ] 左键点击切换状态，UI 秒级更新。
* [ ] 双击不抖动。
* [ ] 右键菜单显示 5 种状态，点击即更新。
* [ ] done/canceled 行半透明，标题列加删除线。
* [ ] 保存文件时写入 status/statusChanged。
* [ ] 重新打开文件保持状态。
* [ ] 复制行时 status 也被复制。
* [ ] 点击 status 列不会触发 grid 编辑/选择。
* [ ] 导出时使用文字状态。

---

## 六、未来扩展方向

* 自定义状态类型。
* 状态流转规则。
* 状态统计与过滤。
* 状态历史日志。

---

## 七、最小可行核心代码（修正版）

```ts
// StatusCellRenderer.ts
export class StatusCellRenderer implements ICellRendererComp {
  private eGui!: HTMLElement;
  private params!: ICellRendererParams;

  init(params: ICellRendererParams): void {
    this.params = params;
    this.eGui = document.createElement('div');
    this.renderIcon();

    this.eGui.addEventListener('click', (e) => {
      e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
      const rowId = params.node!.id!;
      const curr = normalizeStatus(params.data?.status);
      const next = curr === 'todo' ? 'done' : (curr === 'done' ? 'todo' : 'done');
      params.context?.onStatusChange?.(rowId, next);
    });
  }

  private renderIcon() {
    const s = normalizeStatus(this.params.data?.status);
    this.eGui.textContent = getIcon(s);
    this.eGui.title = s;
    this.eGui.setAttribute('aria-label', s);
  }

  getGui() { return this.eGui; }
  refresh(p: ICellRendererParams) { this.params = p; this.renderIcon(); return true; }
}

// TableView.ts
private onStatusChange(rowId: string, newStatus: Status): void {
  const idx = this.idToIndex.get(rowId);
  if (idx == null) return;
  const block = this.blocks[idx];
  block.data.status = newStatus;
  block.data.statusChanged = new Date().toISOString();

  this.gridApi.getRowNode(rowId)?.setDataValue('status', newStatus);
  this.scheduleSave();
}
```

---

## 八、总结

该方案通过 **StatusCellRenderer + AgGridAdapter + TableView** 三层架构，实现了稳定的状态列功能。关键改进点在于**rowId 稳定映射、增量刷新、统一 normalize、列级样式规则、可访问性增强**。这样不仅解决了功能问题，也规避了闪烁、错位、样式脆弱等潜在坑。


