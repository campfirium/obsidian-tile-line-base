# 备忘录：终极表格视图的技术选型与架构设计

**主题：** 为 TileLineBase 插件的“终极表格视图”，选择最合适的前端组件，并设计一个可扩展、可维护的集成架构。

**最终决策：** MVP 阶段采用 **AG Grid Community**，并通过一个**抽象的 `GridAdapter` 层**进行集成，以保证未来的灵活性和可维护性。

---

### **一、核心问题：为什么不能手动实现表格？**

*   **重复造轮子：** 排序、筛选、编辑、列宽调整、虚拟滚动等功能，都是极其复杂的“轮子”。手动实现耗时耗力，且难以做到专业水准。
*   **性能瓶颈：** 在处理大数据量时，手动实现的表格很难做好性能优化（如虚拟滚动）。
*   **交互缺失：** 专业的表格库内置了大量细节体验，如键盘导航、复制粘贴、可访问性 (A11y) 支持，这些是手动实现难以企及的。

---

### **二、技术选型评审：三大主流方案对比**

| 方案 | **AG Grid Community** | **TanStack Table (v8)** | **Tabulator** |
| :--- | :--- | :--- | :--- |
| **核心哲学** | 全功能套装 (自带UI) | 无头UI引擎 (只提供逻辑) | 轻量级纯JS工具库 |
| **React集成** | **极高 (官方包)** | **原生 (就是React Hooks)** | 中等 (需手动包装) |
| **开发速度 (MVP)** | **最快** | 慢 (需手写UI) | 快 |
| **定制能力** | 高 | **无限** | 高 |
| **性能** | 极高 | 极高 | 高 |
| **许可证** | **MIT** | MIT | MIT |

---

### **三、战略决策与分阶段路线图**

1.  **MVP 阶段 (追求速度与体验): 选用 AG Grid Community**
    *   **理由:** 能以最快速度交付一个“看起来就很对”的、功能完备的专业表格，让我们能聚焦于核心的 Markdown 解析与写回逻辑。
    *   **必须明确其功能边界:** 社区版**不包含**分组/透视、Excel级高级筛选器等企业级功能。我们不能在 MVP 方案中过度承诺。

2.  **中长期 (追求UI统一与绝对可控): 规划 TanStack Table 替换路线**
    *   **理由:** 当产品发展到需要与整体设计系统（无论是自研还是引入 MUI/Tailwind）进行深度视觉统一时，TanStack Table 的“无头”特性将提供无限的灵活性。

3.  **极限场景 (追求极致性能): 备选 Glide Data Grid (Canvas)**
    *   **理由:** 当处理超大规模数据（10万行以上）且追求极致流畅度时，基于 Canvas 渲染的表格是最终的性能解决方案。

---

### **四、核心架构设计：“可撤可守”的 `GridAdapter` 层 (关键！)**

为了避免业务逻辑与具体UI库的“野蛮耦合”，我们必须引入一个抽象的**适配器层 (`GridAdapter`)**。

*   **使命:** 定义一个**统一的、与具体库无关的接口**，用于操作表格。我们的核心业务逻辑只与这个接口对话，而不关心底层到底用的是 AG Grid 还是 TanStack Table。

*   **伪接口定义:**
    ```typescript
    export interface GridAdapter {
      // 挂载表格到指定HTML元素
      mount(el: HTMLElement, columns: ColumnDef[], rows: Row[]): void;

      // 更新表格数据
      updateData(rows: Row[]): void;

      // 监听单元格编辑事件
      onCellEdit(callback: (change: {rowId: string; field: string; value: any}) => void): void;

      // 获取当前表格状态（用于持久化）
      getState(): GridState; // 包含排序、筛选、列宽、列顺序等

      // 恢复表格状态
      setState(state: GridState): void;

      // 销毁表格实例
      destroy(): void;
    }
    ```

*   **实现:**
    *   **MVP:** 我们将创建一个 `AgGridAdapter.ts`，用 AG Grid 的 API 来实现这个接口。
    *   **未来:** 如果需要更换，我们只需要创建一个新的 `TanStackAdapter.ts`，**而所有调用 `GridAdapter` 的上层业务代码，无需做任何修改**。

---

### **五、AG Grid Community 落地注意事项 (避坑指南)**

*   **最小化原则:** MVP 的列定义，从最基础的 `field`, `editable`, `valueGetter/valueSetter` 开始，不要过早引入复杂渲染器。
*   **输入法兼容 (IME):** 写回操作的触发时机，应从 `onCellValueChanged` (实时变化) 调整为“编辑结束”或“单元格失焦”事件，以兼容中文等输入法。
*   **容器尺寸变化:** 在 Obsidian 的面板显示/隐藏/切换时，需要手动调用 `api.sizeColumnsToFit()` 等方法来强制重绘表格，以保证尺寸正确。
*   **数据量警惕:** 当数据行数超过 3-5 万时，即使是 AG Grid，客户端模式的性能也可能下降。届时需要考虑优化解析和数据供给策略。

---

**最终结论：** 我们的 MVP 将采用 **AG Grid Community** 作为前端表格组件，并通过一个精心设计的 **`GridAdapter`** 进行集成。这个决策，在**开发速度、用户体验、以及未来的技术可扩展性**之间，取得了完美的平衡。