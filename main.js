/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TileLineBasePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/TableView.ts
var import_obsidian = require("obsidian");

// node_modules/ag-grid-community/dist/package/main.esm.mjs
var LocalEventService = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map();
    this.allAsyncListeners = /* @__PURE__ */ new Map();
    this.globalSyncListeners = /* @__PURE__ */ new Set();
    this.globalAsyncListeners = /* @__PURE__ */ new Set();
    this.asyncFunctionsQueue = [];
    this.scheduled = false;
    this.firedEvents = {};
  }
  setFrameworkOverrides(frameworkOverrides) {
    this.frameworkOverrides = frameworkOverrides;
  }
  getListeners(eventType, async, autoCreateListenerCollection) {
    const listenerMap = async ? this.allAsyncListeners : this.allSyncListeners;
    let listeners = listenerMap.get(eventType);
    if (!listeners && autoCreateListenerCollection) {
      listeners = /* @__PURE__ */ new Set();
      listenerMap.set(eventType, listeners);
    }
    return listeners;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(eventType, listener, async = false) {
    this.getListeners(eventType, async, true).add(listener);
  }
  removeEventListener(eventType, listener, async = false) {
    const listeners = this.getListeners(eventType, async, false);
    if (!listeners) {
      return;
    }
    listeners.delete(listener);
    if (listeners.size === 0) {
      (async ? this.allAsyncListeners : this.allSyncListeners).delete(eventType);
    }
  }
  addGlobalListener(listener, async = false) {
    this.getGlobalListeners(async).add(listener);
  }
  removeGlobalListener(listener, async = false) {
    this.getGlobalListeners(async).delete(listener);
  }
  dispatchEvent(event) {
    this.dispatchToListeners(event, true);
    this.dispatchToListeners(event, false);
    this.firedEvents[event.type] = true;
  }
  dispatchEventOnce(event) {
    if (!this.firedEvents[event.type]) {
      this.dispatchEvent(event);
    }
  }
  dispatchToListeners(event, async) {
    var _a4;
    const eventType = event.type;
    if (async && "event" in event) {
      const browserEvent = event.event;
      if (browserEvent instanceof Event) {
        event.eventPath = browserEvent.composedPath();
      }
    }
    const { frameworkOverrides } = this;
    const runCallback = (func) => {
      const callback = frameworkOverrides ? () => frameworkOverrides.wrapIncoming(func) : func;
      if (async) {
        this.dispatchAsync(callback);
      } else {
        callback();
      }
    };
    const originalListeners = this.getListeners(eventType, async, false);
    if (((_a4 = originalListeners == null ? void 0 : originalListeners.size) != null ? _a4 : 0) > 0) {
      const listeners = new Set(originalListeners);
      for (const listener of listeners) {
        if (!(originalListeners == null ? void 0 : originalListeners.has(listener))) {
          continue;
        }
        runCallback(() => listener(event));
      }
    }
    const globalListenersSrc = this.getGlobalListeners(async);
    if (globalListenersSrc.size > 0) {
      const globalListeners = new Set(globalListenersSrc);
      for (const listener of globalListeners) {
        runCallback(() => listener(eventType, event));
      }
    }
  }
  getGlobalListeners(async) {
    return async ? this.globalAsyncListeners : this.globalSyncListeners;
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(func) {
    this.asyncFunctionsQueue.push(func);
    if (!this.scheduled) {
      const flush = () => {
        window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      };
      this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(flush) : flush();
      this.scheduled = true;
    }
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = false;
    const queueCopy = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [];
    queueCopy.forEach((func) => func());
  }
};
function _makeNull(value) {
  if (value == null || value === "") {
    return null;
  }
  return value;
}
function _exists(value) {
  return value != null && value !== "";
}
function _missing(value) {
  return !_exists(value);
}
function _toStringOrNull(value) {
  return value != null && typeof value.toString === "function" ? value.toString() : null;
}
function _defaultComparator(valueA, valueB, accentedCompare = false) {
  const valueAMissing = valueA == null;
  const valueBMissing = valueB == null;
  if (valueA && valueA.toNumber) {
    valueA = valueA.toNumber();
  }
  if (valueB && valueB.toNumber) {
    valueB = valueB.toNumber();
  }
  if (valueAMissing && valueBMissing) {
    return 0;
  }
  if (valueAMissing) {
    return -1;
  }
  if (valueBMissing) {
    return 1;
  }
  function doQuickCompare(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  if (typeof valueA !== "string") {
    return doQuickCompare(valueA, valueB);
  }
  if (!accentedCompare) {
    return doQuickCompare(valueA, valueB);
  }
  try {
    return valueA.localeCompare(valueB);
  } catch (e) {
    return doQuickCompare(valueA, valueB);
  }
}
var reUnescapedHtml = /[&<>"']/g;
var HTML_ESCAPES = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function _toString(toEscape) {
  var _a4;
  return (_a4 = toEscape == null ? void 0 : toEscape.toString().toString()) != null ? _a4 : null;
}
function _escapeString(toEscape) {
  var _a4, _b2;
  return (_b2 = (_a4 = _toString(toEscape)) == null ? void 0 : _a4.replace(reUnescapedHtml, (chr) => HTML_ESCAPES[chr])) != null ? _b2 : null;
}
function _getRootNode(beans) {
  return beans.eRootDiv.getRootNode();
}
function _getActiveDomElement(beans) {
  return _getRootNode(beans).activeElement;
}
function _getDocument(beans) {
  const { gos, eRootDiv } = beans;
  let result = null;
  const optionsGetDocument = gos.get("getDocument");
  if (optionsGetDocument && _exists(optionsGetDocument)) {
    result = optionsGetDocument();
  } else if (eRootDiv) {
    result = eRootDiv.ownerDocument;
  }
  if (result && _exists(result)) {
    return result;
  }
  return document;
}
function _isNothingFocused(beans) {
  const activeEl = _getActiveDomElement(beans);
  return activeEl === null || activeEl === _getDocument(beans).body;
}
function _getWindow(beans) {
  const eDocument = _getDocument(beans);
  return eDocument.defaultView || window;
}
function _getPageBody(beans) {
  let rootNode = null;
  let targetEl = null;
  try {
    rootNode = _getDocument(beans).fullscreenElement;
  } catch (e) {
  } finally {
    if (!rootNode) {
      rootNode = _getRootNode(beans);
    }
    const body = rootNode.querySelector("body");
    if (body) {
      targetEl = body;
    } else if (rootNode instanceof ShadowRoot) {
      targetEl = rootNode;
    } else if (rootNode instanceof Document) {
      targetEl = rootNode == null ? void 0 : rootNode.documentElement;
    } else {
      targetEl = rootNode;
    }
  }
  return targetEl;
}
function _getBodyWidth(beans) {
  var _a4;
  const body = _getPageBody(beans);
  return (_a4 = body == null ? void 0 : body.clientWidth) != null ? _a4 : window.innerWidth || -1;
}
function _getBodyHeight(beans) {
  var _a4;
  const body = _getPageBody(beans);
  return (_a4 = body == null ? void 0 : body.clientHeight) != null ? _a4 : window.innerHeight || -1;
}
function _toggleAriaAttribute(element, attribute, value) {
  if (value == null || typeof value === "string" && value == "") {
    _removeAriaAttribute(element, attribute);
  } else {
    _setAriaAttribute(element, attribute, value);
  }
}
function _setAriaAttribute(element, attribute, value) {
  element.setAttribute(_ariaAttributeName(attribute), value.toString());
}
function _removeAriaAttribute(element, attribute) {
  element.removeAttribute(_ariaAttributeName(attribute));
}
function _ariaAttributeName(attribute) {
  return `aria-${attribute}`;
}
function _setAriaRole(element, role) {
  if (role) {
    element.setAttribute("role", role);
  } else {
    element.removeAttribute("role");
  }
}
function _getAriaSortState(sortDirection) {
  let sort;
  if (sortDirection === "asc") {
    sort = "ascending";
  } else if (sortDirection === "desc") {
    sort = "descending";
  } else if (sortDirection === "mixed") {
    sort = "other";
  } else {
    sort = "none";
  }
  return sort;
}
function _getAriaLabel(element) {
  return element.getAttribute("aria-label");
}
function _setAriaLabel(element, label) {
  _toggleAriaAttribute(element, "label", label);
}
function _setAriaLabelledBy(element, labelledBy) {
  _toggleAriaAttribute(element, "labelledby", labelledBy);
}
function _setAriaLive(element, live) {
  _toggleAriaAttribute(element, "live", live);
}
function _setAriaAtomic(element, atomic) {
  _toggleAriaAttribute(element, "atomic", atomic);
}
function _setAriaRelevant(element, relevant) {
  _toggleAriaAttribute(element, "relevant", relevant);
}
function _setAriaInvalid(element, invalid) {
  _toggleAriaAttribute(element, "invalid", invalid);
}
function _setAriaHidden(element, hidden) {
  _toggleAriaAttribute(element, "hidden", hidden);
}
function _setAriaExpanded(element, expanded) {
  _setAriaAttribute(element, "expanded", expanded);
}
function _setAriaMultiSelectable(element, multiSelectable) {
  _setAriaAttribute(element, "multiselectable", multiSelectable);
}
function _setAriaRowCount(element, rowCount) {
  _setAriaAttribute(element, "rowcount", rowCount);
}
function _setAriaRowIndex(element, rowIndex) {
  _setAriaAttribute(element, "rowindex", rowIndex);
}
function _setAriaColCount(element, colCount) {
  _setAriaAttribute(element, "colcount", colCount);
}
function _setAriaColIndex(element, colIndex) {
  _setAriaAttribute(element, "colindex", colIndex);
}
function _setAriaColSpan(element, colSpan) {
  _setAriaAttribute(element, "colspan", colSpan);
}
function _setAriaSort(element, sort) {
  _setAriaAttribute(element, "sort", sort);
}
function _removeAriaSort(element) {
  _removeAriaAttribute(element, "sort");
}
function _getAriaCheckboxStateName(translate, state) {
  return state === void 0 ? translate("ariaIndeterminate", "indeterminate") : state === true ? translate("ariaChecked", "checked") : translate("ariaUnchecked", "unchecked");
}
var FOCUSABLE_SELECTOR = "[tabindex], input, select, button, textarea, [href]";
var FOCUSABLE_EXCLUDE = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function _isFocusableFormField(element) {
  const matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
  const inputSelector = "input, select, button, textarea";
  const isFocusable = matches.call(element, inputSelector);
  const isNotFocusable = matches.call(element, FOCUSABLE_EXCLUDE);
  const isElementVisible = _isVisible(element);
  const focusable = isFocusable && !isNotFocusable && isElementVisible;
  return focusable;
}
function _setDisplayed(element, displayed, options = {}) {
  const { skipAriaHidden } = options;
  element.classList.toggle("ag-hidden", !displayed);
  if (!skipAriaHidden) {
    _setAriaHidden(element, !displayed);
  }
}
function _setVisible(element, visible, options = {}) {
  const { skipAriaHidden } = options;
  element.classList.toggle("ag-invisible", !visible);
  if (!skipAriaHidden) {
    _setAriaHidden(element, !visible);
  }
}
function _setDisabled(element, disabled) {
  var _a4;
  const attributeName = "disabled";
  const addOrRemoveDisabledAttribute = disabled ? (e) => e.setAttribute(attributeName, "") : (e) => e.removeAttribute(attributeName);
  addOrRemoveDisabledAttribute(element);
  const inputs = (_a4 = element.querySelectorAll("input")) != null ? _a4 : [];
  for (const input of inputs) {
    addOrRemoveDisabledAttribute(input);
  }
}
function _isElementChildOfClass(element, cls, maxNest) {
  let counter = 0;
  while (element) {
    if (element.classList.contains(cls)) {
      return true;
    }
    element = element.parentElement;
    if (typeof maxNest == "number") {
      if (++counter > maxNest) {
        break;
      }
    } else if (element === maxNest) {
      break;
    }
  }
  return false;
}
function _getElementSize(el) {
  const {
    height,
    width,
    borderTopWidth,
    borderRightWidth,
    borderBottomWidth,
    borderLeftWidth,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    boxSizing
  } = window.getComputedStyle(el);
  return {
    height: parseFloat(height || "0"),
    width: parseFloat(width || "0"),
    borderTopWidth: parseFloat(borderTopWidth || "0"),
    borderRightWidth: parseFloat(borderRightWidth || "0"),
    borderBottomWidth: parseFloat(borderBottomWidth || "0"),
    borderLeftWidth: parseFloat(borderLeftWidth || "0"),
    paddingTop: parseFloat(paddingTop || "0"),
    paddingRight: parseFloat(paddingRight || "0"),
    paddingBottom: parseFloat(paddingBottom || "0"),
    paddingLeft: parseFloat(paddingLeft || "0"),
    marginTop: parseFloat(marginTop || "0"),
    marginRight: parseFloat(marginRight || "0"),
    marginBottom: parseFloat(marginBottom || "0"),
    marginLeft: parseFloat(marginLeft || "0"),
    boxSizing
  };
}
function _getInnerHeight(el) {
  const size = _getElementSize(el);
  if (size.boxSizing === "border-box") {
    return size.height - size.paddingTop - size.paddingBottom;
  }
  return size.height;
}
function _getInnerWidth(el) {
  const size = _getElementSize(el);
  if (size.boxSizing === "border-box") {
    return size.width - size.paddingLeft - size.paddingRight;
  }
  return size.width;
}
function _getElementRectWithOffset(el) {
  const offsetElementRect = el.getBoundingClientRect();
  const { borderTopWidth, borderLeftWidth, borderRightWidth, borderBottomWidth } = _getElementSize(el);
  return {
    top: offsetElementRect.top + (borderTopWidth || 0),
    left: offsetElementRect.left + (borderLeftWidth || 0),
    right: offsetElementRect.right + (borderRightWidth || 0),
    bottom: offsetElementRect.bottom + (borderBottomWidth || 0)
  };
}
function _getScrollLeft(element, rtl) {
  let scrollLeft = element.scrollLeft;
  if (rtl) {
    scrollLeft = Math.abs(scrollLeft);
  }
  return scrollLeft;
}
function _setScrollLeft(element, value, rtl) {
  if (rtl) {
    value *= -1;
  }
  element.scrollLeft = value;
}
function _clearElement(el) {
  while (el && el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
function _removeFromParent(node) {
  if (node && node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function _isInDOM(element) {
  return !!element.offsetParent;
}
function _isVisible(element) {
  const el = element;
  if (el.checkVisibility) {
    return el.checkVisibility({ checkVisibilityCSS: true });
  }
  const isHidden = !_isInDOM(element) || window.getComputedStyle(element).visibility !== "visible";
  return !isHidden;
}
function _loadTemplate(template) {
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = (template || "").trim();
  return tempDiv.firstChild;
}
function _ensureDomOrder(eContainer, eChild, eChildBefore) {
  if (eChildBefore && eChildBefore.nextSibling === eChild) {
    return;
  }
  if (!eContainer.firstChild) {
    eContainer.appendChild(eChild);
  } else if (eChildBefore) {
    if (eChildBefore.nextSibling) {
      eContainer.insertBefore(eChild, eChildBefore.nextSibling);
    } else {
      eContainer.appendChild(eChild);
    }
  } else if (eContainer.firstChild && eContainer.firstChild !== eChild) {
    eContainer.insertAdjacentElement("afterbegin", eChild);
  }
}
function _setDomChildOrder(eContainer, orderedChildren) {
  for (let i = 0; i < orderedChildren.length; i++) {
    const correctCellAtIndex = orderedChildren[i];
    const actualCellAtIndex = eContainer.children[i];
    if (actualCellAtIndex !== correctCellAtIndex) {
      eContainer.insertBefore(correctCellAtIndex, actualCellAtIndex);
    }
  }
}
function _camelCaseToHyphenated(camelCase) {
  return camelCase.replace(/[A-Z]/g, (s) => `-${s.toLocaleLowerCase()}`);
}
function _addStylesToElement(eElement, styles) {
  if (!styles) {
    return;
  }
  for (const key of Object.keys(styles)) {
    const value = styles[key];
    if (!key || !key.length || value == null) {
      continue;
    }
    const parsedKey = _camelCaseToHyphenated(key);
    const valueAsString = value.toString();
    const parsedValue = valueAsString.replace(/\s*!important/g, "");
    const priority = parsedValue.length != valueAsString.length ? "important" : void 0;
    eElement.style.setProperty(parsedKey, parsedValue, priority);
  }
}
function _isHorizontalScrollShowing(element) {
  return element.clientWidth < element.scrollWidth;
}
function _isVerticalScrollShowing(element) {
  return element.clientHeight < element.scrollHeight;
}
function _setElementWidth(element, width) {
  if (width === "flex") {
    element.style.removeProperty("width");
    element.style.removeProperty("minWidth");
    element.style.removeProperty("maxWidth");
    element.style.flex = "1 1 auto";
  } else {
    _setFixedWidth(element, width);
  }
}
function _setFixedWidth(element, width) {
  width = _formatSize(width);
  element.style.width = width;
  element.style.maxWidth = width;
  element.style.minWidth = width;
}
function _setFixedHeight(element, height) {
  height = _formatSize(height);
  element.style.height = height;
  element.style.maxHeight = height;
  element.style.minHeight = height;
}
function _formatSize(size) {
  return typeof size === "number" ? `${size}px` : size;
}
function _isNodeOrElement(o) {
  return o instanceof Node || o instanceof HTMLElement;
}
function _addOrRemoveAttribute(element, name, value) {
  if (value == null || value === "") {
    element.removeAttribute(name);
  } else {
    element.setAttribute(name, value.toString());
  }
}
function _observeResize(beans, element, callback) {
  const win = _getWindow(beans);
  const ResizeObserverImpl = win.ResizeObserver;
  const resizeObserver = ResizeObserverImpl ? new ResizeObserverImpl(callback) : null;
  resizeObserver == null ? void 0 : resizeObserver.observe(element);
  return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
}
function _requestAnimationFrame(beans, callback) {
  const win = _getWindow(beans);
  if (win.requestAnimationFrame) {
    win.requestAnimationFrame(callback);
  } else if (win.webkitRequestAnimationFrame) {
    win.webkitRequestAnimationFrame(callback);
  } else {
    win.setTimeout(callback, 0);
  }
}
var DataRefAttribute = "data-ref";
var whitespaceNode;
function getWhitespaceNode() {
  whitespaceNode != null ? whitespaceNode : whitespaceNode = document.createTextNode(" ");
  return whitespaceNode.cloneNode();
}
function _createAgElement(params) {
  const { attrs, children, cls, ref, role, tag } = params;
  const element = document.createElement(tag);
  if (cls) {
    element.className = cls;
  }
  if (ref) {
    element.setAttribute(DataRefAttribute, ref);
  }
  if (role) {
    element.setAttribute("role", role);
  }
  if (attrs) {
    for (const key of Object.keys(attrs)) {
      element.setAttribute(key, attrs[key]);
    }
  }
  if (children) {
    if (typeof children === "string") {
      element.textContent = children;
    } else {
      let addFirstWhitespace = true;
      for (const child of children) {
        if (child) {
          if (typeof child === "string") {
            element.appendChild(document.createTextNode(child));
            addFirstWhitespace = false;
          } else if (typeof child === "function") {
            element.appendChild(child());
          } else {
            if (addFirstWhitespace) {
              element.appendChild(getWhitespaceNode());
              addFirstWhitespace = false;
            }
            element.append(_createAgElement(child));
            element.appendChild(getWhitespaceNode());
          }
        }
      }
    }
  }
  return element;
}
var PASSIVE_EVENTS = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"];
var NON_PASSIVE_EVENTS = ["wheel"];
var supports = {};
var _isEventSupported = /* @__PURE__ */ (() => {
  const tags = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  const eventChecker = (eventName) => {
    if (typeof supports[eventName] === "boolean") {
      return supports[eventName];
    }
    const el = document.createElement(tags[eventName] || "div");
    eventName = "on" + eventName;
    return supports[eventName] = eventName in el;
  };
  return eventChecker;
})();
function _addSafePassiveEventListener(eElement, event, listener) {
  const passive = getPassiveStateForEvent(event);
  let options;
  if (passive != null) {
    options = { passive };
  }
  eElement.addEventListener(event, listener, options);
}
var getPassiveStateForEvent = (event) => {
  const isPassive = PASSIVE_EVENTS.includes(event);
  const isNonPassive = NON_PASSIVE_EVENTS.includes(event);
  if (isPassive) {
    return true;
  }
  if (isNonPassive) {
    return false;
  }
};
function _areEventsNear(e1, e2, pixelCount) {
  if (pixelCount === 0) {
    return false;
  }
  const diffX = Math.abs(e1.clientX - e2.clientX);
  const diffY = Math.abs(e1.clientY - e2.clientY);
  return Math.max(diffX, diffY) <= pixelCount;
}
function _isEventFromThisInstance(beans, event) {
  return beans.gos.isElementInThisInstance(event.target);
}
function _anchorElementToMouseMoveEvent(element, mouseMoveEvent, beans) {
  const eRect = element.getBoundingClientRect();
  const height = eRect.height;
  const browserWidth = _getBodyWidth(beans) - 2;
  const browserHeight = _getBodyHeight(beans) - 2;
  const offsetParent = element.offsetParent;
  if (!offsetParent) {
    return;
  }
  const offsetParentSize = _getElementRectWithOffset(element.offsetParent);
  const { clientY, clientX } = mouseMoveEvent;
  let top = clientY - offsetParentSize.top - height / 2;
  let left = clientX - offsetParentSize.left - 10;
  const eDocument = _getDocument(beans);
  const win = eDocument.defaultView || window;
  const windowScrollY = win.pageYOffset || eDocument.documentElement.scrollTop;
  const windowScrollX = win.pageXOffset || eDocument.documentElement.scrollLeft;
  if (browserWidth > 0 && left + element.clientWidth > browserWidth + windowScrollX) {
    left = browserWidth + windowScrollX - element.clientWidth;
  }
  if (left < 0) {
    left = 0;
  }
  if (browserHeight > 0 && top + element.clientHeight > browserHeight + windowScrollY) {
    top = browserHeight + windowScrollY - element.clientHeight;
  }
  if (top < 0) {
    top = 0;
  }
  element.style.left = `${left}px`;
  element.style.top = `${top}px`;
}
function defaultLocaleTextFunc(_key, defaultValue) {
  return defaultValue;
}
function _getLocaleTextFunc(localeSvc) {
  var _a4;
  return (_a4 = localeSvc == null ? void 0 : localeSvc.getLocaleTextFunc()) != null ? _a4 : defaultLocaleTextFunc;
}
var AgBeanStub = class {
  constructor() {
    this.destroyFunctions = [];
    this.destroyed = false;
    this.__v_skip = true;
    this.propertyListenerId = 0;
    this.lastChangeSetIdLookup = {};
    this.isAlive = () => !this.destroyed;
  }
  preWireBeans(beans) {
    this.beans = beans;
    this.stubContext = beans.context;
    this.eventSvc = beans.eventSvc;
    this.gos = beans.gos;
  }
  // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
  // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
  // points to a bean or component that was not properly disposed of.
  // constructor() {
  //     setTimeout(()=> {
  //         if (this.isAlive()) {
  //             let prototype: any = Object.getPrototypeOf(this);
  //             const constructor: any = prototype.constructor;
  //             const constructorString = constructor.toString();
  //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
  //             console.log('is alive ' + beanName);
  //         }
  //     }, 5000);
  // }
  destroy() {
    const { destroyFunctions } = this;
    for (let i = 0; i < destroyFunctions.length; i++) {
      destroyFunctions[i]();
    }
    destroyFunctions.length = 0;
    this.destroyed = true;
    this.dispatchLocalEvent({ type: "destroyed" });
  }
  /** Add a local event listener against this BeanStub */
  addEventListener(eventType, listener, async) {
    if (!this.localEventService) {
      this.localEventService = new LocalEventService();
    }
    this.localEventService.addEventListener(eventType, listener, async);
  }
  /** Remove a local event listener from this BeanStub */
  removeEventListener(eventType, listener, async) {
    var _a4;
    (_a4 = this.localEventService) == null ? void 0 : _a4.removeEventListener(eventType, listener, async);
  }
  dispatchLocalEvent(event) {
    var _a4;
    (_a4 = this.localEventService) == null ? void 0 : _a4.dispatchEvent(event);
  }
  addManagedElementListeners(object, handlers) {
    return this._setupListeners(object, handlers);
  }
  addManagedEventListeners(handlers) {
    return this._setupListeners(this.eventSvc, handlers);
  }
  addManagedListeners(object, handlers) {
    return this._setupListeners(object, handlers);
  }
  _setupListeners(object, handlers) {
    const destroyFuncs = [];
    for (const k of Object.keys(handlers)) {
      const handler = handlers[k];
      if (handler) {
        destroyFuncs.push(this._setupListener(object, k, handler));
      }
    }
    return destroyFuncs;
  }
  _setupListener(object, event, listener) {
    if (this.destroyed) {
      return () => null;
    }
    let destroyFunc;
    if (isAgEventEmitter(object)) {
      object.__addEventListener(event, listener);
      destroyFunc = () => {
        object.__removeEventListener(event, listener);
        return null;
      };
    } else {
      const objIsEventService = isEventService(object);
      if (object instanceof HTMLElement) {
        _addSafePassiveEventListener(object, event, listener);
      } else if (objIsEventService) {
        object.addListener(event, listener);
      } else {
        object.addEventListener(event, listener);
      }
      destroyFunc = objIsEventService ? () => {
        object.removeListener(event, listener);
        return null;
      } : () => {
        object.removeEventListener(event, listener);
        return null;
      };
    }
    this.destroyFunctions.push(destroyFunc);
    return () => {
      destroyFunc();
      this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
      return null;
    };
  }
  /**
   * Setup a managed property listener for the given property.
   * However, stores the destroy function in the beanStub so that if this bean
   * is a component the destroy function will be called when the component is destroyed
   * as opposed to being cleaned up only when the properties service is destroyed.
   */
  setupPropertyListener(event, listener) {
    const { gos } = this;
    gos.addPropertyEventListener(event, listener);
    const destroyFunc = () => {
      gos.removePropertyEventListener(event, listener);
      return null;
    };
    this.destroyFunctions.push(destroyFunc);
    return () => {
      destroyFunc();
      this.destroyFunctions = this.destroyFunctions.filter((fn) => fn !== destroyFunc);
      return null;
    };
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */
  addManagedPropertyListener(event, listener) {
    if (this.destroyed) {
      return () => null;
    }
    return this.setupPropertyListener(event, listener);
  }
  /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */
  addManagedPropertyListeners(events, listener) {
    if (this.destroyed) {
      return;
    }
    const eventsKey = events.join("-") + this.propertyListenerId++;
    const wrappedListener = (event) => {
      if (event.changeSet) {
        if (event.changeSet && event.changeSet.id === this.lastChangeSetIdLookup[eventsKey]) {
          return;
        }
        this.lastChangeSetIdLookup[eventsKey] = event.changeSet.id;
      }
      const propertiesChangeEvent = {
        type: "propertyChanged",
        changeSet: event.changeSet,
        source: event.source
      };
      listener(propertiesChangeEvent);
    };
    events.forEach((event) => this.setupPropertyListener(event, wrappedListener));
  }
  getLocaleTextFunc() {
    return _getLocaleTextFunc(this.beans.localeSvc);
  }
  addDestroyFunc(func) {
    if (this.isAlive()) {
      this.destroyFunctions.push(func);
    } else {
      func();
    }
  }
  /** doesn't throw an error if `bean` is undefined */
  createOptionalManagedBean(bean, context) {
    return bean ? this.createManagedBean(bean, context) : void 0;
  }
  createManagedBean(bean, context) {
    const res = this.createBean(bean, context);
    this.addDestroyFunc(this.destroyBean.bind(this, bean, context));
    return res;
  }
  createBean(bean, context, afterPreCreateCallback) {
    return (context || this.stubContext).createBean(bean, afterPreCreateCallback);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(bean, context) {
    return (context || this.stubContext).destroyBean(bean);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(beans, context) {
    return (context || this.stubContext).destroyBeans(beans);
  }
};
function isAgEventEmitter(object) {
  return object.__addEventListener !== void 0;
}
function isEventService(object) {
  return object.eventServiceType === "global";
}
var BeanStub = class extends AgBeanStub {
};
var doOnceFlags = {};
function _doOnce(func, key) {
  if (doOnceFlags[key]) {
    return;
  }
  func();
  doOnceFlags[key] = true;
}
var batchedCallsSetTimeout = {
  pending: false,
  funcs: []
};
var batchedCallsRaf = {
  pending: false,
  funcs: []
};
function _batchCall(func, mode = "setTimeout", beans) {
  const batch = mode === "raf" ? batchedCallsRaf : batchedCallsSetTimeout;
  batch.funcs.push(func);
  if (batch.pending) {
    return;
  }
  batch.pending = true;
  const runBatch = () => {
    const funcsCopy = batch.funcs.slice();
    batch.funcs.length = 0;
    batch.pending = false;
    funcsCopy.forEach((func2) => func2());
  };
  if (mode === "raf") {
    _requestAnimationFrame(beans, runBatch);
  } else {
    window.setTimeout(runBatch, 0);
  }
}
function _debounce(bean, func, delay) {
  let timeout;
  return function(...args) {
    const context = this;
    window.clearTimeout(timeout);
    timeout = window.setTimeout(function() {
      if (bean.isAlive()) {
        func.apply(context, args);
      }
    }, delay);
  };
}
function _throttle(func, wait) {
  let previousCall = 0;
  return function(...args) {
    const context = this;
    const currentCall = Date.now();
    if (currentCall - previousCall < wait) {
      return;
    }
    previousCall = currentCall;
    func.apply(context, args);
  };
}
function _waitUntil(bean, condition, callback, timeout = 100) {
  const timeStamp = Date.now();
  let interval = null;
  let executed = false;
  const clearWait = () => {
    if (interval != null) {
      window.clearInterval(interval);
      interval = null;
    }
  };
  bean.addDestroyFunc(clearWait);
  const internalCallback = () => {
    const reachedTimeout = Date.now() - timeStamp > timeout;
    if (condition() || reachedTimeout) {
      callback();
      executed = true;
      clearWait();
    }
  };
  internalCallback();
  if (!executed) {
    interval = window.setInterval(internalCallback, 10);
  }
}
var SKIP_JS_BUILTINS = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function _iterateObject(object, callback) {
  if (object == null) {
    return;
  }
  if (Array.isArray(object)) {
    for (let i = 0; i < object.length; i++) {
      callback(i.toString(), object[i]);
    }
    return;
  }
  for (const key of Object.keys(object).filter((key2) => !SKIP_JS_BUILTINS.has(key2))) {
    callback(key, object[key]);
  }
}
function _mergeDeep(dest, source, copyUndefined = true, makeCopyOfSimpleObjects = false) {
  if (!_exists(source)) {
    return;
  }
  _iterateObject(source, (key, sourceValue) => {
    let destValue = dest[key];
    if (destValue === sourceValue) {
      return;
    }
    if (makeCopyOfSimpleObjects) {
      const objectIsDueToBeCopied = destValue == null && sourceValue != null;
      if (objectIsDueToBeCopied) {
        const doNotCopyAsSourceIsSimpleObject = typeof sourceValue === "object" && sourceValue.constructor === Object;
        if (doNotCopyAsSourceIsSimpleObject) {
          destValue = {};
          dest[key] = destValue;
        }
      }
    }
    if (_isNonNullObject(sourceValue) && _isNonNullObject(destValue) && !Array.isArray(destValue)) {
      _mergeDeep(destValue, sourceValue, copyUndefined, makeCopyOfSimpleObjects);
    } else if (copyUndefined || sourceValue !== void 0) {
      dest[key] = sourceValue;
    }
  });
}
function _isNonNullObject(value) {
  return typeof value === "object" && value !== null;
}
var _GlobalGridOptions = class _GlobalGridOptions2 {
  /**
   * @param providedOptions
   * @returns Shallow copy of the provided options with global options merged in.
   */
  static applyGlobalGridOptions(providedOptions) {
    if (!_GlobalGridOptions2.gridOptions) {
      return { ...providedOptions };
    }
    let mergedGridOps = {};
    _mergeDeep(mergedGridOps, _GlobalGridOptions2.gridOptions, true, true);
    if (_GlobalGridOptions2.mergeStrategy === "deep") {
      _mergeDeep(mergedGridOps, providedOptions, true, true);
    } else {
      mergedGridOps = { ...mergedGridOps, ...providedOptions };
    }
    if (_GlobalGridOptions2.gridOptions.context) {
      mergedGridOps.context = _GlobalGridOptions2.gridOptions.context;
    }
    if (providedOptions.context) {
      if (_GlobalGridOptions2.mergeStrategy === "deep" && mergedGridOps.context) {
        _mergeDeep(providedOptions.context, mergedGridOps.context, true, true);
      }
      mergedGridOps.context = providedOptions.context;
    }
    return mergedGridOps;
  }
};
_GlobalGridOptions.gridOptions = void 0;
_GlobalGridOptions.mergeStrategy = "shallow";
var GlobalGridOptions = _GlobalGridOptions;
var GRID_OPTION_DEFAULTS = {
  suppressContextMenu: false,
  preventDefaultOnContextMenu: false,
  allowContextMenuWithControlKey: false,
  suppressMenuHide: true,
  enableBrowserTooltips: false,
  tooltipTrigger: "hover",
  tooltipShowDelay: 2e3,
  tooltipHideDelay: 1e4,
  tooltipMouseTrack: false,
  tooltipShowMode: "standard",
  tooltipInteraction: false,
  copyHeadersToClipboard: false,
  copyGroupHeadersToClipboard: false,
  clipboardDelimiter: "	",
  suppressCopyRowsToClipboard: false,
  suppressCopySingleCellRanges: false,
  suppressLastEmptyLineOnPaste: false,
  suppressClipboardPaste: false,
  suppressClipboardApi: false,
  suppressCutToClipboard: false,
  maintainColumnOrder: false,
  enableStrictPivotColumnOrder: false,
  suppressFieldDotNotation: false,
  allowDragFromColumnsToolPanel: false,
  suppressMovableColumns: false,
  suppressColumnMoveAnimation: false,
  suppressMoveWhenColumnDragging: false,
  suppressDragLeaveHidesColumns: false,
  suppressRowGroupHidesColumns: false,
  suppressAutoSize: false,
  autoSizePadding: 20,
  skipHeaderOnAutoSize: false,
  singleClickEdit: false,
  suppressClickEdit: false,
  readOnlyEdit: false,
  stopEditingWhenCellsLoseFocus: false,
  enterNavigatesVertically: false,
  enterNavigatesVerticallyAfterEdit: false,
  enableCellEditingOnBackspace: false,
  undoRedoCellEditing: false,
  undoRedoCellEditingLimit: 10,
  suppressCsvExport: false,
  suppressExcelExport: false,
  cacheQuickFilter: false,
  includeHiddenColumnsInQuickFilter: false,
  excludeChildrenWhenTreeDataFiltering: false,
  enableAdvancedFilter: false,
  includeHiddenColumnsInAdvancedFilter: false,
  enableCharts: false,
  masterDetail: false,
  keepDetailRows: false,
  keepDetailRowsCount: 10,
  detailRowAutoHeight: false,
  tabIndex: 0,
  rowBuffer: 10,
  valueCache: false,
  valueCacheNeverExpires: false,
  enableCellExpressions: false,
  suppressTouch: false,
  suppressFocusAfterRefresh: false,
  suppressBrowserResizeObserver: false,
  suppressPropertyNamesCheck: false,
  suppressChangeDetection: false,
  debug: false,
  suppressLoadingOverlay: false,
  suppressNoRowsOverlay: false,
  pagination: false,
  paginationPageSize: 100,
  paginationPageSizeSelector: true,
  paginationAutoPageSize: false,
  paginateChildRows: false,
  suppressPaginationPanel: false,
  pivotMode: false,
  pivotPanelShow: "never",
  pivotDefaultExpanded: 0,
  pivotSuppressAutoColumn: false,
  suppressExpandablePivotGroups: false,
  functionsReadOnly: false,
  suppressAggFuncInHeader: false,
  alwaysAggregateAtRootLevel: false,
  aggregateOnlyChangedColumns: false,
  suppressAggFilteredOnly: false,
  removePivotHeaderRowWhenSingleValueColumn: false,
  animateRows: true,
  cellFlashDuration: 500,
  cellFadeDuration: 1e3,
  allowShowChangeAfterFilter: false,
  domLayout: "normal",
  ensureDomOrder: false,
  enableRtl: false,
  suppressColumnVirtualisation: false,
  suppressMaxRenderedRowRestriction: false,
  suppressRowVirtualisation: false,
  rowDragManaged: false,
  rowDragInsertDelay: 500,
  suppressRowDrag: false,
  suppressMoveWhenRowDragging: false,
  rowDragEntireRow: false,
  rowDragMultiRow: false,
  embedFullWidthRows: false,
  groupDisplayType: "singleColumn",
  groupDefaultExpanded: 0,
  groupMaintainOrder: false,
  groupSelectsChildren: false,
  groupSuppressBlankHeader: false,
  groupSelectsFiltered: false,
  showOpenedGroup: false,
  groupRemoveSingleChildren: false,
  groupRemoveLowestSingleChildren: false,
  groupHideOpenParents: false,
  groupAllowUnbalanced: false,
  rowGroupPanelShow: "never",
  suppressMakeColumnVisibleAfterUnGroup: false,
  treeData: false,
  rowGroupPanelSuppressSort: false,
  suppressGroupRowsSticky: false,
  rowModelType: "clientSide",
  asyncTransactionWaitMillis: 50,
  suppressModelUpdateAfterUpdateTransaction: false,
  cacheOverflowSize: 1,
  infiniteInitialRowCount: 1,
  serverSideInitialRowCount: 1,
  cacheBlockSize: 100,
  maxBlocksInCache: -1,
  maxConcurrentDatasourceRequests: 2,
  blockLoadDebounceMillis: 0,
  purgeClosedRowNodes: false,
  serverSideSortAllLevels: false,
  serverSideOnlyRefreshFilteredGroups: false,
  serverSidePivotResultFieldSeparator: "_",
  viewportRowModelPageSize: 5,
  viewportRowModelBufferSize: 5,
  alwaysShowHorizontalScroll: false,
  alwaysShowVerticalScroll: false,
  debounceVerticalScrollbar: false,
  suppressHorizontalScroll: false,
  suppressScrollOnNewData: false,
  suppressScrollWhenPopupsAreOpen: false,
  suppressAnimationFrame: false,
  suppressMiddleClickScrolls: false,
  suppressPreventDefaultOnMouseWheel: false,
  rowMultiSelectWithClick: false,
  suppressRowDeselection: false,
  suppressRowClickSelection: false,
  suppressCellFocus: false,
  suppressHeaderFocus: false,
  suppressMultiRangeSelection: false,
  enableCellTextSelection: false,
  enableRangeSelection: false,
  enableRangeHandle: false,
  enableFillHandle: false,
  fillHandleDirection: "xy",
  suppressClearOnFillReduction: false,
  accentedSort: false,
  unSortIcon: false,
  suppressMultiSort: false,
  alwaysMultiSort: false,
  suppressMaintainUnsortedOrder: false,
  suppressRowHoverHighlight: false,
  suppressRowTransform: false,
  columnHoverHighlight: false,
  deltaSort: false,
  enableGroupEdit: false,
  groupLockGroupColumns: 0,
  serverSideEnableClientSideSort: false,
  suppressServerSideFullWidthLoadingRow: false,
  pivotMaxGeneratedColumns: -1,
  columnMenu: "new",
  reactiveCustomComponents: true,
  suppressSetFilterByDefault: false,
  rowNumbers: false,
  enableFilterHandlers: false
};
var BASE_URL = "https://www.ag-grid.com";
function _logIfDebug(gos, message, ...args) {
  if (gos.get("debug")) {
    console.log("AG Grid: " + message, ...args);
  }
}
function _warnOnce(msg, ...args) {
  _doOnce(() => console.warn("AG Grid: " + msg, ...args), msg + (args == null ? void 0 : args.join("")));
}
function _errorOnce(msg, ...args) {
  _doOnce(() => console.error("AG Grid: " + msg, ...args), msg + (args == null ? void 0 : args.join("")));
}
var VERSION = "34.2.0";
var MAX_URL_LENGTH = 2e3;
var MIN_PARAM_LENGTH = 100;
var VERSION_PARAM_NAME = "_version_";
var getConsoleMessage = null;
var baseDocLink = `${BASE_URL}/javascript-data-grid`;
function setValidationDocLink(docLink) {
  baseDocLink = docLink;
}
function getErrorParts(id, args, defaultMessage) {
  var _a4;
  return (_a4 = getConsoleMessage == null ? void 0 : getConsoleMessage(id, args)) != null ? _a4 : [minifiedLog(id, args, defaultMessage)];
}
function getMsgOrDefault(logger, id, args, isWarning, defaultMessage) {
  logger(`${isWarning ? "warning" : "error"} #${id}`, ...getErrorParts(id, args, defaultMessage));
}
function stringifyObject(inputObj) {
  if (!inputObj)
    return String(inputObj);
  const object = {};
  for (const prop of Object.keys(inputObj)) {
    if (typeof inputObj[prop] !== "object" && typeof inputObj[prop] !== "function") {
      object[prop] = inputObj[prop];
    }
  }
  return JSON.stringify(object);
}
function stringifyValue(value) {
  let output = value;
  if (value instanceof Error) {
    output = value.toString();
  } else if (typeof value === "object") {
    output = stringifyObject(value);
  }
  return output;
}
function getParamsUrl(baseUrl, params) {
  return `${baseUrl}?${params.toString()}`;
}
function truncateUrl(baseUrl, params, maxLength) {
  const sortedParams = Array.from(params.entries()).sort((a, b) => b[1].length - a[1].length);
  let url = getParamsUrl(baseUrl, params);
  for (const [key, value] of sortedParams) {
    if (key === VERSION_PARAM_NAME) {
      continue;
    }
    const excessLength = url.length - maxLength;
    if (excessLength <= 0) {
      break;
    }
    const ellipse = "...";
    const truncateAmount = excessLength + ellipse.length;
    const truncatedValue = value.length - truncateAmount > MIN_PARAM_LENGTH ? value.slice(0, value.length - truncateAmount) + ellipse : value.slice(0, MIN_PARAM_LENGTH) + ellipse;
    params.set(key, truncatedValue);
    url = getParamsUrl(baseUrl, params);
  }
  return url;
}
function getErrorLink(errorNum, args) {
  const params = new URLSearchParams();
  params.append(VERSION_PARAM_NAME, VERSION);
  if (args) {
    for (const key of Object.keys(args)) {
      params.append(key, stringifyValue(args[key]));
    }
  }
  const baseUrl = `${baseDocLink}/errors/${errorNum}`;
  const url = getParamsUrl(baseUrl, params);
  return url.length <= MAX_URL_LENGTH ? url : truncateUrl(baseUrl, params, MAX_URL_LENGTH);
}
var minifiedLog = (errorNum, args, defaultMessage) => {
  const errorLink = getErrorLink(errorNum, args);
  return `${defaultMessage ? defaultMessage + " \n" : ""}Visit ${errorLink}${defaultMessage ? "" : " \n  Alternatively register the ValidationModule to see the full message in the console."}`;
};
function _warn(...args) {
  getMsgOrDefault(_warnOnce, args[0], args[1], true);
}
function _error(...args) {
  getMsgOrDefault(_errorOnce, args[0], args[1], false);
}
function _logPreInitErr(id, args, defaultMessage) {
  getMsgOrDefault(_errorOnce, id, args, false, defaultMessage);
}
function getErrMsg(defaultMessage, args) {
  const id = args[0];
  return `error #${id} ` + getErrorParts(id, args[1], defaultMessage).join(" ");
}
function _errMsg(...args) {
  return getErrMsg(void 0, args);
}
function isRowModelType(gos, rowModelType) {
  return gos.get("rowModelType") === rowModelType;
}
function _isClientSideRowModel(gos, rowModel) {
  return isRowModelType(gos, "clientSide");
}
function _isServerSideRowModel(gos, rowModel) {
  return isRowModelType(gos, "serverSide");
}
function _isDomLayout(gos, domLayout) {
  return gos.get("domLayout") === domLayout;
}
function _isRowSelection(gos) {
  return _getRowSelectionMode(gos) !== void 0;
}
function _isGetRowHeightFunction(gos) {
  return typeof gos.get("getRowHeight") === "function";
}
function _shouldMaintainColumnOrder(gos, isPivotColumns) {
  if (isPivotColumns) {
    return !gos.get("enableStrictPivotColumnOrder");
  }
  return gos.get("maintainColumnOrder");
}
function _getRowHeightForNode(beans, rowNode, allowEstimate = false, defaultRowHeight) {
  const { gos, environment } = beans;
  if (defaultRowHeight == null) {
    defaultRowHeight = environment.getDefaultRowHeight();
  }
  if (_isGetRowHeightFunction(gos)) {
    if (allowEstimate) {
      return { height: defaultRowHeight, estimated: true };
    }
    const params = {
      node: rowNode,
      data: rowNode.data
    };
    const height = gos.getCallback("getRowHeight")(params);
    if (isNumeric(height)) {
      if (height === 0) {
        _warn(23);
      }
      return { height: Math.max(1, height), estimated: false };
    }
  }
  if (rowNode.detail && gos.get("masterDetail")) {
    return getMasterDetailRowHeight(gos);
  }
  const gridOptionsRowHeight = gos.get("rowHeight");
  const rowHeight = gridOptionsRowHeight && isNumeric(gridOptionsRowHeight) ? gridOptionsRowHeight : defaultRowHeight;
  return { height: rowHeight, estimated: false };
}
function getMasterDetailRowHeight(gos) {
  if (gos.get("detailRowAutoHeight")) {
    return { height: 1, estimated: false };
  }
  const defaultRowHeight = gos.get("detailRowHeight");
  if (isNumeric(defaultRowHeight)) {
    return { height: defaultRowHeight, estimated: false };
  }
  return { height: 300, estimated: false };
}
function _getRowHeightAsNumber(beans) {
  const { environment, gos } = beans;
  const gridOptionsRowHeight = gos.get("rowHeight");
  if (!gridOptionsRowHeight || _missing(gridOptionsRowHeight)) {
    return environment.getDefaultRowHeight();
  }
  const rowHeight = environment.refreshRowHeightVariable();
  if (rowHeight !== -1) {
    return rowHeight;
  }
  _warn(24);
  return environment.getDefaultRowHeight();
}
function isNumeric(value) {
  return !isNaN(value) && typeof value === "number" && isFinite(value);
}
function _getDomData(gos, element, key) {
  const domData = element[gos.getDomDataKey()];
  return domData ? domData[key] : void 0;
}
function _setDomData(gos, element, key, value) {
  const domDataKey = gos.getDomDataKey();
  let domData = element[domDataKey];
  if (_missing(domData)) {
    domData = {};
    element[domDataKey] = domData;
  }
  domData[key] = value;
}
function _isAnimateRows(gos) {
  if (gos.get("ensureDomOrder")) {
    return false;
  }
  return gos.get("animateRows");
}
function _isGroupRowsSticky(gos) {
  if (gos.get("paginateChildRows") || gos.get("groupHideOpenParents") || _isDomLayout(gos, "print")) {
    return false;
  }
  return true;
}
function _isColumnsSortingCoupledToGroup(gos) {
  const autoGroupColumnDef = gos.get("autoGroupColumnDef");
  return !(autoGroupColumnDef == null ? void 0 : autoGroupColumnDef.comparator) && !gos.get("treeData");
}
function _isGroupUseEntireRow(gos, pivotMode) {
  if (pivotMode) {
    return false;
  }
  return gos.get("groupDisplayType") === "groupRows";
}
function _isFullWidthGroupRow(gos, node, pivotMode) {
  return !!node.group && !node.footer && _isGroupUseEntireRow(gos, pivotMode);
}
function _getCheckboxes(selection) {
  var _a4;
  return (_a4 = selection == null ? void 0 : selection.checkboxes) != null ? _a4 : true;
}
function _getCheckboxLocation(rowSelection) {
  var _a4;
  if (typeof rowSelection !== "object") {
    return void 0;
  }
  return (_a4 = rowSelection.checkboxLocation) != null ? _a4 : "selectionColumn";
}
function _isCellSelectionEnabled(gos) {
  const selection = gos.get("cellSelection");
  const useNewAPI = selection !== void 0;
  return useNewAPI ? !!selection : gos.get("enableRangeSelection");
}
function _getRowSelectionMode(arg) {
  const selection = "beanName" in arg && arg.beanName === "gos" ? arg.get("rowSelection") : arg.rowSelection;
  if (typeof selection === "string") {
    switch (selection) {
      case "multiple":
        return "multiRow";
      case "single":
        return "singleRow";
      default:
        return;
    }
  }
  switch (selection == null ? void 0 : selection.mode) {
    case "multiRow":
    case "singleRow":
      return selection.mode;
    default:
      return;
  }
}
function _isMultiRowSelection(arg) {
  const mode = _getRowSelectionMode(arg);
  return mode === "multiRow";
}
function _getSelectAll(gos, defaultValue = true) {
  const rowSelection = gos.get("rowSelection");
  if (typeof rowSelection !== "object") {
    return defaultValue ? "all" : void 0;
  }
  return rowSelection.mode === "multiRow" ? rowSelection.selectAll : "all";
}
function _isLegacyMenuEnabled(gos) {
  return gos.get("columnMenu") === "legacy";
}
function _getCallbackForEvent(eventName) {
  if (!eventName || eventName.length < 2) {
    return eventName;
  }
  return "on" + eventName[0].toUpperCase() + eventName.substring(1);
}
function _addGridCommonParams(gos, params) {
  return gos.addCommon(params);
}
function _interpretAsRightClick({ gos }, event) {
  return event.button === 2 || event.ctrlKey && gos.get("allowContextMenuWithControlKey");
}
var COL_DEF_DEFAULTS = {
  resizable: true,
  sortable: true
};
var instanceIdSequence = 0;
function getNextColInstanceId() {
  return instanceIdSequence++;
}
function isColumn(col) {
  return col instanceof AgColumn;
}
var AgColumn = class extends BeanStub {
  constructor(colDef, userProvidedColDef, colId, primary) {
    super();
    this.colDef = colDef;
    this.userProvidedColDef = userProvidedColDef;
    this.colId = colId;
    this.primary = primary;
    this.isColumn = true;
    this.instanceId = getNextColInstanceId();
    this.autoHeaderHeight = null;
    this.moving = false;
    this.resizing = false;
    this.menuVisible = false;
    this.lastLeftPinned = false;
    this.firstRightPinned = false;
    this.filterActive = false;
    this.colEventSvc = new LocalEventService();
    this.tooltipEnabled = false;
    this.rowGroupActive = false;
    this.pivotActive = false;
    this.aggregationActive = false;
    this.flex = null;
    this.colIdSanitised = _escapeString(colId);
  }
  destroy() {
    var _a4;
    super.destroy();
    (_a4 = this.beans.rowSpanSvc) == null ? void 0 : _a4.deregister(this);
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState() {
    const {
      colDef,
      beans: { sortSvc, pinnedCols, colFlex }
    } = this;
    sortSvc == null ? void 0 : sortSvc.initCol(this);
    const hide = colDef.hide;
    if (hide !== void 0) {
      this.visible = !hide;
    } else {
      this.visible = !colDef.initialHide;
    }
    pinnedCols == null ? void 0 : pinnedCols.initCol(this);
    colFlex == null ? void 0 : colFlex.initCol(this);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(colDef, userProvidedColDef, source) {
    var _a4;
    const colSpanChanged = colDef.spanRows !== this.colDef.spanRows;
    this.colDef = colDef;
    this.userProvidedColDef = userProvidedColDef;
    this.initMinAndMaxWidths();
    this.initDotNotation();
    this.initTooltip();
    if (colSpanChanged) {
      (_a4 = this.beans.rowSpanSvc) == null ? void 0 : _a4.deregister(this);
      this.initRowSpan();
    }
    this.dispatchColEvent("colDefChanged", source);
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  getParent() {
    return this.parent;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  // this is done after constructor as it uses gridOptionsService
  postConstruct() {
    this.setState();
    this.initMinAndMaxWidths();
    this.resetActualWidth("gridInitializing");
    this.initDotNotation();
    this.initTooltip();
    this.initRowSpan();
    this.addPivotListener();
  }
  initDotNotation() {
    const {
      gos,
      colDef: { field, tooltipField }
    } = this;
    const suppressDotNotation = gos.get("suppressFieldDotNotation");
    this.fieldContainsDots = _exists(field) && field.indexOf(".") >= 0 && !suppressDotNotation;
    this.tooltipFieldContainsDots = _exists(tooltipField) && tooltipField.indexOf(".") >= 0 && !suppressDotNotation;
  }
  initMinAndMaxWidths() {
    var _a4, _b2;
    const colDef = this.colDef;
    this.minWidth = (_a4 = colDef.minWidth) != null ? _a4 : this.beans.environment.getDefaultColumnMinWidth();
    this.maxWidth = (_b2 = colDef.maxWidth) != null ? _b2 : Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    var _a4;
    (_a4 = this.beans.tooltipSvc) == null ? void 0 : _a4.initCol(this);
  }
  initRowSpan() {
    var _a4;
    if (this.colDef.spanRows) {
      (_a4 = this.beans.rowSpanSvc) == null ? void 0 : _a4.register(this);
    }
  }
  addPivotListener() {
    const pivotColDefSvc = this.beans.pivotColDefSvc;
    const pivotValueColumn = this.colDef.pivotValueColumn;
    if (!pivotColDefSvc || !pivotValueColumn) {
      return;
    }
    this.addManagedListeners(pivotValueColumn, {
      colDefChanged: (evt) => {
        const colDef = pivotColDefSvc.recreateColDef(this.colDef);
        this.setColDef(colDef, colDef, evt.source);
      }
    });
  }
  resetActualWidth(source) {
    const initialWidth = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(initialWidth, source, true);
  }
  calculateColInitialWidth(colDef) {
    let width;
    const colDefWidth = colDef.width;
    const colDefInitialWidth = colDef.initialWidth;
    if (colDefWidth != null) {
      width = colDefWidth;
    } else if (colDefInitialWidth != null) {
      width = colDefInitialWidth;
    } else {
      width = 200;
    }
    return Math.max(Math.min(width, this.maxWidth), this.minWidth);
  }
  isEmptyGroup() {
    return false;
  }
  isRowGroupDisplayed(colId) {
    var _a4, _b2;
    return (_b2 = (_a4 = this.beans.showRowGroupCols) == null ? void 0 : _a4.isRowGroupDisplayed(this, colId)) != null ? _b2 : false;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    const filterDefined = !!this.colDef.filter;
    return filterDefined;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  getHighlighted() {
    return this.highlighted;
  }
  __addEventListener(eventType, listener) {
    this.colEventSvc.addEventListener(eventType, listener);
  }
  __removeEventListener(eventType, listener) {
    this.colEventSvc.removeEventListener(eventType, listener);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  addEventListener(eventType, userListener) {
    var _a4, _b2, _c, _d;
    this.frameworkEventListenerService = (_b2 = (_a4 = this.beans.frameworkOverrides).createLocalEventListenerWrapper) == null ? void 0 : _b2.call(
      _a4,
      this.frameworkEventListenerService,
      this.colEventSvc
    );
    const listener = (_d = (_c = this.frameworkEventListenerService) == null ? void 0 : _c.wrap(eventType, userListener)) != null ? _d : userListener;
    this.colEventSvc.addEventListener(eventType, listener);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  removeEventListener(eventType, userListener) {
    var _a4, _b2;
    const listener = (_b2 = (_a4 = this.frameworkEventListenerService) == null ? void 0 : _a4.unwrap(eventType, userListener)) != null ? _b2 : userListener;
    this.colEventSvc.removeEventListener(eventType, listener);
  }
  createColumnFunctionCallbackParams(rowNode) {
    return _addGridCommonParams(this.gos, {
      node: rowNode,
      data: rowNode.data,
      column: this,
      colDef: this.colDef
    });
  }
  isSuppressNavigable(rowNode) {
    var _a4, _b2;
    return (_b2 = (_a4 = this.beans.cellNavigation) == null ? void 0 : _a4.isSuppressNavigable(this, rowNode)) != null ? _b2 : false;
  }
  isCellEditable(rowNode) {
    var _a4, _b2;
    return (_b2 = (_a4 = this.beans.editSvc) == null ? void 0 : _a4.isCellEditable({ rowNode, column: this })) != null ? _b2 : false;
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(rowNode) {
    return this.isColumnFunc(rowNode, this.colDef.rowDrag);
  }
  isDndSource(rowNode) {
    return this.isColumnFunc(rowNode, this.colDef.dndSource);
  }
  isCellCheckboxSelection(rowNode) {
    var _a4, _b2;
    return (_b2 = (_a4 = this.beans.selectionSvc) == null ? void 0 : _a4.isCellCheckboxSelection(this, rowNode)) != null ? _b2 : false;
  }
  isSuppressPaste(rowNode) {
    var _a4, _b2;
    return this.isColumnFunc(rowNode, (_b2 = (_a4 = this.colDef) == null ? void 0 : _a4.suppressPaste) != null ? _b2 : null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  /** Get value from ColDef or default if it exists. */
  getColDefValue(key) {
    var _a4;
    return (_a4 = this.colDef[key]) != null ? _a4 : COL_DEF_DEFAULTS[key];
  }
  isColumnFunc(rowNode, value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "function") {
      const params = this.createColumnFunctionCallbackParams(rowNode);
      const editableFunc = value;
      return editableFunc(params);
    }
    return false;
  }
  createColumnEvent(type, source) {
    return _addGridCommonParams(this.gos, {
      type,
      column: this,
      columns: [this],
      source
    });
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  /** @deprecated v32 use col.getSort() === 'asc */
  isSortAscending() {
    return this.sort === "asc";
  }
  /** @deprecated v32 use col.getSort() === 'desc */
  isSortDescending() {
    return this.sort === "desc";
  }
  /** @deprecated v32 use col.getSort() === undefined */
  isSortNone() {
    return _missing(this.sort);
  }
  /** @deprecated v32 use col.getSort() !== undefined */
  isSorting() {
    return _exists(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(left, source) {
    this.oldLeft = this.left;
    if (this.left !== left) {
      this.left = left;
      this.dispatchColEvent("leftChanged", source);
    }
  }
  isFilterActive() {
    return this.filterActive;
  }
  /** @deprecated v33 Use `api.isColumnHovered(column)` instead. */
  isHovered() {
    var _a4;
    _warn(261);
    return !!((_a4 = this.beans.colHover) == null ? void 0 : _a4.isHovered(this));
  }
  setFirstRightPinned(firstRightPinned, source) {
    if (this.firstRightPinned !== firstRightPinned) {
      this.firstRightPinned = firstRightPinned;
      this.dispatchColEvent("firstRightPinnedChanged", source);
    }
  }
  setLastLeftPinned(lastLeftPinned, source) {
    if (this.lastLeftPinned !== lastLeftPinned) {
      this.lastLeftPinned = lastLeftPinned;
      this.dispatchColEvent("lastLeftPinnedChanged", source);
    }
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(visible, source) {
    const newValue = visible === true;
    if (this.visible !== newValue) {
      this.visible = newValue;
      this.dispatchColEvent("visibleChanged", source);
    }
    this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    const colDef = this.getColDef();
    return !colDef.suppressSpanHeaderHeight;
  }
  /**
   * Returns the first parent that is not a padding group.
   */
  getFirstRealParent() {
    let parent = this.getOriginalParent();
    while (parent && parent.isPadding()) {
      parent = parent.getOriginalParent();
    }
    return parent;
  }
  getColumnGroupPaddingInfo() {
    let parent = this.getParent();
    if (!parent || !parent.isPadding()) {
      return { numberOfParents: 0, isSpanningTotal: false };
    }
    const numberOfParents = parent.getPaddingLevel() + 1;
    let isSpanningTotal = true;
    while (parent) {
      if (!parent.isPadding()) {
        isSpanningTotal = false;
        break;
      }
      parent = parent.getParent();
    }
    return { numberOfParents, isSpanningTotal };
  }
  getColDef() {
    return this.colDef;
  }
  getDefinition() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(height) {
    const changed = height !== this.autoHeaderHeight;
    this.autoHeaderHeight = height;
    return changed;
  }
  createBaseColDefParams(rowNode) {
    const params = _addGridCommonParams(this.gos, {
      node: rowNode,
      data: rowNode.data,
      colDef: this.colDef,
      column: this
    });
    return params;
  }
  getColSpan(rowNode) {
    if (_missing(this.colDef.colSpan)) {
      return 1;
    }
    const params = this.createBaseColDefParams(rowNode);
    const colSpan = this.colDef.colSpan(params);
    return Math.max(colSpan, 1);
  }
  getRowSpan(rowNode) {
    if (_missing(this.colDef.rowSpan)) {
      return 1;
    }
    const params = this.createBaseColDefParams(rowNode);
    const rowSpan = this.colDef.rowSpan(params);
    return Math.max(rowSpan, 1);
  }
  setActualWidth(actualWidth, source, silent = false) {
    actualWidth = Math.max(actualWidth, this.minWidth);
    actualWidth = Math.min(actualWidth, this.maxWidth);
    if (this.actualWidth !== actualWidth) {
      this.actualWidth = actualWidth;
      if (this.flex != null && source !== "flex" && source !== "gridInitializing") {
        this.flex = null;
      }
      if (!silent) {
        this.fireColumnWidthChangedEvent(source);
      }
    }
    this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(source) {
    this.dispatchColEvent("widthChanged", source);
  }
  isGreaterThanMax(width) {
    return width > this.maxWidth;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex;
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === true;
  }
  isAllowValue() {
    return this.colDef.enableValue === true;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === true;
  }
  dispatchColEvent(type, source, additionalEventAttributes) {
    const colEvent = this.createColumnEvent(type, source);
    if (additionalEventAttributes) {
      _mergeDeep(colEvent, additionalEventAttributes);
    }
    this.colEventSvc.dispatchEvent(colEvent);
  }
  dispatchStateUpdatedEvent(key) {
    this.colEventSvc.dispatchEvent({
      type: "columnStateUpdated",
      key
    });
  }
};
function isProvidedColumnGroup(col) {
  return col instanceof AgProvidedColumnGroup;
}
var AgProvidedColumnGroup = class extends BeanStub {
  constructor(colGroupDef, groupId, padding, level) {
    super();
    this.colGroupDef = colGroupDef;
    this.groupId = groupId;
    this.padding = padding;
    this.level = level;
    this.isColumn = false;
    this.expandable = false;
    this.instanceId = getNextColInstanceId();
    this.expandableListenerRemoveCallback = null;
    this.expanded = !!(colGroupDef == null ? void 0 : colGroupDef.openByDefault);
  }
  destroy() {
    if (this.expandableListenerRemoveCallback) {
      this.reset(null, void 0);
    }
    super.destroy();
  }
  reset(colGroupDef, level) {
    this.colGroupDef = colGroupDef;
    this.level = level;
    this.originalParent = null;
    if (this.expandableListenerRemoveCallback) {
      this.expandableListenerRemoveCallback();
    }
    this.children = void 0;
    this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    if (this.children) {
      return this.children.some((child) => child.isVisible());
    }
    return false;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(expanded) {
    this.expanded = expanded === void 0 ? false : expanded;
    this.dispatchLocalEvent({ type: "expandedChanged" });
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(children) {
    this.children = children;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const result = [];
    this.addLeafColumns(result);
    return result;
  }
  forEachLeafColumn(callback) {
    if (!this.children) {
      return;
    }
    for (const child of this.children) {
      if (isColumn(child)) {
        callback(child);
      } else if (isProvidedColumnGroup(child)) {
        child.forEachLeafColumn(callback);
      }
    }
  }
  addLeafColumns(leafColumns) {
    if (!this.children) {
      return;
    }
    this.children.forEach((child) => {
      if (isColumn(child)) {
        leafColumns.push(child);
      } else if (isProvidedColumnGroup(child)) {
        child.addLeafColumns(leafColumns);
      }
    });
  }
  getColumnGroupShow() {
    const colGroupDef = this.colGroupDef;
    if (!colGroupDef) {
      return;
    }
    return colGroupDef.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable();
    if (this.expandableListenerRemoveCallback) {
      this.expandableListenerRemoveCallback();
    }
    const listener = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((col) => col.__addEventListener("visibleChanged", listener));
    this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((col) => col.__removeEventListener("visibleChanged", listener));
      this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding()) {
      return;
    }
    let atLeastOneShowingWhenOpen = false;
    let atLeastOneShowingWhenClosed = false;
    let atLeastOneChangeable = false;
    const children = this.findChildrenRemovingPadding();
    for (let i = 0, j = children.length; i < j; i++) {
      const abstractColumn = children[i];
      if (!abstractColumn.isVisible()) {
        continue;
      }
      const headerGroupShow = abstractColumn.getColumnGroupShow();
      if (headerGroupShow === "open") {
        atLeastOneShowingWhenOpen = true;
        atLeastOneChangeable = true;
      } else if (headerGroupShow === "closed") {
        atLeastOneShowingWhenClosed = true;
        atLeastOneChangeable = true;
      } else {
        atLeastOneShowingWhenOpen = true;
        atLeastOneShowingWhenClosed = true;
      }
    }
    const expandable = atLeastOneShowingWhenOpen && atLeastOneShowingWhenClosed && atLeastOneChangeable;
    if (this.expandable !== expandable) {
      this.expandable = expandable;
      this.dispatchLocalEvent({ type: "expandableChanged" });
    }
  }
  findChildrenRemovingPadding() {
    const res = [];
    const process = (items) => {
      items.forEach((item) => {
        const skipBecausePadding = isProvidedColumnGroup(item) && item.isPadding();
        if (skipBecausePadding) {
          process(item.children);
        } else {
          res.push(item);
        }
      });
    };
    process(this.children);
    return res;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
};
var DefaultColumnTypes = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
};
function createMergedColGroupDef(beans, colGroupDef, groupId) {
  const colGroupDefMerged = {};
  const gos = beans.gos;
  Object.assign(colGroupDefMerged, gos.get("defaultColGroupDef"));
  Object.assign(colGroupDefMerged, colGroupDef);
  gos.validateColDef(colGroupDefMerged, groupId);
  return colGroupDefMerged;
}
var ColumnKeyCreator = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(keys) {
    for (let i = 0; i < keys.length; i++) {
      this.existingKeys[keys[i]] = true;
    }
  }
  getUniqueKey(colId, colField) {
    colId = _toStringOrNull(colId);
    let count = 0;
    while (true) {
      let idToTry = colId != null ? colId : colField;
      if (idToTry) {
        if (count !== 0) {
          idToTry += "_" + count;
        }
      } else {
        idToTry = count;
      }
      if (!this.existingKeys[idToTry]) {
        const usedId = String(idToTry);
        if (colId && count > 0) {
          _warn(273, { providedId: colId, usedId });
        }
        this.existingKeys[usedId] = true;
        return usedId;
      }
      count++;
    }
  }
};
var _EmptyArray = Object.freeze([]);
function _last(arr) {
  if (!(arr == null ? void 0 : arr.length)) {
    return;
  }
  return arr[arr.length - 1];
}
function _areEqual(a, b, comparator) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return a == null && b == null;
  }
  const len = a.length;
  if (len !== b.length) {
    return false;
  }
  for (let i = 0; i < len; i++) {
    if (a[i] !== b[i] && !(comparator == null ? void 0 : comparator(a[i], b[i]))) {
      return false;
    }
  }
  return true;
}
function _forAll(array, callback) {
  if (!array) {
    return;
  }
  for (const value of array) {
    callback(value);
  }
}
function _removeFromArray(array, object) {
  const index = array.indexOf(object);
  if (index >= 0) {
    array.splice(index, 1);
  }
}
function _moveInArray(array, objectsToMove, toIndex) {
  for (let i = 0; i < objectsToMove.length; i++) {
    _removeFromArray(array, objectsToMove[i]);
  }
  for (let i = objectsToMove.length - 1; i >= 0; i--) {
    array.splice(toIndex, 0, objectsToMove[i]);
  }
}
var GROUP_AUTO_COLUMN_ID = "ag-Grid-AutoColumn";
var SELECTION_COLUMN_ID = "ag-Grid-SelectionColumn";
var ROW_NUMBERS_COLUMN_ID = "ag-Grid-RowNumbersColumn";
function _getColumnsFromTree(rootColumns) {
  const result = [];
  const recursiveFindColumns = (childColumns) => {
    for (let i = 0; i < childColumns.length; i++) {
      const child = childColumns[i];
      if (isColumn(child)) {
        result.push(child);
      } else if (isProvidedColumnGroup(child)) {
        recursiveFindColumns(child.getChildren());
      }
    }
  };
  recursiveFindColumns(rootColumns);
  return result;
}
function getWidthOfColsInList(columnList) {
  return columnList.reduce((width, col) => width + col.getActualWidth(), 0);
}
function _destroyColumnTree(beans, oldTree, newTree) {
  const oldObjectsById = {};
  if (!oldTree) {
    return;
  }
  depthFirstOriginalTreeSearch(null, oldTree, (child) => {
    oldObjectsById[child.getInstanceId()] = child;
  });
  if (newTree) {
    depthFirstOriginalTreeSearch(null, newTree, (child) => {
      oldObjectsById[child.getInstanceId()] = null;
    });
  }
  const colsToDestroy = Object.values(oldObjectsById).filter((item) => item != null);
  beans.context.destroyBeans(colsToDestroy);
}
function isColumnGroupAutoCol(col) {
  const colId = col.getId();
  return colId.startsWith(GROUP_AUTO_COLUMN_ID);
}
function isColumnSelectionCol(col) {
  var _a4;
  const id = typeof col === "string" ? col : "getColId" in col ? col.getColId() : col.colId;
  return (_a4 = id == null ? void 0 : id.startsWith(SELECTION_COLUMN_ID)) != null ? _a4 : false;
}
function isRowNumberCol(col) {
  var _a4;
  const id = typeof col === "string" ? col : "getColId" in col ? col.getColId() : col.colId;
  return (_a4 = id == null ? void 0 : id.startsWith(ROW_NUMBERS_COLUMN_ID)) != null ? _a4 : false;
}
function convertColumnTypes(type) {
  let typeKeys = [];
  if (type instanceof Array) {
    typeKeys = type;
  } else if (typeof type === "string") {
    typeKeys = type.split(",");
  }
  return typeKeys;
}
function _convertColumnEventSourceType(source) {
  return source === "optionsUpdated" ? "gridOptionsChanged" : source;
}
function _columnsMatch(column, key) {
  const columnMatches = column === key;
  const colDefMatches = column.getColDef() === key;
  const idMatches = column.getColId() == key;
  return columnMatches || colDefMatches || idMatches;
}
var getValueFactory = (stateItem, defaultState) => (key1, key2) => {
  const obj = {
    value1: void 0,
    value2: void 0
  };
  let calculated = false;
  if (stateItem) {
    if (stateItem[key1] !== void 0) {
      obj.value1 = stateItem[key1];
      calculated = true;
    }
    if (_exists(key2) && stateItem[key2] !== void 0) {
      obj.value2 = stateItem[key2];
      calculated = true;
    }
  }
  if (!calculated && defaultState) {
    if (defaultState[key1] !== void 0) {
      obj.value1 = defaultState[key1];
    }
    if (_exists(key2) && defaultState[key2] !== void 0) {
      obj.value2 = defaultState[key2];
    }
  }
  return obj;
};
function _createColumnTree(beans, defs = null, primaryColumns, existingTree, source) {
  var _a4;
  const columnKeyCreator = new ColumnKeyCreator();
  const { existingCols, existingGroups, existingColKeys } = extractExistingTreeData(existingTree);
  columnKeyCreator.addExistingKeys(existingColKeys);
  const unbalancedTree = _recursivelyCreateColumns(
    beans,
    defs,
    0,
    primaryColumns,
    existingCols,
    columnKeyCreator,
    existingGroups,
    source
  );
  const { colGroupSvc } = beans;
  const treeDepth = (_a4 = colGroupSvc == null ? void 0 : colGroupSvc.findMaxDepth(unbalancedTree, 0)) != null ? _a4 : 0;
  const columnTree = colGroupSvc ? colGroupSvc.balanceColumnTree(unbalancedTree, 0, treeDepth, columnKeyCreator) : unbalancedTree;
  const depthFirstCallback = (child, parent) => {
    if (isProvidedColumnGroup(child)) {
      child.setupExpandable();
    }
    child.originalParent = parent;
  };
  depthFirstOriginalTreeSearch(null, columnTree, depthFirstCallback);
  return {
    columnTree,
    treeDepth
  };
}
function extractExistingTreeData(existingTree) {
  const existingCols = [];
  const existingGroups = [];
  const existingColKeys = [];
  if (existingTree) {
    depthFirstOriginalTreeSearch(null, existingTree, (item) => {
      if (isProvidedColumnGroup(item)) {
        const group = item;
        existingGroups.push(group);
      } else {
        const col = item;
        existingColKeys.push(col.getId());
        existingCols.push(col);
      }
    });
  }
  return { existingCols, existingGroups, existingColKeys };
}
function _recursivelyCreateColumns(beans, defs, level, primaryColumns, existingColsCopy, columnKeyCreator, existingGroups, source) {
  if (!defs)
    return [];
  const { colGroupSvc } = beans;
  const result = new Array(defs.length);
  for (let i = 0; i < result.length; i++) {
    const def = defs[i];
    if (colGroupSvc && isColumnGroupDef(def)) {
      result[i] = colGroupSvc.createProvidedColumnGroup(
        primaryColumns,
        def,
        level,
        existingColsCopy,
        columnKeyCreator,
        existingGroups,
        source
      );
    } else {
      result[i] = createColumn(beans, primaryColumns, def, existingColsCopy, columnKeyCreator, source);
    }
  }
  return result;
}
function createColumn(beans, primaryColumns, colDef, existingColsCopy, columnKeyCreator, source) {
  var _a4;
  const existingColAndIndex = findExistingColumn(colDef, existingColsCopy);
  if (existingColAndIndex) {
    existingColsCopy == null ? void 0 : existingColsCopy.splice(existingColAndIndex.idx, 1);
  }
  let column = existingColAndIndex == null ? void 0 : existingColAndIndex.column;
  if (!column) {
    const colId = columnKeyCreator.getUniqueKey(colDef.colId, colDef.field);
    const colDefMerged = _addColumnDefaultAndTypes(beans, colDef, colId);
    column = new AgColumn(colDefMerged, colDef, colId, primaryColumns);
    beans.context.createBean(column);
  } else {
    const colDefMerged = _addColumnDefaultAndTypes(beans, colDef, column.getColId());
    column.setColDef(colDefMerged, colDef, source);
    _updateColumnState(beans, column, colDefMerged, source);
  }
  (_a4 = beans.dataTypeSvc) == null ? void 0 : _a4.addColumnListeners(column);
  return column;
}
function updateSomeColumnState(beans, column, hide, sort, sortIndex, pinned, flex, source) {
  const { sortSvc, pinnedCols, colFlex } = beans;
  if (hide !== void 0) {
    column.setVisible(!hide, source);
  }
  if (sortSvc) {
    sortSvc.updateColSort(column, sort, source);
    if (sortIndex !== void 0) {
      sortSvc.setColSortIndex(column, sortIndex);
    }
  }
  if (pinned !== void 0) {
    pinnedCols == null ? void 0 : pinnedCols.setColPinned(column, pinned);
  }
  if (flex !== void 0) {
    colFlex == null ? void 0 : colFlex.setColFlex(column, flex);
  }
}
function _updateColumnState(beans, column, colDef, source) {
  updateSomeColumnState(
    beans,
    column,
    colDef.hide,
    colDef.sort,
    colDef.sortIndex,
    colDef.pinned,
    colDef.flex,
    source
  );
  const colFlex = column.getFlex();
  if (colFlex != null && colFlex > 0) {
    return;
  }
  if (colDef.width != null) {
    column.setActualWidth(colDef.width, source);
  } else {
    const widthBeforeUpdate = column.getActualWidth();
    column.setActualWidth(widthBeforeUpdate, source);
  }
}
function findExistingColumn(newColDef, existingColsCopy) {
  if (!existingColsCopy)
    return void 0;
  for (let i = 0; i < existingColsCopy.length; i++) {
    const def = existingColsCopy[i].getUserProvidedColDef();
    if (!def)
      continue;
    const newHasId = newColDef.colId != null;
    if (newHasId) {
      if (existingColsCopy[i].getId() === newColDef.colId) {
        return { idx: i, column: existingColsCopy[i] };
      }
      continue;
    }
    const newHasField = newColDef.field != null;
    if (newHasField) {
      if (def.field === newColDef.field) {
        return { idx: i, column: existingColsCopy[i] };
      }
      continue;
    }
    if (def === newColDef) {
      return { idx: i, column: existingColsCopy[i] };
    }
  }
  return void 0;
}
function _addColumnDefaultAndTypes(beans, colDef, colId, isAutoCol) {
  const { gos, dataTypeSvc } = beans;
  const res = {};
  const defaultColDef = gos.get("defaultColDef");
  _mergeDeep(res, defaultColDef, false, true);
  const columnType = updateColDefAndGetColumnType(beans, res, colDef, colId);
  if (columnType) {
    assignColumnTypes(beans, columnType, res);
  }
  const cellDataType = res.cellDataType;
  _mergeDeep(res, colDef, false, true);
  if (cellDataType !== void 0) {
    res.cellDataType = cellDataType;
  }
  const autoGroupColDef = gos.get("autoGroupColumnDef");
  const isSortingCoupled = _isColumnsSortingCoupledToGroup(gos);
  if (colDef.rowGroup && autoGroupColDef && isSortingCoupled) {
    _mergeDeep(
      res,
      { sort: autoGroupColDef.sort, initialSort: autoGroupColDef.initialSort },
      false,
      true
    );
  }
  if (dataTypeSvc) {
    dataTypeSvc.postProcess(res);
    dataTypeSvc.validateColDef(res);
  }
  gos.validateColDef(res, colId, isAutoCol);
  return res;
}
function updateColDefAndGetColumnType(beans, colDef, userColDef, colId) {
  var _a4, _b2, _c;
  const dataTypeDefinitionColumnType = (_a4 = beans.dataTypeSvc) == null ? void 0 : _a4.updateColDefAndGetColumnType(colDef, userColDef, colId);
  const columnTypes = (_c = (_b2 = userColDef.type) != null ? _b2 : dataTypeDefinitionColumnType) != null ? _c : colDef.type;
  colDef.type = columnTypes;
  return columnTypes ? convertColumnTypes(columnTypes) : void 0;
}
function assignColumnTypes(beans, typeKeys, colDefMerged) {
  if (!typeKeys.length) {
    return;
  }
  const allColumnTypes = Object.assign({}, DefaultColumnTypes);
  const userTypes = beans.gos.get("columnTypes") || {};
  for (const key of Object.keys(userTypes)) {
    const value = userTypes[key];
    if (key in allColumnTypes) {
      _warn(34, { key });
    } else {
      const colType = value;
      if (colType.type) {
        _warn(35);
      }
      allColumnTypes[key] = value;
    }
  }
  typeKeys.forEach((t) => {
    const typeColDef = allColumnTypes[t.trim()];
    if (typeColDef) {
      _mergeDeep(colDefMerged, typeColDef, false, true);
    } else {
      _warn(36, { t });
    }
  });
}
function isColumnGroupDef(abstractColDef) {
  return abstractColDef.children !== void 0;
}
function depthFirstOriginalTreeSearch(parent, tree, callback) {
  if (!tree) {
    return;
  }
  for (let i = 0; i < tree.length; i++) {
    const child = tree[i];
    if (isProvidedColumnGroup(child)) {
      depthFirstOriginalTreeSearch(child, child.getChildren(), callback);
    }
    callback(child, parent);
  }
}
function placeLockedColumns(cols, gos) {
  const left = [];
  const normal = [];
  const right = [];
  cols.forEach((col) => {
    const position = col.getColDef().lockPosition;
    if (position === "right") {
      right.push(col);
    } else if (position === "left" || position === true) {
      left.push(col);
    } else {
      normal.push(col);
    }
  });
  const isRtl = gos.get("enableRtl");
  if (isRtl) {
    return [...right, ...normal, ...left];
  }
  return [...left, ...normal, ...right];
}
function doesMovePassMarryChildren(allColumnsCopy, gridBalancedTree) {
  let rulePassed = true;
  depthFirstOriginalTreeSearch(null, gridBalancedTree, (child) => {
    if (!isProvidedColumnGroup(child)) {
      return;
    }
    const columnGroup = child;
    const colGroupDef = columnGroup.getColGroupDef();
    const marryChildren = colGroupDef && colGroupDef.marryChildren;
    if (!marryChildren) {
      return;
    }
    const newIndexes = [];
    columnGroup.getLeafColumns().forEach((col) => {
      const newColIndex = allColumnsCopy.indexOf(col);
      newIndexes.push(newColIndex);
    });
    const maxIndex = Math.max.apply(Math, newIndexes);
    const minIndex = Math.min.apply(Math, newIndexes);
    const spread = maxIndex - minIndex;
    const maxSpread = columnGroup.getLeafColumns().length - 1;
    if (spread > maxSpread) {
      rulePassed = false;
    }
  });
  return rulePassed;
}
function getCommonValue(cols, valueGetter) {
  if (!cols || cols.length == 0) {
    return void 0;
  }
  const firstValue = valueGetter(cols[0]);
  for (let i = 1; i < cols.length; i++) {
    if (firstValue !== valueGetter(cols[i])) {
      return void 0;
    }
  }
  return firstValue;
}
function dispatchColumnPinnedEvent(eventSvc, changedColumns, source) {
  if (!changedColumns.length) {
    return;
  }
  const column = changedColumns.length === 1 ? changedColumns[0] : null;
  const pinned = getCommonValue(changedColumns, (col) => col.getPinned());
  eventSvc.dispatchEvent({
    type: "columnPinned",
    // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
    pinned: pinned != null ? pinned : null,
    columns: changedColumns,
    column,
    source
  });
}
function dispatchColumnVisibleEvent(eventSvc, changedColumns, source) {
  if (!changedColumns.length) {
    return;
  }
  const column = changedColumns.length === 1 ? changedColumns[0] : null;
  const visible = getCommonValue(changedColumns, (col) => col.isVisible());
  eventSvc.dispatchEvent({
    type: "columnVisible",
    visible,
    columns: changedColumns,
    column,
    source
  });
}
function dispatchColumnChangedEvent(eventSvc, type, columns, source) {
  eventSvc.dispatchEvent({
    type,
    columns,
    column: columns && columns.length == 1 ? columns[0] : null,
    source
  });
}
function dispatchColumnResizedEvent(eventSvc, columns, finished, source, flexColumns = null) {
  if (columns == null ? void 0 : columns.length) {
    eventSvc.dispatchEvent({
      type: "columnResized",
      columns,
      column: columns.length === 1 ? columns[0] : null,
      flexColumns,
      finished,
      source
    });
  }
}
function _applyColumnState(beans, params, source) {
  var _a4, _b2, _c;
  const {
    colModel,
    rowGroupColsSvc,
    pivotColsSvc,
    autoColSvc,
    selectionColSvc,
    colAnimation,
    visibleCols,
    pivotResultCols,
    environment,
    valueColsSvc,
    eventSvc,
    gos
  } = beans;
  const providedCols = (_a4 = colModel.getColDefCols()) != null ? _a4 : [];
  const selectionCols = selectionColSvc == null ? void 0 : selectionColSvc.getColumns();
  if (!providedCols.length && !(selectionCols == null ? void 0 : selectionCols.length)) {
    return false;
  }
  if ((params == null ? void 0 : params.state) && !params.state.forEach) {
    _warn(32);
    return false;
  }
  const syncColumnWithStateItem = (column, stateItem, rowGroupIndexes, pivotIndexes, autoCol) => {
    var _a5;
    if (!column) {
      return;
    }
    const getValue = getValueFactory(stateItem, params.defaultState);
    const flex = getValue("flex").value1;
    updateSomeColumnState(
      beans,
      column,
      getValue("hide").value1,
      getValue("sort").value1,
      getValue("sortIndex").value1,
      getValue("pinned").value1,
      flex,
      source
    );
    if (flex == null) {
      const width = getValue("width").value1;
      if (width != null) {
        const minColWidth = (_a5 = column.getColDef().minWidth) != null ? _a5 : environment.getDefaultColumnMinWidth();
        if (minColWidth != null && width >= minColWidth) {
          column.setActualWidth(width, source);
        }
      }
    }
    if (autoCol || !column.isPrimary()) {
      return;
    }
    valueColsSvc == null ? void 0 : valueColsSvc.syncColumnWithState(column, source, getValue);
    rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.syncColumnWithState(column, source, getValue, rowGroupIndexes);
    pivotColsSvc == null ? void 0 : pivotColsSvc.syncColumnWithState(column, source, getValue, pivotIndexes);
  };
  const applyStates = (states, existingColumns, getById2) => {
    var _a5, _b3, _c2, _d;
    const dispatchEventsFunc = _compareColumnStatesAndDispatchEvents(beans, source);
    const columnsWithNoState = existingColumns.slice();
    const rowGroupIndexes = {};
    const pivotIndexes = {};
    const autoColStates = [];
    const selectionColStates = [];
    const unmatchedAndAutoStates2 = [];
    let unmatchedCount2 = 0;
    const previousRowGroupCols = (_a5 = rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.columns.slice()) != null ? _a5 : [];
    const previousPivotCols = (_b3 = pivotColsSvc == null ? void 0 : pivotColsSvc.columns.slice()) != null ? _b3 : [];
    states.forEach((state) => {
      const colId = state.colId;
      const isAutoGroupColumn = colId.startsWith(GROUP_AUTO_COLUMN_ID);
      if (isAutoGroupColumn) {
        autoColStates.push(state);
        unmatchedAndAutoStates2.push(state);
        return;
      }
      if (isColumnSelectionCol(colId)) {
        selectionColStates.push(state);
        unmatchedAndAutoStates2.push(state);
        return;
      }
      const column = getById2(colId);
      if (!column) {
        unmatchedAndAutoStates2.push(state);
        unmatchedCount2 += 1;
      } else {
        syncColumnWithStateItem(column, state, rowGroupIndexes, pivotIndexes, false);
        _removeFromArray(columnsWithNoState, column);
      }
    });
    const applyDefaultsFunc = (col) => syncColumnWithStateItem(col, null, rowGroupIndexes, pivotIndexes, false);
    columnsWithNoState.forEach(applyDefaultsFunc);
    rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.sortColumns(comparatorByIndex.bind(rowGroupColsSvc, rowGroupIndexes, previousRowGroupCols));
    pivotColsSvc == null ? void 0 : pivotColsSvc.sortColumns(comparatorByIndex.bind(pivotColsSvc, pivotIndexes, previousPivotCols));
    colModel.refreshCols(false);
    const syncColStates = (getCol, colStates, columns = []) => {
      colStates.forEach((stateItem) => {
        const col = getCol(stateItem.colId);
        _removeFromArray(columns, col);
        syncColumnWithStateItem(col, stateItem, null, null, true);
      });
      columns.forEach(applyDefaultsFunc);
    };
    syncColStates(
      (colId) => {
        var _a6;
        return (_a6 = autoColSvc == null ? void 0 : autoColSvc.getColumn(colId)) != null ? _a6 : null;
      },
      autoColStates,
      (_c2 = autoColSvc == null ? void 0 : autoColSvc.getColumns()) == null ? void 0 : _c2.slice()
    );
    syncColStates(
      (colId) => {
        var _a6;
        return (_a6 = selectionColSvc == null ? void 0 : selectionColSvc.getColumn(colId)) != null ? _a6 : null;
      },
      selectionColStates,
      (_d = selectionColSvc == null ? void 0 : selectionColSvc.getColumns()) == null ? void 0 : _d.slice()
    );
    orderLiveColsLikeState(params, colModel, gos);
    visibleCols.refresh(source);
    eventSvc.dispatchEvent({
      type: "columnEverythingChanged",
      source
    });
    dispatchEventsFunc();
    return { unmatchedAndAutoStates: unmatchedAndAutoStates2, unmatchedCount: unmatchedCount2 };
  };
  colAnimation == null ? void 0 : colAnimation.start();
  let { unmatchedAndAutoStates, unmatchedCount } = applyStates(
    params.state || [],
    providedCols,
    (id) => colModel.getColDefCol(id)
  );
  if (unmatchedAndAutoStates.length > 0 || _exists(params.defaultState)) {
    const pivotResultColsList = (_c = (_b2 = pivotResultCols == null ? void 0 : pivotResultCols.getPivotResultCols()) == null ? void 0 : _b2.list) != null ? _c : [];
    unmatchedCount = applyStates(
      unmatchedAndAutoStates,
      pivotResultColsList,
      (id) => {
        var _a5;
        return (_a5 = pivotResultCols == null ? void 0 : pivotResultCols.getPivotResultCol(id)) != null ? _a5 : null;
      }
    ).unmatchedCount;
  }
  colAnimation == null ? void 0 : colAnimation.finish();
  return unmatchedCount === 0;
}
function _compareColumnStatesAndDispatchEvents(beans, source) {
  var _a4, _b2, _c;
  const { rowGroupColsSvc, pivotColsSvc, valueColsSvc, colModel, sortSvc, eventSvc } = beans;
  const startState = {
    rowGroupColumns: (_a4 = rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.columns.slice()) != null ? _a4 : [],
    pivotColumns: (_b2 = pivotColsSvc == null ? void 0 : pivotColsSvc.columns.slice()) != null ? _b2 : [],
    valueColumns: (_c = valueColsSvc == null ? void 0 : valueColsSvc.columns.slice()) != null ? _c : []
  };
  const columnStateBefore = _getColumnState(beans);
  const columnStateBeforeMap = {};
  columnStateBefore.forEach((col) => {
    columnStateBeforeMap[col.colId] = col;
  });
  return () => {
    var _a5, _b3;
    const dispatchWhenListsDifferent = (eventType, colsBefore, colsAfter, idMapper) => {
      const beforeList = colsBefore.map(idMapper);
      const afterList = colsAfter.map(idMapper);
      const unchanged = _areEqual(beforeList, afterList);
      if (unchanged) {
        return;
      }
      const changes = new Set(colsBefore);
      colsAfter.forEach((id) => {
        if (!changes.delete(id)) {
          changes.add(id);
        }
      });
      const changesArr = [...changes];
      eventSvc.dispatchEvent({
        type: eventType,
        columns: changesArr,
        column: changesArr.length === 1 ? changesArr[0] : null,
        source
      });
    };
    const getChangedColumns = (changedPredicate) => {
      const changedColumns2 = [];
      colModel.forAllCols((column) => {
        const colStateBefore = columnStateBeforeMap[column.getColId()];
        if (colStateBefore && changedPredicate(colStateBefore, column)) {
          changedColumns2.push(column);
        }
      });
      return changedColumns2;
    };
    const columnIdMapper = (c) => c.getColId();
    dispatchWhenListsDifferent(
      "columnRowGroupChanged",
      startState.rowGroupColumns,
      (_a5 = rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.columns) != null ? _a5 : [],
      columnIdMapper
    );
    dispatchWhenListsDifferent(
      "columnPivotChanged",
      startState.pivotColumns,
      (_b3 = pivotColsSvc == null ? void 0 : pivotColsSvc.columns) != null ? _b3 : [],
      columnIdMapper
    );
    const valueChangePredicate = (cs, c) => {
      const oldActive = cs.aggFunc != null;
      const activeChanged = oldActive != c.isValueActive();
      const aggFuncChanged = oldActive && cs.aggFunc != c.getAggFunc();
      return activeChanged || aggFuncChanged;
    };
    const changedValues = getChangedColumns(valueChangePredicate);
    if (changedValues.length > 0) {
      dispatchColumnChangedEvent(eventSvc, "columnValueChanged", changedValues, source);
    }
    const resizeChangePredicate = (cs, c) => cs.width != c.getActualWidth();
    dispatchColumnResizedEvent(eventSvc, getChangedColumns(resizeChangePredicate), true, source);
    const pinnedChangePredicate = (cs, c) => cs.pinned != c.getPinned();
    dispatchColumnPinnedEvent(eventSvc, getChangedColumns(pinnedChangePredicate), source);
    const visibilityChangePredicate = (cs, c) => cs.hide == c.isVisible();
    dispatchColumnVisibleEvent(eventSvc, getChangedColumns(visibilityChangePredicate), source);
    const sortChangePredicate = (cs, c) => cs.sort != c.getSort() || cs.sortIndex != c.getSortIndex();
    const changedColumns = getChangedColumns(sortChangePredicate);
    if (changedColumns.length > 0) {
      sortSvc == null ? void 0 : sortSvc.dispatchSortChangedEvents(source, changedColumns);
    }
    const colStateAfter = _getColumnState(beans);
    normaliseColumnMovedEventForColumnState(columnStateBefore, colStateAfter, source, colModel, eventSvc);
  };
}
function _getColumnState(beans) {
  const { colModel, rowGroupColsSvc, pivotColsSvc } = beans;
  const primaryCols = colModel.getColDefCols();
  if (_missing(primaryCols) || !colModel.isAlive()) {
    return [];
  }
  const rowGroupColumns = rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.columns;
  const pivotColumns = pivotColsSvc == null ? void 0 : pivotColsSvc.columns;
  const res = [];
  const createStateItemFromColumn = (column) => {
    var _a4;
    const rowGroupIndex = column.isRowGroupActive() && rowGroupColumns ? rowGroupColumns.indexOf(column) : null;
    const pivotIndex = column.isPivotActive() && pivotColumns ? pivotColumns.indexOf(column) : null;
    const aggFunc = column.isValueActive() ? column.getAggFunc() : null;
    const sort = column.getSort() != null ? column.getSort() : null;
    const sortIndex = column.getSortIndex() != null ? column.getSortIndex() : null;
    res.push({
      colId: column.getColId(),
      width: column.getActualWidth(),
      hide: !column.isVisible(),
      pinned: column.getPinned(),
      sort,
      sortIndex,
      aggFunc,
      rowGroup: column.isRowGroupActive(),
      rowGroupIndex,
      pivot: column.isPivotActive(),
      pivotIndex,
      flex: (_a4 = column.getFlex()) != null ? _a4 : null
    });
  };
  colModel.forAllCols((col) => createStateItemFromColumn(col));
  const colIdToGridIndexMap = new Map(
    colModel.getCols().map((col, index) => [col.getColId(), index])
  );
  res.sort((itemA, itemB) => {
    const posA = colIdToGridIndexMap.has(itemA.colId) ? colIdToGridIndexMap.get(itemA.colId) : -1;
    const posB = colIdToGridIndexMap.has(itemB.colId) ? colIdToGridIndexMap.get(itemB.colId) : -1;
    return posA - posB;
  });
  return res;
}
function getColumnStateFromColDef(column) {
  const getValueOrNull = (a, b) => a != null ? a : b != null ? b : null;
  const colDef = column.getColDef();
  const sort = getValueOrNull(colDef.sort, colDef.initialSort);
  const sortIndex = getValueOrNull(colDef.sortIndex, colDef.initialSortIndex);
  const hide = getValueOrNull(colDef.hide, colDef.initialHide);
  const pinned = getValueOrNull(colDef.pinned, colDef.initialPinned);
  const width = getValueOrNull(colDef.width, colDef.initialWidth);
  const flex = getValueOrNull(colDef.flex, colDef.initialFlex);
  let rowGroupIndex = getValueOrNull(colDef.rowGroupIndex, colDef.initialRowGroupIndex);
  let rowGroup = getValueOrNull(colDef.rowGroup, colDef.initialRowGroup);
  if (rowGroupIndex == null && (rowGroup == null || rowGroup == false)) {
    rowGroupIndex = null;
    rowGroup = null;
  }
  let pivotIndex = getValueOrNull(colDef.pivotIndex, colDef.initialPivotIndex);
  let pivot = getValueOrNull(colDef.pivot, colDef.initialPivot);
  if (pivotIndex == null && (pivot == null || pivot == false)) {
    pivotIndex = null;
    pivot = null;
  }
  const aggFunc = getValueOrNull(colDef.aggFunc, colDef.initialAggFunc);
  return {
    colId: column.getColId(),
    sort,
    sortIndex,
    hide,
    pinned,
    width,
    flex,
    rowGroup,
    rowGroupIndex,
    pivot,
    pivotIndex,
    aggFunc
  };
}
function orderLiveColsLikeState(params, colModel, gos) {
  if (!params.applyOrder || !params.state) {
    return;
  }
  const colIds = [];
  params.state.forEach((item) => {
    if (item.colId != null) {
      colIds.push(item.colId);
    }
  });
  sortColsLikeKeys(colModel.cols, colIds, colModel, gos);
}
function sortColsLikeKeys(cols, colIds, colModel, gos) {
  if (cols == null) {
    return;
  }
  let newOrder = [];
  const processedColIds = {};
  colIds.forEach((colId) => {
    if (processedColIds[colId]) {
      return;
    }
    const col = cols.map[colId];
    if (col) {
      newOrder.push(col);
      processedColIds[colId] = true;
    }
  });
  let autoGroupInsertIndex = 0;
  cols.list.forEach((col) => {
    const colId = col.getColId();
    const alreadyProcessed = processedColIds[colId] != null;
    if (alreadyProcessed) {
      return;
    }
    const isAutoGroupCol = colId.startsWith(GROUP_AUTO_COLUMN_ID);
    if (isAutoGroupCol) {
      newOrder.splice(autoGroupInsertIndex++, 0, col);
    } else {
      newOrder.push(col);
    }
  });
  newOrder = placeLockedColumns(newOrder, gos);
  if (!doesMovePassMarryChildren(newOrder, colModel.getColTree())) {
    _warn(39);
    return;
  }
  cols.list = newOrder;
}
function normaliseColumnMovedEventForColumnState(colStateBefore, colStateAfter, source, colModel, eventSvc) {
  const colStateAfterMapped = {};
  colStateAfter.forEach((s) => colStateAfterMapped[s.colId] = s);
  const colsIntersectIds = {};
  colStateBefore.forEach((s) => {
    if (colStateAfterMapped[s.colId]) {
      colsIntersectIds[s.colId] = true;
    }
  });
  const beforeFiltered = colStateBefore.filter((c) => colsIntersectIds[c.colId]);
  const afterFiltered = colStateAfter.filter((c) => colsIntersectIds[c.colId]);
  const movedColumns = [];
  afterFiltered.forEach((csAfter, index) => {
    const csBefore = beforeFiltered && beforeFiltered[index];
    if (csBefore && csBefore.colId !== csAfter.colId) {
      const gridCol = colModel.getCol(csBefore.colId);
      if (gridCol) {
        movedColumns.push(gridCol);
      }
    }
  });
  if (!movedColumns.length) {
    return;
  }
  eventSvc.dispatchEvent({
    type: "columnMoved",
    columns: movedColumns,
    column: movedColumns.length === 1 ? movedColumns[0] : null,
    finished: true,
    source
  });
}
var comparatorByIndex = (indexes, oldList, colA, colB) => {
  const indexA = indexes[colA.getId()];
  const indexB = indexes[colB.getId()];
  const aHasIndex = indexA != null;
  const bHasIndex = indexB != null;
  if (aHasIndex && bHasIndex) {
    return indexA - indexB;
  }
  if (aHasIndex) {
    return -1;
  }
  if (bHasIndex) {
    return 1;
  }
  const oldIndexA = oldList.indexOf(colA);
  const oldIndexB = oldList.indexOf(colB);
  const aHasOldIndex = oldIndexA >= 0;
  const bHasOldIndex = oldIndexB >= 0;
  if (aHasOldIndex && bHasOldIndex) {
    return oldIndexA - oldIndexB;
  }
  if (aHasOldIndex) {
    return -1;
  }
  return 1;
};
var ColumnModel = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colModel";
    this.pivotMode = false;
    this.ready = false;
    this.changeEventsDispatching = false;
  }
  postConstruct() {
    this.pivotMode = this.gos.get("pivotMode");
    this.addManagedPropertyListeners(
      [
        "groupDisplayType",
        "treeData",
        "treeDataDisplayType",
        "groupHideOpenParents",
        "rowNumbers",
        "hidePaddedHeaderRows"
      ],
      (event) => this.refreshAll(_convertColumnEventSourceType(event.source))
    );
    this.addManagedPropertyListeners(
      ["defaultColDef", "defaultColGroupDef", "columnTypes", "suppressFieldDotNotation"],
      this.recreateColumnDefs.bind(this)
    );
    this.addManagedPropertyListener(
      "pivotMode",
      (event) => this.setPivotMode(this.gos.get("pivotMode"), _convertColumnEventSourceType(event.source))
    );
  }
  // called from SyncService, when grid has finished initialising
  createColsFromColDefs(source) {
    var _a4, _b2, _c;
    const { beans } = this;
    const {
      valueCache,
      colAutosize,
      rowGroupColsSvc,
      pivotColsSvc,
      valueColsSvc,
      visibleCols,
      eventSvc,
      groupHierarchyColSvc
    } = beans;
    const dispatchEventsFunc = this.colDefs ? _compareColumnStatesAndDispatchEvents(beans, source) : void 0;
    valueCache == null ? void 0 : valueCache.expire();
    const oldCols = (_a4 = this.colDefCols) == null ? void 0 : _a4.list;
    const oldTree = (_b2 = this.colDefCols) == null ? void 0 : _b2.tree;
    const newTree = _createColumnTree(beans, this.colDefs, true, oldTree, source);
    _destroyColumnTree(beans, (_c = this.colDefCols) == null ? void 0 : _c.tree, newTree.columnTree);
    const tree = newTree.columnTree;
    const treeDepth = newTree.treeDepth;
    const list = _getColumnsFromTree(tree);
    const map = {};
    list.forEach((col) => map[col.getId()] = col);
    this.colDefCols = { tree, treeDepth, list, map };
    this.createColumnsForService([groupHierarchyColSvc], this.colDefCols);
    rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.extractCols(source, oldCols);
    pivotColsSvc == null ? void 0 : pivotColsSvc.extractCols(source, oldCols);
    valueColsSvc == null ? void 0 : valueColsSvc.extractCols(source, oldCols);
    this.ready = true;
    this.refreshCols(true);
    visibleCols.refresh(source);
    eventSvc.dispatchEvent({
      type: "columnEverythingChanged",
      source
    });
    if (dispatchEventsFunc) {
      this.changeEventsDispatching = true;
      dispatchEventsFunc();
      this.changeEventsDispatching = false;
    }
    eventSvc.dispatchEvent({
      type: "newColumnsLoaded",
      source
    });
    if (source === "gridInitializing") {
      colAutosize == null ? void 0 : colAutosize.applyAutosizeStrategy();
    }
  }
  // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
  // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
  // setPivotMode, applyColumnState,
  // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
  // pivotResultCols.setPivotResultCols
  refreshCols(newColDefs) {
    var _a4;
    if (!this.colDefCols) {
      return;
    }
    const prevColTree = (_a4 = this.cols) == null ? void 0 : _a4.tree;
    this.saveColOrder();
    const {
      autoColSvc,
      selectionColSvc,
      rowNumbersSvc,
      quickFilter,
      pivotResultCols,
      showRowGroupCols,
      rowAutoHeight,
      visibleCols,
      colViewport,
      eventSvc
    } = this.beans;
    const cols = this.selectCols(pivotResultCols, this.colDefCols);
    this.createColumnsForService([autoColSvc, selectionColSvc, rowNumbersSvc], cols);
    const shouldSortNewColDefs = _shouldMaintainColumnOrder(this.gos, this.showingPivotResult);
    if (!newColDefs || shouldSortNewColDefs) {
      this.restoreColOrder(cols);
    }
    this.positionLockedCols(cols);
    showRowGroupCols == null ? void 0 : showRowGroupCols.refresh();
    quickFilter == null ? void 0 : quickFilter.refreshCols();
    this.setColSpanActive();
    rowAutoHeight == null ? void 0 : rowAutoHeight.setAutoHeightActive(cols);
    visibleCols.clear();
    colViewport.clear();
    const dispatchChangedEvent = !_areEqual(prevColTree, this.cols.tree);
    if (dispatchChangedEvent) {
      eventSvc.dispatchEvent({
        type: "gridColumnsChanged"
      });
    }
  }
  createColumnsForService(services, cols) {
    for (const service of services) {
      if (!service) {
        continue;
      }
      service.createColumns(cols, (updateOrder) => {
        this.lastOrder = updateOrder(this.lastOrder);
        this.lastPivotOrder = updateOrder(this.lastPivotOrder);
      });
      service.addColumns(cols);
    }
  }
  selectCols(pivotResultColsSvc, colDefCols) {
    var _a4;
    const pivotResultCols = (_a4 = pivotResultColsSvc == null ? void 0 : pivotResultColsSvc.getPivotResultCols()) != null ? _a4 : null;
    this.showingPivotResult = pivotResultCols != null;
    const { map, list, tree, treeDepth } = pivotResultCols != null ? pivotResultCols : colDefCols;
    this.cols = {
      list: list.slice(),
      map: { ...map },
      tree: tree.slice(),
      treeDepth
    };
    if (pivotResultCols) {
      const hasSameColumns = pivotResultCols.list.some((col) => {
        var _a5;
        return ((_a5 = this.cols) == null ? void 0 : _a5.map[col.getColId()]) !== void 0;
      });
      if (!hasSameColumns) {
        this.lastPivotOrder = null;
      }
    }
    return this.cols;
  }
  getColsToShow() {
    if (!this.cols) {
      return [];
    }
    const { valueColsSvc, selectionColSvc, gos } = this.beans;
    const showAutoGroupAndValuesOnly = this.isPivotMode() && !this.showingPivotResult;
    const showSelectionColumn = selectionColSvc == null ? void 0 : selectionColSvc.isSelectionColumnEnabled();
    const showRowNumbers = gos.get("rowNumbers");
    const valueColumns = valueColsSvc == null ? void 0 : valueColsSvc.columns;
    const res = this.cols.list.filter((col) => {
      const isAutoGroupCol = isColumnGroupAutoCol(col);
      if (showAutoGroupAndValuesOnly) {
        const isValueCol = valueColumns == null ? void 0 : valueColumns.includes(col);
        return isAutoGroupCol || isValueCol || showSelectionColumn && isColumnSelectionCol(col) || showRowNumbers && isRowNumberCol(col);
      } else {
        return isAutoGroupCol || col.isVisible();
      }
    });
    return res;
  }
  // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
  refreshAll(source) {
    if (!this.ready) {
      return;
    }
    this.refreshCols(false);
    this.beans.visibleCols.refresh(source);
  }
  setColsVisible(keys, visible = false, source) {
    _applyColumnState(
      this.beans,
      {
        state: keys.map((key) => ({
          colId: typeof key === "string" ? key : key.getColId(),
          hide: !visible
        }))
      },
      source
    );
  }
  /**
   * Restores provided columns order to the previous order in this.lastPivotOrder / this.lastOrder
   * If columns are not in the last order:
   *  - Check column groups, and apply column after the last column in the lowest shared group
   *  - If no sibling is found, apply the column at the end of the cols
   */
  restoreColOrder(cols) {
    const lastOrder = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
    if (!lastOrder) {
      return;
    }
    const preservedOrder = lastOrder.filter((col) => cols.map[col.getId()] != null);
    if (preservedOrder.length === 0) {
      return;
    }
    if (preservedOrder.length === cols.list.length) {
      cols.list = preservedOrder;
      return;
    }
    const hasSiblings = (col) => {
      const ancestor = col.getOriginalParent();
      if (!ancestor) {
        return false;
      }
      const children = ancestor.getChildren();
      if (children.length > 1) {
        return true;
      }
      return hasSiblings(ancestor);
    };
    if (!preservedOrder.some((col) => hasSiblings(col))) {
      const preservedOrderSet = new Set(preservedOrder);
      for (const col of cols.list) {
        if (!preservedOrderSet.has(col)) {
          preservedOrder.push(col);
        }
      }
      cols.list = preservedOrder;
      return;
    }
    const colPositionMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < preservedOrder.length; i++) {
      const col = preservedOrder[i];
      colPositionMap.set(col, i);
    }
    const additionalCols = cols.list.filter((col) => !colPositionMap.has(col));
    if (additionalCols.length === 0) {
      cols.list = preservedOrder;
      return;
    }
    const getPreviousSibling = (col, group) => {
      const parent = group ? group.getOriginalParent() : col.getOriginalParent();
      if (!parent) {
        return null;
      }
      let highestIdx = null;
      let highestSibling = null;
      for (const child of parent.getChildren()) {
        if (child === group || child === col) {
          continue;
        }
        if (child instanceof AgColumn) {
          const colIdx = colPositionMap.get(child);
          if (colIdx == null) {
            continue;
          }
          if (highestIdx == null || highestIdx < colIdx) {
            highestIdx = colIdx;
            highestSibling = child;
          }
          continue;
        }
        child.forEachLeafColumn((leafCol) => {
          const colIdx = colPositionMap.get(leafCol);
          if (colIdx == null) {
            return;
          }
          if (highestIdx == null || highestIdx < colIdx) {
            highestIdx = colIdx;
            highestSibling = leafCol;
          }
        });
      }
      if (highestSibling == null) {
        return getPreviousSibling(col, parent);
      }
      return highestSibling;
    };
    const noSiblingsAvailable = [];
    const previousSiblingPosMap = /* @__PURE__ */ new Map();
    for (const col of additionalCols) {
      const prevSiblingIdx = getPreviousSibling(col, null);
      if (prevSiblingIdx == null) {
        noSiblingsAvailable.push(col);
        continue;
      }
      const prev = previousSiblingPosMap.get(prevSiblingIdx);
      if (prev === void 0) {
        previousSiblingPosMap.set(prevSiblingIdx, col);
      } else if (Array.isArray(prev)) {
        prev.push(col);
      } else {
        previousSiblingPosMap.set(prevSiblingIdx, [prev, col]);
      }
    }
    const result = new Array(cols.list.length);
    let resultPointer = result.length - 1;
    for (let i = noSiblingsAvailable.length - 1; i >= 0; i--) {
      result[resultPointer--] = noSiblingsAvailable[i];
    }
    for (let i = preservedOrder.length - 1; i >= 0; i--) {
      const nextCol = preservedOrder[i];
      const extraCols = previousSiblingPosMap.get(nextCol);
      if (extraCols) {
        if (Array.isArray(extraCols)) {
          for (let x = extraCols.length - 1; x >= 0; x--) {
            const col = extraCols[x];
            result[resultPointer--] = col;
          }
        } else {
          result[resultPointer--] = extraCols;
        }
      }
      result[resultPointer--] = nextCol;
    }
    cols.list = result;
  }
  positionLockedCols(cols) {
    cols.list = placeLockedColumns(cols.list, this.gos);
  }
  saveColOrder() {
    var _a4, _b2, _c, _d;
    if (this.showingPivotResult) {
      this.lastPivotOrder = (_b2 = (_a4 = this.cols) == null ? void 0 : _a4.list) != null ? _b2 : null;
    } else {
      this.lastOrder = (_d = (_c = this.cols) == null ? void 0 : _c.list) != null ? _d : null;
    }
  }
  getColumnDefs() {
    var _a4, _b2, _c;
    return this.colDefCols ? (_c = this.beans.colDefFactory) == null ? void 0 : _c.getColumnDefs(
      this.colDefCols.list,
      this.showingPivotResult,
      this.lastOrder,
      (_b2 = (_a4 = this.cols) == null ? void 0 : _a4.list) != null ? _b2 : []
    ) : void 0;
  }
  setColSpanActive() {
    var _a4;
    this.colSpanActive = !!((_a4 = this.cols) == null ? void 0 : _a4.list.some((col) => col.getColDef().colSpan != null));
  }
  isPivotMode() {
    return this.pivotMode;
  }
  setPivotMode(pivotMode, source) {
    if (pivotMode === this.pivotMode) {
      return;
    }
    this.pivotMode = pivotMode;
    if (!this.ready) {
      return;
    }
    this.refreshCols(false);
    const { visibleCols, eventSvc } = this.beans;
    visibleCols.refresh(source);
    eventSvc.dispatchEvent({
      type: "columnPivotModeChanged"
    });
  }
  // + clientSideRowModel
  isPivotActive() {
    var _a4;
    const pivotColumns = (_a4 = this.beans.pivotColsSvc) == null ? void 0 : _a4.columns;
    return this.pivotMode && !!(pivotColumns == null ? void 0 : pivotColumns.length);
  }
  // called when dataTypes change
  recreateColumnDefs(e) {
    var _a4;
    if (!this.cols) {
      return;
    }
    (_a4 = this.beans.autoColSvc) == null ? void 0 : _a4.updateColumns(e);
    const source = _convertColumnEventSourceType(e.source);
    this.createColsFromColDefs(source);
  }
  setColumnDefs(columnDefs, source) {
    this.colDefs = columnDefs;
    this.createColsFromColDefs(source);
  }
  destroy() {
    var _a4;
    _destroyColumnTree(this.beans, (_a4 = this.colDefCols) == null ? void 0 : _a4.tree);
    super.destroy();
  }
  getColTree() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.cols) == null ? void 0 : _a4.tree) != null ? _b2 : [];
  }
  // + columnSelectPanel
  getColDefColTree() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.colDefCols) == null ? void 0 : _a4.tree) != null ? _b2 : [];
  }
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getColDefCols() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.colDefCols) == null ? void 0 : _a4.list) != null ? _b2 : null;
  }
  // + moveColumnController
  getCols() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.cols) == null ? void 0 : _a4.list) != null ? _b2 : [];
  }
  forAllCols(callback) {
    var _a4, _b2, _c, _d, _e;
    const { pivotResultCols, autoColSvc, selectionColSvc, groupHierarchyColSvc } = this.beans;
    _forAll((_a4 = this.colDefCols) == null ? void 0 : _a4.list, callback);
    _forAll((_b2 = autoColSvc == null ? void 0 : autoColSvc.columns) == null ? void 0 : _b2.list, callback);
    _forAll((_c = selectionColSvc == null ? void 0 : selectionColSvc.columns) == null ? void 0 : _c.list, callback);
    _forAll((_d = groupHierarchyColSvc == null ? void 0 : groupHierarchyColSvc.columns) == null ? void 0 : _d.list, callback);
    _forAll((_e = pivotResultCols == null ? void 0 : pivotResultCols.getPivotResultCols()) == null ? void 0 : _e.list, callback);
  }
  getColsForKeys(keys) {
    if (!keys) {
      return [];
    }
    return keys.map((key) => this.getCol(key)).filter((col) => col != null);
  }
  getColDefCol(key) {
    var _a4;
    if (!((_a4 = this.colDefCols) == null ? void 0 : _a4.list)) {
      return null;
    }
    return this.getColFromCollection(key, this.colDefCols);
  }
  getCol(key) {
    if (key == null) {
      return null;
    }
    return this.getColFromCollection(key, this.cols);
  }
  /**
   * Get column exclusively by ID.
   *
   * Note getCol/getColFromCollection have poor performance when col has been removed.
   */
  getColById(key) {
    var _a4, _b2;
    return (_b2 = (_a4 = this.cols) == null ? void 0 : _a4.map[key]) != null ? _b2 : null;
  }
  getColFromCollection(key, cols) {
    var _a4, _b2, _c;
    if (cols == null) {
      return null;
    }
    const { map, list } = cols;
    if (typeof key == "string" && map[key]) {
      return map[key];
    }
    for (let i = 0; i < list.length; i++) {
      if (_columnsMatch(list[i], key)) {
        return list[i];
      }
    }
    const { autoColSvc, selectionColSvc, groupHierarchyColSvc } = this.beans;
    return (_c = (_b2 = (_a4 = autoColSvc == null ? void 0 : autoColSvc.getColumn(key)) != null ? _a4 : selectionColSvc == null ? void 0 : selectionColSvc.getColumn(key)) != null ? _b2 : groupHierarchyColSvc == null ? void 0 : groupHierarchyColSvc.getColumn(key)) != null ? _c : null;
  }
};
var GroupInstanceIdCreator = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(key) {
    const lastResult = this.existingIds[key];
    let result;
    if (typeof lastResult !== "number") {
      result = 0;
    } else {
      result = lastResult + 1;
    }
    this.existingIds[key] = result;
    return result;
  }
};
function setupCompBean(ctrl, ctx, compBean) {
  if (compBean) {
    ctrl.addDestroyFunc(() => ctx.destroyBean(compBean));
  }
  return compBean != null ? compBean : ctrl;
}
var RefPlaceholder = null;
var CssClassManager = class {
  constructor(getGui) {
    this.cssClassStates = {};
    this.getGui = getGui;
  }
  toggleCss(className, addOrRemove) {
    var _a4;
    if (!className) {
      return;
    }
    if (className.indexOf(" ") >= 0) {
      const list = (className || "").split(" ");
      if (list.length > 1) {
        list.forEach((cls) => this.toggleCss(cls, addOrRemove));
        return;
      }
    }
    const updateNeeded = this.cssClassStates[className] !== addOrRemove;
    if (updateNeeded && className.length) {
      (_a4 = this.getGui()) == null ? void 0 : _a4.classList.toggle(className, addOrRemove);
      this.cssClassStates[className] = addOrRemove;
    }
  }
};
var compIdSequence = 0;
var AgComponentStub = class extends AgBeanStub {
  constructor(templateOrParams, componentSelectors) {
    super();
    this.suppressDataRefValidation = false;
    this.displayed = true;
    this.visible = true;
    this.compId = compIdSequence++;
    this.cssManager = new CssClassManager(() => this.eGui);
    this.componentSelectors = new Map((componentSelectors != null ? componentSelectors : []).map((comp) => [comp.selector, comp]));
    if (templateOrParams) {
      this.setTemplate(templateOrParams);
    }
  }
  preConstruct() {
    var _a4, _b2, _c;
    this.wireTemplate(this.getGui());
    const debugId = "component-" + ((_b2 = (_a4 = Object.getPrototypeOf(this)) == null ? void 0 : _a4.constructor) == null ? void 0 : _b2.name);
    (_c = this.css) == null ? void 0 : _c.forEach((css) => this.beans.environment.addGlobalCSS(css, debugId));
  }
  wireTemplate(element, paramsMap) {
    if (element && this.gos) {
      this.applyElementsToComponent(element);
      this.createChildComponentsFromTags(element, paramsMap);
    }
  }
  getCompId() {
    return this.compId;
  }
  getDataRefAttribute(element) {
    if (element.getAttribute) {
      return element.getAttribute(DataRefAttribute);
    }
    return null;
  }
  applyElementsToComponent(element, elementRef, paramsMap, newComponent = null) {
    if (elementRef === void 0) {
      elementRef = this.getDataRefAttribute(element);
    }
    if (elementRef) {
      const current = this[elementRef];
      if (current === RefPlaceholder) {
        this[elementRef] = newComponent != null ? newComponent : element;
      } else {
        const usedAsParamRef = paramsMap && paramsMap[elementRef];
        if (!this.suppressDataRefValidation && !usedAsParamRef) {
          throw new Error(`data-ref: ${elementRef} on ${this.constructor.name} with ${current}`);
        }
      }
    }
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(parentNode, paramsMap) {
    var _a4;
    const childNodeList = [];
    for (const childNode of (_a4 = parentNode.childNodes) != null ? _a4 : []) {
      childNodeList.push(childNode);
    }
    childNodeList.forEach((childNode) => {
      if (!(childNode instanceof HTMLElement)) {
        return;
      }
      const childComp = this.createComponentFromElement(
        childNode,
        (childComp2) => {
          var _a5;
          const childGui = childComp2.getGui();
          if (childGui) {
            for (const attr of (_a5 = childNode.attributes) != null ? _a5 : []) {
              childGui.setAttribute(attr.name, attr.value);
            }
          }
        },
        paramsMap
      );
      if (childComp) {
        if (childComp.addItems && childNode.children.length) {
          this.createChildComponentsFromTags(childNode, paramsMap);
          const items = Array.prototype.slice.call(childNode.children);
          childComp.addItems(items);
        }
        this.swapComponentForNode(childComp, parentNode, childNode);
      } else if (childNode.childNodes) {
        this.createChildComponentsFromTags(childNode, paramsMap);
      }
    });
  }
  createComponentFromElement(element, afterPreCreateCallback, paramsMap) {
    const key = element.nodeName;
    const elementRef = this.getDataRefAttribute(element);
    const isAgGridComponent = key.indexOf("AG-") === 0;
    const componentSelector = isAgGridComponent ? this.componentSelectors.get(key) : null;
    let newComponent = null;
    if (componentSelector) {
      const componentParams = paramsMap && elementRef ? paramsMap[elementRef] : void 0;
      newComponent = new componentSelector.component(componentParams);
      newComponent.setParentComponent(
        this
      );
      this.createBean(newComponent, null, afterPreCreateCallback);
    } else if (isAgGridComponent) {
      throw new Error(`selector: ${key}`);
    }
    this.applyElementsToComponent(element, elementRef, paramsMap, newComponent);
    return newComponent;
  }
  swapComponentForNode(newComponent, parentNode, childNode) {
    const eComponent = newComponent.getGui();
    parentNode.replaceChild(eComponent, childNode);
    parentNode.insertBefore(document.createComment(childNode.nodeName), eComponent);
    this.addDestroyFunc(this.destroyBean.bind(this, newComponent));
  }
  activateTabIndex(elements) {
    const tabIndex = this.gos.get("tabIndex");
    if (!elements) {
      elements = [];
    }
    if (!elements.length) {
      elements.push(this.getGui());
    }
    elements.forEach((el) => el.setAttribute("tabindex", tabIndex.toString()));
  }
  setTemplate(templateOrParams, componentSelectors, paramsMap) {
    let eGui;
    if (typeof templateOrParams === "string" || templateOrParams == null) {
      eGui = _loadTemplate(templateOrParams);
    } else {
      eGui = _createAgElement(templateOrParams);
    }
    this.setTemplateFromElement(eGui, componentSelectors, paramsMap);
  }
  setTemplateFromElement(element, components, paramsMap, suppressDataRefValidation = false) {
    this.eGui = element;
    this.suppressDataRefValidation = suppressDataRefValidation;
    if (components) {
      for (let i = 0; i < components.length; i++) {
        const component = components[i];
        this.componentSelectors.set(component.selector, component);
      }
    }
    this.wireTemplate(element, paramsMap);
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(component) {
    this.parentComponent = component;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(eGui) {
    this.eGui = eGui;
  }
  queryForHtmlElement(cssSelector) {
    return this.eGui.querySelector(cssSelector);
  }
  getContainerAndElement(newChild, container) {
    let parent = container;
    if (newChild == null) {
      return null;
    }
    if (!parent) {
      parent = this.eGui;
    }
    if (_isNodeOrElement(newChild)) {
      return {
        element: newChild,
        parent
      };
    }
    return {
      element: newChild.getGui(),
      parent
    };
  }
  prependChild(newChild, container) {
    const { element, parent } = this.getContainerAndElement(newChild, container) || {};
    if (!element || !parent) {
      return;
    }
    parent.insertAdjacentElement("afterbegin", element);
  }
  appendChild(newChild, container) {
    const { element, parent } = this.getContainerAndElement(newChild, container) || {};
    if (!element || !parent) {
      return;
    }
    parent.appendChild(element);
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(visible, options = {}) {
    if (visible !== this.visible) {
      this.visible = visible;
      const { skipAriaHidden } = options;
      _setVisible(this.eGui, visible, { skipAriaHidden });
    }
  }
  setDisplayed(displayed, options = {}) {
    if (displayed !== this.displayed) {
      this.displayed = displayed;
      const { skipAriaHidden } = options;
      _setDisplayed(this.eGui, displayed, { skipAriaHidden });
      const event = {
        type: "displayChanged",
        visible: this.displayed
      };
      this.dispatchLocalEvent(event);
    }
  }
  destroy() {
    if (this.parentComponent) {
      this.parentComponent = void 0;
    }
    super.destroy();
  }
  addGuiEventListener(event, listener, options) {
    this.eGui.addEventListener(event, listener, options);
    this.addDestroyFunc(() => this.eGui.removeEventListener(event, listener));
  }
  addCss(className) {
    this.cssManager.toggleCss(className, true);
  }
  removeCss(className) {
    this.cssManager.toggleCss(className, false);
  }
  toggleCss(className, addOrRemove) {
    this.cssManager.toggleCss(className, addOrRemove);
  }
  registerCSS(css) {
    this.css || (this.css = []);
    this.css.push(css);
  }
};
var Component = class extends AgComponentStub {
};
var AgPromise = class _AgPromise {
  constructor(callback) {
    this.status = 0;
    this.resolution = null;
    this.waiters = [];
    callback(
      (value) => this.onDone(value),
      (params) => this.onReject(params)
    );
  }
  static all(promises) {
    return promises.length ? new _AgPromise((resolve) => {
      let remainingToResolve = promises.length;
      const combinedValues = new Array(remainingToResolve);
      promises.forEach((promise, index) => {
        promise.then((value) => {
          combinedValues[index] = value;
          remainingToResolve--;
          if (remainingToResolve === 0) {
            resolve(combinedValues);
          }
        });
      });
    }) : _AgPromise.resolve();
  }
  static resolve(value = null) {
    return new _AgPromise((resolve) => resolve(value));
  }
  then(func) {
    return new _AgPromise((resolve) => {
      if (this.status === 1) {
        resolve(func(this.resolution));
      } else {
        this.waiters.push((value) => resolve(func(value)));
      }
    });
  }
  onDone(value) {
    this.status = 1;
    this.resolution = value;
    this.waiters.forEach((waiter) => waiter(value));
  }
  onReject(_) {
  }
};
function doesImplementIComponent(candidate) {
  if (!candidate) {
    return false;
  }
  return candidate.prototype && "getGui" in candidate.prototype;
}
function _getUserCompKeys(frameworkOverrides, defObject, type, params) {
  const { name } = type;
  let compName;
  let jsComp;
  let fwComp;
  let paramsFromSelector;
  let popupFromSelector;
  let popupPositionFromSelector;
  if (defObject) {
    const defObjectAny = defObject;
    const selectorFunc = defObjectAny[name + "Selector"];
    const selectorRes = selectorFunc ? selectorFunc(params) : null;
    const assignComp = (providedJsComp) => {
      if (typeof providedJsComp === "string") {
        compName = providedJsComp;
      } else if (providedJsComp != null && providedJsComp !== true) {
        const isFwkComp = frameworkOverrides.isFrameworkComponent(providedJsComp);
        if (isFwkComp) {
          fwComp = providedJsComp;
        } else {
          jsComp = providedJsComp;
        }
      }
    };
    if (selectorRes) {
      assignComp(selectorRes.component);
      paramsFromSelector = selectorRes.params;
      popupFromSelector = selectorRes.popup;
      popupPositionFromSelector = selectorRes.popupPosition;
    } else {
      assignComp(defObjectAny[name]);
    }
  }
  return { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector };
}
var UserComponentFactory = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "userCompFactory";
  }
  wireBeans(beans) {
    this.agCompUtils = beans.agCompUtils;
    this.registry = beans.registry;
    this.frameworkCompWrapper = beans.frameworkCompWrapper;
    this.gridOptions = beans.gridOptions;
  }
  getCompDetailsFromGridOptions(type, defaultName, params, mandatory = false) {
    return this.getCompDetails(this.gridOptions, type, defaultName, params, mandatory);
  }
  getCompDetails(defObject, type, defaultName, params, mandatory = false) {
    var _a4;
    const { name, cellRenderer } = type;
    let { compName, jsComp, fwComp, paramsFromSelector, popupFromSelector, popupPositionFromSelector } = _getUserCompKeys(this.beans.frameworkOverrides, defObject, type, params);
    let defaultCompParams;
    let defaultCompProcessParams;
    const lookupFromRegistry = (key) => {
      const item = this.registry.getUserComponent(name, key);
      if (item) {
        jsComp = !item.componentFromFramework ? item.component : void 0;
        fwComp = item.componentFromFramework ? item.component : void 0;
        defaultCompParams = item.params;
        defaultCompProcessParams = item.processParams;
      }
    };
    if (compName != null) {
      lookupFromRegistry(compName);
    }
    if (jsComp == null && fwComp == null && defaultName != null) {
      lookupFromRegistry(defaultName);
    }
    if (jsComp && cellRenderer && !doesImplementIComponent(jsComp)) {
      jsComp = (_a4 = this.agCompUtils) == null ? void 0 : _a4.adaptFunction(type, jsComp);
    }
    if (!jsComp && !fwComp) {
      const { validation } = this.beans;
      if (mandatory && (compName !== defaultName || !defaultName)) {
        if (compName) {
          if (!(validation == null ? void 0 : validation.isProvidedUserComp(compName))) {
            _error(50, { compName });
          }
        } else {
          if (defaultName) {
            if (!validation) {
              _error(260, {
                ...this.gos.getModuleErrorParams(),
                propName: name,
                compName: defaultName
              });
            }
          } else {
            _error(216, { name });
          }
        }
      } else if (defaultName && !validation) {
        _error(146, { comp: defaultName });
      }
      return;
    }
    const paramsMerged = this.mergeParams(
      defObject,
      type,
      params,
      paramsFromSelector,
      defaultCompParams,
      defaultCompProcessParams
    );
    const componentFromFramework = jsComp == null;
    const componentClass = jsComp != null ? jsComp : fwComp;
    return {
      componentFromFramework,
      componentClass,
      params: paramsMerged,
      type,
      popupFromSelector,
      popupPositionFromSelector,
      newAgStackInstance: () => this.newAgStackInstance(componentClass, componentFromFramework, paramsMerged, type)
    };
  }
  newAgStackInstance(ComponentClass, componentFromFramework, params, type) {
    var _a4;
    const jsComponent = !componentFromFramework;
    let instance;
    if (jsComponent) {
      instance = new ComponentClass();
    } else {
      instance = this.frameworkCompWrapper.wrap(
        ComponentClass,
        type.mandatoryMethods,
        type.optionalMethods,
        type
      );
    }
    this.createBean(instance);
    const deferredInit = (_a4 = instance.init) == null ? void 0 : _a4.call(instance, params);
    if (deferredInit == null) {
      return AgPromise.resolve(instance);
    }
    return deferredInit.then(() => instance);
  }
  /**
   * merges params with application provided params
   * used by Floating Filter
   */
  mergeParams(defObject, type, paramsFromGrid, paramsFromSelector = null, defaultCompParams, defaultCompProcessParams) {
    const params = { ...paramsFromGrid, ...defaultCompParams };
    const defObjectAny = defObject;
    const userParams = defObjectAny && defObjectAny[type.name + "Params"];
    if (typeof userParams === "function") {
      const userParamsFromFunc = userParams(paramsFromGrid);
      _mergeDeep(params, userParamsFromFunc);
    } else if (typeof userParams === "object") {
      _mergeDeep(params, userParams);
    }
    _mergeDeep(params, paramsFromSelector);
    return defaultCompProcessParams ? defaultCompProcessParams(params) : params;
  }
};
var DragAndDropImageComponent = {
  name: "dragAndDropImageComponent",
  mandatoryMethods: ["setIcon", "setLabel"]
};
var HeaderComponent = { name: "headerComponent", optionalMethods: ["refresh"] };
var InnerHeaderComponent = { name: "innerHeaderComponent" };
var InnerHeaderGroupComponent = { name: "innerHeaderGroupComponent" };
var HeaderGroupComponent = { name: "headerGroupComponent" };
var CellRendererComponent = {
  name: "cellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: true
};
var LoadingCellRendererComponent = { name: "loadingCellRenderer", cellRenderer: true };
var LoadingOverlayComponent = { name: "loadingOverlayComponent", optionalMethods: ["refresh"] };
var NoRowsOverlayComponent = { name: "noRowsOverlayComponent", optionalMethods: ["refresh"] };
var FullWidth = {
  name: "fullWidthCellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: true
};
var FullWidthLoading = { name: "loadingCellRenderer", cellRenderer: true };
var FullWidthGroup = {
  name: "groupRowRenderer",
  optionalMethods: ["afterGuiAttached"],
  cellRenderer: true
};
var FullWidthDetail = { name: "detailCellRenderer", optionalMethods: ["refresh"], cellRenderer: true };
function _getDragAndDropImageCompDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(DragAndDropImageComponent, "agDragAndDropImage", params, true);
}
function _getHeaderCompDetails(userCompFactory, colDef, params) {
  return userCompFactory.getCompDetails(colDef, HeaderComponent, "agColumnHeader", params);
}
function _getInnerHeaderCompDetails(userCompFactory, headerCompParams, params) {
  return userCompFactory.getCompDetails(headerCompParams, InnerHeaderComponent, void 0, params);
}
function _getHeaderGroupCompDetails(userCompFactory, params) {
  const colGroupDef = params.columnGroup.getColGroupDef();
  return userCompFactory.getCompDetails(colGroupDef, HeaderGroupComponent, "agColumnGroupHeader", params);
}
function _getInnerHeaderGroupCompDetails(userCompFactory, headerGroupCompParams, params) {
  return userCompFactory.getCompDetails(headerGroupCompParams, InnerHeaderGroupComponent, void 0, params);
}
function _getFullWidthCellRendererDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(FullWidth, void 0, params, true);
}
function _getFullWidthLoadingCellRendererDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(FullWidthLoading, "agLoadingCellRenderer", params, true);
}
function _getFullWidthGroupCellRendererDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(FullWidthGroup, "agGroupRowRenderer", params, true);
}
function _getFullWidthDetailCellRendererDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(FullWidthDetail, "agDetailCellRenderer", params, true);
}
function _getCellRendererDetails(userCompFactory, def, params) {
  return userCompFactory.getCompDetails(def, CellRendererComponent, void 0, params);
}
function _getLoadingCellRendererDetails(userCompFactory, def, params) {
  return userCompFactory.getCompDetails(def, LoadingCellRendererComponent, "agSkeletonCellRenderer", params, true);
}
function _getLoadingOverlayCompDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(LoadingOverlayComponent, "agLoadingOverlay", params, true);
}
function _getNoRowsOverlayCompDetails(userCompFactory, params) {
  return userCompFactory.getCompDetailsFromGridOptions(NoRowsOverlayComponent, "agNoRowsOverlay", params, true);
}
function _unwrapUserComp(comp) {
  const compAsAny = comp;
  const isProxy = compAsAny != null && compAsAny.getFrameworkComponentInstance != null;
  return isProxy ? compAsAny.getFrameworkComponentInstance() : comp;
}
function isComponentMetaFunc(componentMeta) {
  return typeof componentMeta === "object" && !!componentMeta.getComp;
}
var KeyCode = {
  BACKSPACE: "Backspace",
  TAB: "Tab",
  ENTER: "Enter",
  ESCAPE: "Escape",
  SPACE: " ",
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown",
  DELETE: "Delete",
  F2: "F2",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  PAGE_HOME: "Home",
  PAGE_END: "End",
  // these should be used with `event.code` instead of `event.key`
  // as `event.key` changes when non-latin keyboards are used
  A: "KeyA",
  C: "KeyC",
  D: "KeyD",
  V: "KeyV",
  X: "KeyX",
  Y: "KeyY",
  Z: "KeyZ"
};
var isSafari;
var isFirefox;
var isMacOs;
var isIOS;
var invisibleScrollbar;
var browserScrollbarWidth;
var maxDivHeight;
function _isBrowserSafari() {
  if (isSafari === void 0) {
    isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  }
  return isSafari;
}
function _isBrowserFirefox() {
  if (isFirefox === void 0) {
    isFirefox = /(firefox)/i.test(navigator.userAgent);
  }
  return isFirefox;
}
function _isMacOsUserAgent() {
  if (isMacOs === void 0) {
    isMacOs = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
  }
  return isMacOs;
}
function _isIOSUserAgent() {
  if (isIOS === void 0) {
    isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
  }
  return isIOS;
}
function _getTabIndex(el) {
  if (!el) {
    return null;
  }
  const numberTabIndex = el.tabIndex;
  const tabIndex = el.getAttribute("tabIndex");
  if (numberTabIndex === -1 && (tabIndex === null || tabIndex === "" && !_isBrowserFirefox())) {
    return null;
  }
  return numberTabIndex.toString();
}
function _getMaxDivHeight() {
  if (maxDivHeight !== void 0) {
    return maxDivHeight;
  }
  if (!document.body) {
    return -1;
  }
  let res = 1e6;
  const testUpTo = _isBrowserFirefox() ? 6e6 : 1e9;
  const div = document.createElement("div");
  document.body.appendChild(div);
  while (true) {
    const test = res * 2;
    div.style.height = test + "px";
    if (test > testUpTo || div.clientHeight !== test) {
      break;
    } else {
      res = test;
    }
  }
  document.body.removeChild(div);
  maxDivHeight = res;
  return res;
}
function _getScrollbarWidth() {
  if (browserScrollbarWidth == null) {
    initScrollbarWidthAndVisibility();
  }
  return browserScrollbarWidth;
}
function initScrollbarWidthAndVisibility() {
  const body = document.body;
  const div = document.createElement("div");
  div.style.width = div.style.height = "100px";
  div.style.opacity = "0";
  div.style.overflow = "scroll";
  div.style.msOverflowStyle = "scrollbar";
  div.style.position = "absolute";
  body.appendChild(div);
  let width = div.offsetWidth - div.clientWidth;
  if (width === 0 && div.clientWidth === 0) {
    width = null;
  }
  if (div.parentNode) {
    div.parentNode.removeChild(div);
  }
  if (width != null) {
    browserScrollbarWidth = width;
    invisibleScrollbar = width === 0;
  }
}
function _isInvisibleScrollbar() {
  if (invisibleScrollbar == null) {
    initScrollbarWidthAndVisibility();
  }
  return invisibleScrollbar;
}
var DATE_TIME_SEPARATOR = "T";
var DATE_TIME_SEPARATOR_REGEXP = new RegExp(`[${DATE_TIME_SEPARATOR} ]`);
var DATE_TIME_REGEXP = new RegExp(`^\\d{4}-\\d{2}-\\d{2}(${DATE_TIME_SEPARATOR}\\d{2}:\\d{2}:\\d{2}\\D?)?`);
function _padStartWidthZeros(value, totalStringSize) {
  return value.toString().padStart(totalStringSize, "0");
}
function _serialiseDate(date, includeTime = true, separator = DATE_TIME_SEPARATOR) {
  if (!date) {
    return null;
  }
  let serialised = [date.getFullYear(), date.getMonth() + 1, date.getDate()].map((part) => _padStartWidthZeros(part, 2)).join("-");
  if (includeTime) {
    serialised += separator + [date.getHours(), date.getMinutes(), date.getSeconds()].map((part) => _padStartWidthZeros(part, 2)).join(":");
  }
  return serialised;
}
function _isValidDate(value, bailIfInvalidTime = false) {
  return !!_parseDateTimeFromString(value, bailIfInvalidTime);
}
function _isValidDateTime(value) {
  return _isValidDate(value, true);
}
function _parseDateTimeFromString(value, bailIfInvalidTime = false, skipValidation) {
  if (!value) {
    return null;
  }
  if (!skipValidation && !DATE_TIME_REGEXP.test(value)) {
    return null;
  }
  const [dateStr, timeStr] = value.split(DATE_TIME_SEPARATOR_REGEXP);
  if (!dateStr) {
    return null;
  }
  const fields = dateStr.split("-").map((f) => parseInt(f, 10));
  if (fields.filter((f) => !isNaN(f)).length !== 3) {
    return null;
  }
  const [year, month, day] = fields;
  const date = new Date(year, month - 1, day);
  if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
    return null;
  }
  if (!timeStr && bailIfInvalidTime) {
    return null;
  }
  if (!timeStr || timeStr === "00:00:00") {
    return date;
  }
  const [hours, minutes, seconds] = timeStr.split(":").map((part) => parseInt(part, 10));
  if (hours >= 0 && hours < 24) {
    date.setHours(hours);
  } else if (bailIfInvalidTime) {
    return null;
  }
  if (minutes >= 0 && minutes < 60) {
    date.setMinutes(minutes);
  } else if (bailIfInvalidTime) {
    return null;
  }
  if (seconds >= 0 && seconds < 60) {
    date.setSeconds(seconds);
  } else if (bailIfInvalidTime) {
    return null;
  }
  return date;
}
function _isEventFromPrintableCharacter(event) {
  var _a4;
  if (event.altKey || event.ctrlKey || event.metaKey) {
    return false;
  }
  const printableCharacter = ((_a4 = event.key) == null ? void 0 : _a4.length) === 1;
  return printableCharacter;
}
var keyboardModeActive = false;
var instanceCount = 0;
function addKeyboardModeEvents(doc) {
  if (instanceCount > 0) {
    return;
  }
  doc.addEventListener("keydown", toggleKeyboardMode);
  doc.addEventListener("mousedown", toggleKeyboardMode);
}
function removeKeyboardModeEvents(doc) {
  if (instanceCount > 0)
    return;
  doc.removeEventListener("keydown", toggleKeyboardMode);
  doc.removeEventListener("mousedown", toggleKeyboardMode);
}
function toggleKeyboardMode(event) {
  const isKeyboardActive = keyboardModeActive;
  const isKeyboardEvent = event.type === "keydown";
  if (isKeyboardEvent) {
    if (event.ctrlKey || event.metaKey || event.altKey) {
      return;
    }
  }
  if (isKeyboardActive === isKeyboardEvent) {
    return;
  }
  keyboardModeActive = isKeyboardEvent;
}
function _registerKeyboardFocusEvents(beans) {
  const eDocument = _getDocument(beans);
  addKeyboardModeEvents(eDocument);
  instanceCount++;
  return () => {
    instanceCount--;
    removeKeyboardModeEvents(eDocument);
  };
}
function _isKeyboardMode() {
  return keyboardModeActive;
}
function _findFocusableElements(rootNode, exclude, onlyUnmanaged = false) {
  const focusableString = FOCUSABLE_SELECTOR;
  let excludeString = FOCUSABLE_EXCLUDE;
  if (exclude) {
    excludeString += ", " + exclude;
  }
  if (onlyUnmanaged) {
    excludeString += ', [tabindex="-1"]';
  }
  const nodes = Array.prototype.slice.apply(rootNode.querySelectorAll(focusableString)).filter((node) => {
    return _isVisible(node);
  });
  const excludeNodes = Array.prototype.slice.apply(rootNode.querySelectorAll(excludeString));
  if (!excludeNodes.length) {
    return nodes;
  }
  const diff = (a, b) => a.filter((element) => b.indexOf(element) === -1);
  return diff(nodes, excludeNodes);
}
function _focusInto(rootNode, up = false, onlyUnmanaged = false, excludeTabGuards = false) {
  const focusableElements = _findFocusableElements(
    rootNode,
    excludeTabGuards ? ".ag-tab-guard" : null,
    onlyUnmanaged
  );
  const toFocus = up ? _last(focusableElements) : focusableElements[0];
  if (toFocus) {
    toFocus.focus({ preventScroll: true });
    return true;
  }
  return false;
}
function _findNextFocusableElement(beans, rootNode, onlyManaged, backwards) {
  const focusable = _findFocusableElements(rootNode, onlyManaged ? ':not([tabindex="-1"])' : null);
  const activeEl = _getActiveDomElement(beans);
  let currentIndex;
  if (onlyManaged) {
    currentIndex = focusable.findIndex((el) => el.contains(activeEl));
  } else {
    currentIndex = focusable.indexOf(activeEl);
  }
  const nextIndex = currentIndex + (backwards ? -1 : 1);
  if (nextIndex < 0 || nextIndex >= focusable.length) {
    return null;
  }
  return focusable[nextIndex];
}
function _findTabbableParent(node, limit = 5) {
  let counter = 0;
  while (node && _getTabIndex(node) === null && ++counter <= limit) {
    node = node.parentElement;
  }
  if (_getTabIndex(node) === null) {
    return null;
  }
  return node;
}
var agAbstractLabelCSS = (
  /*css*/
  `.ag-label{white-space:nowrap}:where(.ag-ltr) .ag-label{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-label-align-right) .ag-label{order:1}:where(.ag-ltr) :where(.ag-label-align-right) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-rtl) :where(.ag-label-align-right) .ag-label{margin-right:var(--ag-spacing)}.ag-label-align-right>*{flex:none}.ag-label-align-top{align-items:flex-start;flex-direction:column;>*{align-self:stretch}}.ag-label-ellipsis{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-label-align-top) .ag-label{margin-bottom:calc(var(--ag-spacing)*.5)}`
);
var AgAbstractLabel = class extends AgComponentStub {
  constructor(config, template, components) {
    super(template, components);
    this.labelSeparator = "";
    this.labelAlignment = "left";
    this.disabled = false;
    this.label = "";
    this.config = config || {};
    this.registerCSS(agAbstractLabelCSS);
  }
  postConstruct() {
    this.addCss("ag-labeled");
    this.eLabel.classList.add("ag-label");
    const { labelSeparator, label, labelWidth, labelAlignment, disabled } = this.config;
    if (disabled != null) {
      this.setDisabled(disabled);
    }
    if (labelSeparator != null) {
      this.setLabelSeparator(labelSeparator);
    }
    if (label != null) {
      this.setLabel(label);
    }
    if (labelWidth != null) {
      this.setLabelWidth(labelWidth);
    }
    this.setLabelAlignment(labelAlignment || this.labelAlignment);
    this.refreshLabel();
  }
  refreshLabel() {
    const { label, eLabel } = this;
    _clearElement(eLabel);
    if (typeof label === "string") {
      eLabel.innerText = label + this.labelSeparator;
    } else if (label) {
      eLabel.appendChild(label);
    }
    if (label === "") {
      _setDisplayed(eLabel, false);
      _setAriaRole(eLabel, "presentation");
    } else {
      _setDisplayed(eLabel, true);
      _setAriaRole(eLabel, null);
    }
  }
  setLabelSeparator(labelSeparator) {
    if (this.labelSeparator === labelSeparator) {
      return this;
    }
    this.labelSeparator = labelSeparator;
    if (this.label != null) {
      this.refreshLabel();
    }
    return this;
  }
  getLabelId() {
    const eLabel = this.eLabel;
    eLabel.id = eLabel.id || `ag-${this.getCompId()}-label`;
    return eLabel.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(label) {
    if (this.label === label) {
      return this;
    }
    this.label = label;
    this.refreshLabel();
    return this;
  }
  setLabelAlignment(alignment) {
    const eGui = this.getGui();
    const eGuiClassList = eGui.classList;
    eGuiClassList.toggle("ag-label-align-left", alignment === "left");
    eGuiClassList.toggle("ag-label-align-right", alignment === "right");
    eGuiClassList.toggle("ag-label-align-top", alignment === "top");
    return this;
  }
  setLabelEllipsis(hasEllipsis) {
    this.eLabel.classList.toggle("ag-label-ellipsis", hasEllipsis);
    return this;
  }
  setLabelWidth(width) {
    if (this.label == null) {
      return this;
    }
    _setElementWidth(this.eLabel, width);
    return this;
  }
  setDisabled(disabled) {
    disabled = !!disabled;
    const element = this.getGui();
    _setDisabled(element, disabled);
    element.classList.toggle("ag-disabled", disabled);
    this.disabled = disabled;
    return this;
  }
  isDisabled() {
    return !!this.disabled;
  }
};
var AgAbstractField = class extends AgAbstractLabel {
  constructor(config, template, components, className) {
    super(config, template, components);
    this.className = className;
  }
  postConstruct() {
    super.postConstruct();
    const { width, value, onValueChange } = this.config;
    if (width != null) {
      this.setWidth(width);
    }
    if (value != null) {
      this.setValue(value);
    }
    if (onValueChange != null) {
      this.onValueChange(onValueChange);
    }
    if (this.className) {
      this.addCss(this.className);
    }
    this.refreshAriaLabelledBy();
  }
  setLabel(label) {
    super.setLabel(label);
    this.refreshAriaLabelledBy();
    return this;
  }
  refreshAriaLabelledBy() {
    const ariaEl = this.getAriaElement();
    const labelId = this.getLabelId();
    const label = this.getLabel();
    if (label == null || label == "" || _getAriaLabel(ariaEl) !== null) {
      _setAriaLabelledBy(ariaEl, "");
    } else {
      _setAriaLabelledBy(ariaEl, labelId != null ? labelId : "");
    }
  }
  setAriaLabel(label) {
    _setAriaLabel(this.getAriaElement(), label);
    this.refreshAriaLabelledBy();
    return this;
  }
  onValueChange(callbackFn) {
    this.addManagedListeners(this, { fieldValueChanged: () => callbackFn(this.getValue()) });
    return this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(width) {
    _setFixedWidth(this.getGui(), width);
    return this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(value, silent) {
    if (this.value === value) {
      return this;
    }
    this.previousValue = this.value;
    this.value = value;
    if (!silent) {
      this.dispatchLocalEvent({ type: "fieldValueChanged" });
    }
    return this;
  }
};
function buildTemplate(displayFieldTag) {
  return {
    tag: "div",
    role: "presentation",
    children: [
      { tag: "div", ref: "eLabel", cls: "ag-input-field-label" },
      {
        tag: "div",
        ref: "eWrapper",
        cls: "ag-wrapper ag-input-wrapper",
        role: "presentation",
        children: [{ tag: displayFieldTag, ref: "eInput", cls: "ag-input-field-input" }]
      }
    ]
  };
}
var AgAbstractInputField = class extends AgAbstractField {
  constructor(config, className, inputType = "text", displayFieldTag = "input") {
    var _a4;
    super(config, (_a4 = config == null ? void 0 : config.template) != null ? _a4 : buildTemplate(displayFieldTag), [], className);
    this.inputType = inputType;
    this.displayFieldTag = displayFieldTag;
    this.eLabel = RefPlaceholder;
    this.eWrapper = RefPlaceholder;
    this.eInput = RefPlaceholder;
  }
  postConstruct() {
    super.postConstruct();
    this.setInputType(this.inputType);
    const { eLabel, eWrapper, eInput, className } = this;
    eLabel.classList.add(`${className}-label`);
    eWrapper.classList.add(`${className}-input-wrapper`);
    eInput.classList.add(`${className}-input`);
    this.addCss("ag-input-field");
    eInput.id = eInput.id || `ag-${this.getCompId()}-input`;
    const { inputName, inputWidth } = this.config;
    if (inputName != null) {
      this.setInputName(inputName);
    }
    if (inputWidth != null) {
      this.setInputWidth(inputWidth);
    }
    this.addInputListeners();
    this.activateTabIndex([eInput]);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, {
      input: (e) => this.setValue(e.target.value)
    });
  }
  setInputType(inputType) {
    if (this.displayFieldTag === "input") {
      this.inputType = inputType;
      _addOrRemoveAttribute(this.eInput, "type", inputType);
    }
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(width) {
    _setElementWidth(this.eWrapper, width);
    return this;
  }
  setInputName(name) {
    this.getInputElement().setAttribute("name", name);
    return this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(length) {
    const eInput = this.eInput;
    eInput.maxLength = length;
    return this;
  }
  setInputPlaceholder(placeholder) {
    _addOrRemoveAttribute(this.eInput, "placeholder", placeholder);
    return this;
  }
  setInputAriaLabel(label) {
    _setAriaLabel(this.eInput, label);
    this.refreshAriaLabelledBy();
    return this;
  }
  setDisabled(disabled) {
    _setDisabled(this.eInput, disabled);
    return super.setDisabled(disabled);
  }
  setAutoComplete(value) {
    if (value === true) {
      _addOrRemoveAttribute(this.eInput, "autocomplete", null);
    } else {
      const autoCompleteValue = typeof value === "string" ? value : "off";
      _addOrRemoveAttribute(this.eInput, "autocomplete", autoCompleteValue);
    }
    return this;
  }
};
var AgCheckbox = class extends AgAbstractInputField {
  constructor(config, className = "ag-checkbox", inputType = "checkbox") {
    super(config, className, inputType);
    this.labelAlignment = "right";
    this.selected = false;
    this.readOnly = false;
    this.passive = false;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly, passive } = this.config;
    if (typeof readOnly === "boolean")
      this.setReadOnly(readOnly);
    if (typeof passive === "boolean")
      this.setPassive(passive);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) });
    this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
  }
  getNextValue() {
    return this.selected === void 0 ? true : !this.selected;
  }
  setPassive(passive) {
    this.passive = passive;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(readOnly) {
    this.eWrapper.classList.toggle("ag-disabled", readOnly);
    this.eInput.disabled = readOnly;
    this.readOnly = readOnly;
  }
  setDisabled(disabled) {
    this.eWrapper.classList.toggle("ag-disabled", disabled);
    return super.setDisabled(disabled);
  }
  toggle() {
    if (this.eInput.disabled) {
      return;
    }
    const previousValue = this.isSelected();
    const nextValue = this.getNextValue();
    if (this.passive) {
      this.dispatchChange(nextValue, previousValue);
    } else {
      this.setValue(nextValue);
    }
  }
  getValue() {
    return this.isSelected();
  }
  setValue(value, silent) {
    this.refreshSelectedClass(value);
    this.setSelected(value, silent);
    return this;
  }
  setName(name) {
    const input = this.getInputElement();
    input.name = name;
    return this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(selected, silent) {
    if (this.isSelected() === selected) {
      return;
    }
    this.previousValue = this.isSelected();
    selected = this.selected = typeof selected === "boolean" ? selected : void 0;
    const eInput = this.eInput;
    eInput.checked = selected;
    eInput.indeterminate = selected === void 0;
    if (!silent) {
      this.dispatchChange(this.selected, this.previousValue);
    }
  }
  dispatchChange(selected, previousValue, event) {
    this.dispatchLocalEvent({ type: "fieldValueChanged", selected, previousValue, event });
    const input = this.getInputElement();
    this.eventSvc.dispatchEvent({
      type: "checkboxChanged",
      id: input.id,
      name: input.name,
      selected,
      previousValue
    });
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled) {
      return;
    }
    const previousValue = this.isSelected();
    const selected = this.selected = e.target.checked;
    this.refreshSelectedClass(selected);
    this.dispatchChange(selected, previousValue, e);
  }
  refreshSelectedClass(value) {
    const classList = this.eWrapper.classList;
    classList.toggle("ag-checked", value === true);
    classList.toggle("ag-indeterminate", value == null);
  }
};
var AgCheckboxSelector = {
  selector: "AG-CHECKBOX",
  component: AgCheckbox
};
var sharedCSS = (
  /*css*/
  `:where(.ag-root-wrapper,.ag-external,.ag-popup,.ag-dnd-ghost,.ag-chart),:where(.ag-root-wrapper,.ag-external,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]){box-sizing:border-box;&:after,&:before{box-sizing:border-box}&:where(div,span,label):focus-visible{box-shadow:inset var(--ag-focus-shadow);outline:none;&:where(.invalid){box-shadow:inset var(--ag-focus-error-shadow)}}&:where(button){color:inherit}}:where(.ag-root-wrapper,ag-external,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]) ::-ms-clear{display:none}.ag-hidden{display:none!important}.ag-invisible{visibility:hidden!important}.ag-popup-child{top:0;z-index:5;&:where(:not(.ag-tooltip-custom)){box-shadow:var(--ag-popup-shadow)}}.ag-input-wrapper,.ag-picker-field-wrapper{align-items:center;display:flex;flex:1 1 auto;line-height:normal;position:relative}.ag-input-field{align-items:center;display:flex;flex-direction:row}.ag-input-field-input:where(:not([type=checkbox],[type=radio])){flex:1 1 auto;min-width:0;width:100%}.ag-chart,.ag-dnd-ghost,.ag-external,.ag-popup,.ag-root-wrapper{cursor:default;line-height:normal;white-space:normal;-webkit-font-smoothing:antialiased;background-color:var(--ag-background-color);color:var(--ag-text-color);color-scheme:var(--ag-browser-color-scheme);font-family:var(--ag-font-family);font-size:var(--ag-font-size);--ag-indentation-level:0}:where(.ag-icon):before{align-items:center;background-color:currentcolor;color:inherit;content:"";display:flex;font-family:inherit;font-size:var(--ag-icon-size);font-style:normal;font-variant:normal;height:var(--ag-icon-size);justify-content:center;line-height:var(--ag-icon-size);-webkit-mask-size:contain;mask-size:contain;text-transform:none;width:var(--ag-icon-size)}.ag-icon{background-position:50%;background-repeat:no-repeat;background-size:contain;color:var(--ag-icon-color);display:block;height:var(--ag-icon-size);position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-icon-size)}.ag-disabled,[disabled]{.ag-icon{opacity:.5}&.ag-icon-grip{opacity:.35}}.ag-resizer{pointer-events:none;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none;z-index:1}:where(.ag-resizer){&.ag-resizer-topLeft{cursor:nwse-resize;height:5px;left:0;top:0;width:5px}&.ag-resizer-top{cursor:ns-resize;height:5px;left:5px;right:5px;top:0}&.ag-resizer-topRight{cursor:nesw-resize;height:5px;right:0;top:0;width:5px}&.ag-resizer-right{bottom:5px;cursor:ew-resize;right:0;top:5px;width:5px}&.ag-resizer-bottomRight{bottom:0;cursor:nwse-resize;height:5px;right:0;width:5px}&.ag-resizer-bottom{bottom:0;cursor:ns-resize;height:5px;left:5px;right:5px}&.ag-resizer-bottomLeft{bottom:0;cursor:nesw-resize;height:5px;left:0;width:5px}&.ag-resizer-left{bottom:5px;cursor:ew-resize;left:0;top:5px;width:5px}}`
);
var _a, _b;
var IS_SSR = typeof window !== "object" || !((_b = (_a = window == null ? void 0 : window.document) == null ? void 0 : _a.fonts) == null ? void 0 : _b.forEach);
var FORCE_LEGACY_THEMES = false;
var _injectGlobalCSS = (css, styleContainer, debugId, layer, priority, nonce) => {
  if (IS_SSR)
    return;
  if (FORCE_LEGACY_THEMES)
    return;
  if (layer) {
    css = `@layer ${CSS.escape(layer)} { ${css} }`;
  }
  let injections = injectionState.map.get(styleContainer);
  if (!injections) {
    injections = [];
    injectionState.map.set(styleContainer, injections);
  }
  if (injections.find((i) => i.css === css))
    return;
  const el = document.createElement("style");
  if (nonce) {
    el.setAttribute("nonce", nonce);
  }
  el.dataset.agGlobalCss = debugId;
  el.textContent = css;
  const newInjection = { css, el, priority };
  let insertAfter;
  for (const injection of injections) {
    if (injection.priority > priority)
      break;
    insertAfter = injection;
  }
  if (insertAfter) {
    insertAfter.el.insertAdjacentElement("afterend", el);
    const index = injections.indexOf(insertAfter);
    injections.splice(index + 1, 0, newInjection);
  } else {
    styleContainer.insertBefore(el, styleContainer.querySelector(":not(title, meta)"));
    injections.push(newInjection);
  }
};
var _injectCoreAndModuleCSS = (styleContainer, layer, nonce, moduleCss) => {
  _injectGlobalCSS(sharedCSS, styleContainer, "shared", layer, 0, nonce);
  moduleCss == null ? void 0 : moduleCss.forEach(
    (css, debugId) => css.forEach((singleCss) => _injectGlobalCSS(singleCss, styleContainer, debugId, layer, 0, nonce))
  );
};
var _registerInstanceUsingThemingAPI = (environment) => {
  injectionState.grids.add(environment);
};
var _unregisterInstanceUsingThemingAPI = (environment) => {
  injectionState.grids.delete(environment);
  if (injectionState.grids.size === 0) {
    injectionState.map = /* @__PURE__ */ new WeakMap();
    for (const style of document.head.querySelectorAll("style[data-ag-global-css]")) {
      style.remove();
    }
  }
};
var _a2;
var _a3;
var injectionState = (_a3 = (_a2 = typeof window === "object" ? window : {}).agStyleInjectionState) != null ? _a3 : _a2.agStyleInjectionState = {
  map: /* @__PURE__ */ new WeakMap(),
  grids: /* @__PURE__ */ new Set()
};
var createPart = (args) => {
  return new PartImpl(args);
};
var defaultModeName = "$default";
var partCounter = 0;
var PartImpl = class {
  constructor({ feature, params, modeParams = {}, css, cssImports }) {
    var _a4;
    this.feature = feature;
    this.css = css;
    this.cssImports = cssImports;
    this.modeParams = {
      // NOTE: it's important that default is defined first, putting it
      // first in iteration order, because when merging params the default
      // params override any prior modal params, so modal params in this
      // part need to come after default params to prevent them from being
      // immediately overridden.
      [defaultModeName]: {
        ...(_a4 = modeParams[defaultModeName]) != null ? _a4 : {},
        ...params != null ? params : {}
      },
      ...modeParams
    };
  }
  use(styleContainer, layer, nonce) {
    var _a4, _b2;
    let inject = this._inject;
    if (inject == null) {
      let { css } = this;
      if (css) {
        const className = `ag-theme-${(_a4 = this.feature) != null ? _a4 : "part"}-${++partCounter}`;
        if (typeof css === "function")
          css = css();
        css = `:where(.${className}) {
${css}
}
`;
        for (const cssImport of (_b2 = this.cssImports) != null ? _b2 : []) {
          css = `@import url(${JSON.stringify(cssImport)});
${css}`;
        }
        inject = { css, class: className };
      } else {
        inject = false;
      }
      this._inject = inject;
    }
    if (inject && styleContainer) {
      _injectGlobalCSS(inject.css, styleContainer, inject.class, layer, 1, nonce);
    }
    return inject ? inject.class : false;
  }
};
var kebabCase = (str) => str.replace(/[A-Z]/g, (m) => `-${m}`).toLowerCase();
var paramToVariableName = (paramName) => `--ag-${kebabCase(paramName)}`;
var paramToVariableExpression = (paramName) => `var(${paramToVariableName(paramName)})`;
var clamp = (value, min, max) => Math.max(min, Math.min(max, value));
var memoize = (fn) => {
  const values = /* @__PURE__ */ new Map();
  return (a) => {
    const key = a;
    if (!values.has(key)) {
      values.set(key, fn(a));
    }
    return values.get(key);
  };
};
var accentMix = (mix) => ({ ref: "accentColor", mix });
var foregroundMix = (mix) => ({ ref: "foregroundColor", mix });
var foregroundBackgroundMix = (mix) => ({
  ref: "foregroundColor",
  mix,
  onto: "backgroundColor"
});
var foregroundHeaderBackgroundMix = (mix) => ({
  ref: "foregroundColor",
  mix,
  onto: "headerBackgroundColor"
});
var backgroundColor = { ref: "backgroundColor" };
var foregroundColor = { ref: "foregroundColor" };
var accentColor = { ref: "accentColor" };
var defaultLightColorSchemeParams = {
  backgroundColor: "#fff",
  foregroundColor: "#181d1f",
  borderColor: foregroundMix(0.15),
  chromeBackgroundColor: foregroundBackgroundMix(0.02),
  browserColorScheme: "light"
};
var sharedDefaults = {
  ...defaultLightColorSchemeParams,
  textColor: foregroundColor,
  accentColor: "#2196f3",
  invalidColor: "#e02525",
  fontFamily: [
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu",
    "Cantarell",
    "Helvetica Neue",
    "sans-serif"
  ],
  subtleTextColor: {
    ref: "textColor",
    mix: 0.5
  },
  borderWidth: 1,
  borderRadius: 4,
  spacing: 8,
  fontSize: 14,
  focusShadow: {
    spread: 3,
    color: accentMix(0.5)
  },
  focusErrorShadow: {
    spread: 3,
    color: {
      ref: "invalidColor",
      onto: "backgroundColor",
      mix: 0.5
    }
  },
  popupShadow: "0 0 16px #00000026",
  cardShadow: "0 1px 4px 1px #00000018",
  dropdownShadow: { ref: "cardShadow" },
  listItemHeight: {
    calc: "max(iconSize, dataFontSize) + widgetVerticalSpacing"
  },
  dragAndDropImageBackgroundColor: backgroundColor,
  dragAndDropImageBorder: true,
  dragAndDropImageNotAllowedBorder: {
    color: {
      ref: "invalidColor",
      onto: "dragAndDropImageBackgroundColor",
      mix: 0.5
    }
  },
  dragAndDropImageShadow: {
    ref: "popupShadow"
  },
  iconSize: 16,
  iconColor: "inherit",
  toggleButtonWidth: 28,
  toggleButtonHeight: 18,
  toggleButtonOnBackgroundColor: accentColor,
  toggleButtonOffBackgroundColor: foregroundBackgroundMix(0.3),
  toggleButtonSwitchBackgroundColor: backgroundColor,
  toggleButtonSwitchInset: 2,
  tooltipBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  tooltipErrorBackgroundColor: {
    ref: "invalidColor",
    onto: "backgroundColor",
    mix: 0.1
  },
  tooltipTextColor: {
    ref: "textColor"
  },
  tooltipErrorTextColor: {
    ref: "invalidColor"
  },
  tooltipBorder: true,
  tooltipErrorBorder: {
    color: {
      ref: "invalidColor",
      onto: "backgroundColor",
      mix: 0.25
    }
  }
};
var paramTypes = [
  "colorScheme",
  "color",
  "length",
  "scale",
  "borderStyle",
  "border",
  "shadow",
  "image",
  "fontFamily",
  "fontWeight",
  "duration"
];
var getParamType = memoize((param) => {
  var _a4;
  param = param.toLowerCase();
  return (_a4 = paramTypes.find((type) => param.endsWith(type.toLowerCase()))) != null ? _a4 : "length";
});
var literalToCSS = (value) => {
  if (typeof value === "object" && (value == null ? void 0 : value.ref))
    return paramToVariableExpression(value.ref);
  if (typeof value === "string")
    return value;
  if (typeof value === "number")
    return String(value);
  return false;
};
var colorValueToCss = (value) => {
  if (typeof value === "string")
    return value;
  if (value && "ref" in value) {
    const colorExpr = paramToVariableExpression(value.ref);
    if (value.mix == null) {
      return colorExpr;
    }
    const backgroundExpr = value.onto ? paramToVariableExpression(value.onto) : "transparent";
    return `color-mix(in srgb, ${backgroundExpr}, ${colorExpr} ${clamp(value.mix * 100, 0, 100)}%)`;
  }
  return false;
};
var colorSchemeValueToCss = literalToCSS;
var lengthValueToCss = (value) => {
  if (typeof value === "string")
    return value;
  if (typeof value === "number")
    return `${value}px`;
  if (value && "calc" in value) {
    const valueWithSpaces = value.calc.replace(/ ?[*/+] ?/g, " $& ");
    return `calc(${valueWithSpaces.replace(/-?\b[a-z][a-z0-9]*\b(?![-(])/gi, (p) => p[0] === "-" ? p : ` ${paramToVariableExpression(p)} `)})`;
  }
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return false;
};
var scaleValueToCss = literalToCSS;
var borderValueToCss = (value, param) => {
  var _a4, _b2, _c;
  if (typeof value === "string")
    return value;
  if (value === true)
    return borderValueToCss({}, param);
  if (value === false)
    return param === "columnBorder" ? borderValueToCss({ color: "transparent" }, param) : "none";
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return borderStyleValueToCss((_a4 = value.style) != null ? _a4 : "solid") + " " + lengthValueToCss((_b2 = value.width) != null ? _b2 : { ref: "borderWidth" }) + " " + colorValueToCss((_c = value.color) != null ? _c : { ref: "borderColor" });
};
var shadowValueToCss = (value) => {
  var _a4, _b2, _c, _d, _e;
  if (typeof value === "string")
    return value;
  if (value === false)
    return "none";
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return [
    lengthValueToCss((_a4 = value.offsetX) != null ? _a4 : 0),
    lengthValueToCss((_b2 = value.offsetY) != null ? _b2 : 0),
    lengthValueToCss((_c = value.radius) != null ? _c : 0),
    lengthValueToCss((_d = value.spread) != null ? _d : 0),
    colorValueToCss((_e = value.color) != null ? _e : { ref: "foregroundColor" })
  ].join(" ");
};
var borderStyleValueToCss = literalToCSS;
var fontFamilyValueToCss = (value) => {
  if (typeof value === "string")
    return value.includes(",") ? value : quoteUnsafeChars(value);
  if (value && "googleFont" in value)
    return fontFamilyValueToCss(value.googleFont);
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  if (Array.isArray(value)) {
    return value.map((font) => {
      if (typeof font === "object" && "googleFont" in font) {
        font = font.googleFont;
      }
      return quoteUnsafeChars(font);
    }).join(", ");
  }
  return false;
};
var quoteUnsafeChars = (font) => (
  // don't quote var() expressions or quote safe identifier names, so that
  // people can specify fonts like sans-serif which are keywords not strings,
  // or var(--my-var)
  /^[\w-]+$|\w\(/.test(font) ? font : JSON.stringify(font)
);
var fontWeightValueToCss = literalToCSS;
var imageValueToCss = (value) => {
  if (typeof value === "string")
    return value;
  if (value && "url" in value)
    return `url(${JSON.stringify(value.url)})`;
  if (value && "svg" in value)
    return imageValueToCss({ url: `data:image/svg+xml,${encodeURIComponent(value.svg)}` });
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return false;
};
var durationValueToCss = (value, param, themeLogger) => {
  if (typeof value === "string")
    return value;
  if (typeof value === "number") {
    if (value >= 10) {
      themeLogger.warn(104, { value, param });
    }
    return `${value}s`;
  }
  if (value && "ref" in value)
    return paramToVariableExpression(value.ref);
  return false;
};
var paramValidators = {
  color: colorValueToCss,
  colorScheme: colorSchemeValueToCss,
  length: lengthValueToCss,
  scale: scaleValueToCss,
  border: borderValueToCss,
  borderStyle: borderStyleValueToCss,
  shadow: shadowValueToCss,
  image: imageValueToCss,
  fontFamily: fontFamilyValueToCss,
  fontWeight: fontWeightValueToCss,
  duration: durationValueToCss
};
var paramValueToCss = (param, value, themeLogger) => {
  const type = getParamType(param);
  return paramValidators[type](value, param, themeLogger);
};
var createSharedTheme = (themeLogger) => new ThemeImpl(themeLogger);
var ThemeImpl = class _ThemeImpl {
  constructor(themeLogger, parts = []) {
    this.themeLogger = themeLogger;
    this.parts = parts;
  }
  withPart(part) {
    if (typeof part === "function")
      part = part();
    if (!(part instanceof PartImpl)) {
      this.themeLogger.preInitErr(259, "Invalid part", { part });
      return this;
    }
    return new _ThemeImpl(this.themeLogger, [...this.parts, part]);
  }
  withoutPart(feature) {
    return this.withPart(createPart({ feature }));
  }
  withParams(params, mode = defaultModeName) {
    return this.withPart(
      createPart({
        modeParams: { [mode]: params }
      })
    );
  }
  /**
   * Called by a grid instance when it starts using the theme. This installs
   * the theme's parts into document head, or the shadow DOM if the provided
   * container is within a shadow root.
   */
  _startUse({ styleContainer, cssLayer, nonce, loadThemeGoogleFonts, moduleCss }) {
    if (IS_SSR)
      return;
    if (FORCE_LEGACY_THEMES)
      return;
    uninstallLegacyCSS();
    _injectCoreAndModuleCSS(styleContainer, cssLayer, nonce, moduleCss);
    const googleFontsUsed = getGoogleFontsUsed(this);
    if (googleFontsUsed.length > 0) {
      for (const googleFont of googleFontsUsed) {
        if (loadThemeGoogleFonts) {
          loadGoogleFont(googleFont, nonce);
        }
      }
    }
    for (const part of this.parts) {
      part.use(styleContainer, cssLayer, nonce);
    }
  }
  /**
   * Return CSS that that applies the params of this theme to elements with
   * the provided class name
   */
  _getCssClass() {
    var _a4;
    if (FORCE_LEGACY_THEMES)
      return "ag-theme-quartz";
    return (_a4 = this._cssClassCache) != null ? _a4 : this._cssClassCache = deduplicatePartsByFeature(this.parts).map((part) => part.use(void 0, void 0, void 0)).filter(Boolean).join(" ");
  }
  _getModeParams() {
    var _a4;
    let paramsCache = this._paramsCache;
    if (!paramsCache) {
      const mergedModeParams = {
        // NOTE: defining the default mode here is important, it ensures
        // that the default mode is first in iteration order, which puts
        // it first in outputted CSS, allowing other modes to override it
        [defaultModeName]: { ...sharedDefaults }
      };
      for (const part of deduplicatePartsByFeature(this.parts)) {
        for (const partMode of Object.keys(part.modeParams)) {
          const partParams = part.modeParams[partMode];
          if (partParams) {
            const mergedParams = (_a4 = mergedModeParams[partMode]) != null ? _a4 : mergedModeParams[partMode] = {};
            const partParamNames = /* @__PURE__ */ new Set();
            for (const partParamName of Object.keys(partParams)) {
              const partParamValue = partParams[partParamName];
              if (partParamValue !== void 0) {
                mergedParams[partParamName] = partParamValue;
                partParamNames.add(partParamName);
              }
            }
            if (partMode === defaultModeName) {
              for (const mergedMode of Object.keys(mergedModeParams)) {
                const mergedParams2 = mergedModeParams[mergedMode];
                if (mergedMode !== defaultModeName) {
                  for (const partParamName of partParamNames) {
                    delete mergedParams2[partParamName];
                  }
                }
              }
            }
          }
        }
      }
      this._paramsCache = paramsCache = mergedModeParams;
    }
    return paramsCache;
  }
  /**
   * Return the CSS chunk that is inserted into the grid DOM, and will
   * therefore be removed automatically when the grid is destroyed or it
   * starts to use a new theme.
   *
   * @param className a unique class name on the grid wrapper used to scope the returned CSS to the grid instance
   */
  _getPerInstanceCss(className) {
    const selectorPlaceholder = "##SELECTOR##";
    let innerParamsCss = this._paramsCssCache;
    if (!innerParamsCss) {
      let variablesCss = "";
      let inheritanceCss = "";
      const modeParams = this._getModeParams();
      for (const mode of Object.keys(modeParams)) {
        const params = modeParams[mode];
        if (mode !== defaultModeName) {
          const escapedMode = typeof CSS === "object" ? CSS.escape(mode) : mode;
          const wrapPrefix = `:where([data-ag-theme-mode="${escapedMode}"]) & {
`;
          variablesCss += wrapPrefix;
          inheritanceCss += wrapPrefix;
        }
        for (const key of Object.keys(params).sort()) {
          const value = params[key];
          const cssValue = paramValueToCss(key, value, this.themeLogger);
          if (cssValue === false) {
            this.themeLogger.error(107, { key, value });
          } else {
            const cssName = paramToVariableName(key);
            const inheritedName = cssName.replace("--ag-", "--ag-inherited-");
            variablesCss += `	${cssName}: var(${inheritedName}, ${cssValue});
`;
            inheritanceCss += `	${inheritedName}: var(${cssName});
`;
          }
        }
        if (mode !== defaultModeName) {
          variablesCss += "}\n";
          inheritanceCss += "}\n";
        }
      }
      let css = `${selectorPlaceholder} {
${variablesCss}}
`;
      css += `:has(> ${selectorPlaceholder}):not(${selectorPlaceholder}) {
${inheritanceCss}}
`;
      this._paramsCssCache = innerParamsCss = css;
    }
    return innerParamsCss.replaceAll(selectorPlaceholder, `:where(.${className})`);
  }
};
var deduplicatePartsByFeature = (parts) => {
  const lastPartByFeature = /* @__PURE__ */ new Map();
  for (const part of parts) {
    lastPartByFeature.set(part.feature, part);
  }
  const result = [];
  for (const part of parts) {
    if (!part.feature || lastPartByFeature.get(part.feature) === part) {
      result.push(part);
    }
  }
  return result;
};
var getGoogleFontsUsed = (theme) => {
  const googleFontsUsed = /* @__PURE__ */ new Set();
  const visitParamValue = (paramValue) => {
    if (Array.isArray(paramValue)) {
      paramValue.forEach(visitParamValue);
    } else {
      const googleFont = paramValue == null ? void 0 : paramValue.googleFont;
      if (typeof googleFont === "string") {
        googleFontsUsed.add(googleFont);
      }
    }
  };
  const allModeValues = Object.values(theme._getModeParams());
  const allValues = allModeValues.flatMap((mv) => Object.values(mv));
  allValues.forEach(visitParamValue);
  return Array.from(googleFontsUsed).sort();
};
var uninstalledLegacyCSS = false;
var uninstallLegacyCSS = () => {
  if (uninstalledLegacyCSS)
    return;
  uninstalledLegacyCSS = true;
  for (const style of Array.from(document.head.querySelectorAll('style[data-ag-scope="legacy"]'))) {
    style.remove();
  }
};
var googleFontsLoaded = /* @__PURE__ */ new Set();
var loadGoogleFont = async (font, nonce) => {
  googleFontsLoaded.add(font);
  const css = `@import url('https://${googleFontsDomain}/css2?family=${encodeURIComponent(font)}:wght@100;200;300;400;500;600;700;800;900&display=swap');
`;
  _injectGlobalCSS(css, document.head, `googleFont:${font}`, void 0, 0, nonce);
};
var googleFontsDomain = "fonts.googleapis.com";
var contextId = 1;
var AgContext = class {
  constructor(params) {
    this.beans = {};
    this.createdBeans = [];
    this.destroyed = false;
    this.instanceId = contextId++;
    if (!params || !params.beanClasses) {
      return;
    }
    this.beanDestroyComparator = params.beanDestroyComparator;
    this.init(params);
  }
  init(params) {
    var _a4;
    this.id = params.id;
    this.beans.context = this;
    this.destroyCallback = params.destroyCallback;
    for (const beanName of Object.keys(params.providedBeanInstances)) {
      this.beans[beanName] = params.providedBeanInstances[beanName];
    }
    params.beanClasses.forEach((BeanClass) => {
      const instance = new BeanClass();
      if (instance.beanName) {
        this.beans[instance.beanName] = instance;
      } else {
        console.error(`Bean ${BeanClass.name} is missing beanName`);
      }
      this.createdBeans.push(instance);
    });
    (_a4 = params.derivedBeans) == null ? void 0 : _a4.forEach((beanFunc) => {
      const { beanName, bean } = beanFunc(this);
      this.beans[beanName] = bean;
      this.createdBeans.push(bean);
    });
    if (params.beanInitComparator) {
      this.createdBeans.sort(params.beanInitComparator);
    }
    this.initBeans(this.createdBeans);
  }
  getBeanInstances() {
    return Object.values(this.beans);
  }
  createBean(bean, afterPreCreateCallback) {
    this.initBeans([bean], afterPreCreateCallback);
    return bean;
  }
  initBeans(beanInstances, afterPreCreateCallback) {
    const beans = this.beans;
    beanInstances.forEach((instance) => {
      var _a4, _b2;
      (_a4 = instance.preWireBeans) == null ? void 0 : _a4.call(instance, beans);
      (_b2 = instance.wireBeans) == null ? void 0 : _b2.call(instance, beans);
    });
    beanInstances.forEach((instance) => {
      var _a4;
      return (_a4 = instance.preConstruct) == null ? void 0 : _a4.call(instance);
    });
    if (afterPreCreateCallback) {
      beanInstances.forEach(afterPreCreateCallback);
    }
    beanInstances.forEach((instance) => {
      var _a4;
      return (_a4 = instance.postConstruct) == null ? void 0 : _a4.call(instance);
    });
  }
  getBeans() {
    return this.beans;
  }
  getBean(name) {
    return this.beans[name];
  }
  getId() {
    return this.id;
  }
  destroy() {
    var _a4;
    if (this.destroyed) {
      return;
    }
    this.destroyed = true;
    const beanInstances = this.getBeanInstances();
    if (this.beanDestroyComparator) {
      beanInstances.sort(this.beanDestroyComparator);
    }
    this.destroyBeans(beanInstances);
    this.beans = {};
    this.createdBeans = [];
    (_a4 = this.destroyCallback) == null ? void 0 : _a4.call(this);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(bean) {
    var _a4;
    (_a4 = bean == null ? void 0 : bean.destroy) == null ? void 0 : _a4.call(bean);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(beans) {
    if (beans) {
      for (let i = 0; i < beans.length; i++) {
        this.destroyBean(beans[i]);
      }
    }
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
};
var paramsId = 0;
var BaseEnvironment = class extends AgBeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "environment";
    this.paramsClass = `ag-theme-params-${++paramsId}`;
    this.globalCSS = [];
  }
  wireBeans(beans) {
    this.eRootDiv = beans.eRootDiv;
  }
  postConstruct() {
    var _a4;
    const { gos, eRootDiv } = this;
    gos.setInstanceDomData(eRootDiv);
    this.eStyleContainer = (_a4 = gos.get("themeStyleContainer")) != null ? _a4 : eRootDiv.getRootNode() === document ? document.head : eRootDiv;
    this.cssLayer = gos.get("themeCssLayer");
    this.styleNonce = gos.get("styleNonce");
    this.addManagedPropertyListener("theme", () => this.handleThemeChange());
    this.handleThemeChange();
    this.initVariables();
    this.addDestroyFunc(() => _unregisterInstanceUsingThemingAPI(this));
    this.mutationObserver = new MutationObserver(() => {
      this.fireStylesChangedEvent("themeChanged");
    });
    this.addDestroyFunc(() => this.mutationObserver.disconnect());
  }
  applyThemeClasses(el, extraClasses = []) {
    const { theme } = this;
    let themeClass;
    if (theme) {
      themeClass = `${this.paramsClass} ${theme._getCssClass()}`;
    } else {
      themeClass = this.applyLegacyThemeClasses();
    }
    for (const className of Array.from(el.classList)) {
      if (className.startsWith("ag-theme-")) {
        el.classList.remove(className);
      }
    }
    if (themeClass) {
      const oldClass = el.className;
      el.className = `${oldClass}${oldClass ? " " : ""}${themeClass}${(extraClasses == null ? void 0 : extraClasses.length) ? ` ${extraClasses.join(" ")}` : ""}`;
    }
  }
  applyLegacyThemeClasses() {
    let themeClass = "";
    this.mutationObserver.disconnect();
    let node = this.eRootDiv;
    while (node) {
      let isThemeEl = false;
      for (const className of Array.from(node.classList)) {
        if (className.startsWith("ag-theme-")) {
          isThemeEl = true;
          themeClass = themeClass ? `${themeClass} ${className}` : className;
        }
      }
      if (isThemeEl) {
        this.mutationObserver.observe(node, {
          attributes: true,
          attributeFilter: ["class"]
        });
      }
      node = node.parentElement;
    }
    return themeClass;
  }
  addGlobalCSS(css, debugId) {
    if (this.theme) {
      _injectGlobalCSS(css, this.eStyleContainer, debugId, this.cssLayer, 0, this.styleNonce);
    } else {
      this.globalCSS.push([css, debugId]);
    }
  }
  handleThemeChange() {
    const { gos, theme: oldTheme } = this;
    const themeProperty = gos.get("theme");
    let newTheme;
    if (themeProperty === "legacy") {
      newTheme = void 0;
    } else {
      const themeOrDefault = themeProperty != null ? themeProperty : this.getDefaultTheme();
      if (themeOrDefault instanceof ThemeImpl) {
        newTheme = themeOrDefault;
      } else {
        this.themeError(themeOrDefault);
      }
    }
    if (newTheme !== oldTheme) {
      this.handleNewTheme(newTheme);
    }
    this.postProcessThemeChange(newTheme, themeProperty);
  }
  handleNewTheme(newTheme) {
    const { gos, eRootDiv, globalCSS } = this;
    const additionalCss = this.getAdditionalCss();
    if (newTheme) {
      _registerInstanceUsingThemingAPI(this);
      _injectCoreAndModuleCSS(this.eStyleContainer, this.cssLayer, this.styleNonce, additionalCss);
      for (const [css, debugId] of globalCSS) {
        _injectGlobalCSS(css, this.eStyleContainer, debugId, this.cssLayer, 0, this.styleNonce);
      }
      globalCSS.length = 0;
    }
    this.theme = newTheme;
    newTheme == null ? void 0 : newTheme._startUse({
      loadThemeGoogleFonts: gos.get("loadThemeGoogleFonts"),
      styleContainer: this.eStyleContainer,
      cssLayer: this.cssLayer,
      nonce: this.styleNonce,
      moduleCss: additionalCss
    });
    let eParamsStyle = this.eParamsStyle;
    if (!eParamsStyle) {
      eParamsStyle = this.eParamsStyle = _createAgElement({ tag: "style" });
      const styleNonce = gos.get("styleNonce");
      if (styleNonce) {
        eParamsStyle.setAttribute("nonce", styleNonce);
      }
      eRootDiv.appendChild(eParamsStyle);
    }
    if (!IS_SSR) {
      eParamsStyle.textContent = (newTheme == null ? void 0 : newTheme._getPerInstanceCss(this.paramsClass)) || "";
    }
    this.applyThemeClasses(eRootDiv);
    this.fireStylesChangedEvent("themeChanged");
  }
};
var BaseRegistry = class extends AgBeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "registry";
  }
  registerDynamicBeans(dynamicBeans) {
    var _a4;
    if (dynamicBeans) {
      (_a4 = this.dynamicBeans) != null ? _a4 : this.dynamicBeans = {};
      for (const name of Object.keys(dynamicBeans)) {
        this.dynamicBeans[name] = dynamicBeans[name];
      }
    }
  }
  createDynamicBean(name, mandatory, ...args) {
    if (!this.dynamicBeans) {
      throw new Error(this.getDynamicError(name, true));
    }
    const BeanClass = this.dynamicBeans[name];
    if (BeanClass == null) {
      if (mandatory) {
        throw new Error(this.getDynamicError(name, false));
      }
      return void 0;
    }
    return new BeanClass(...args);
  }
};
var BaseEventService = class extends AgBeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "eventSvc";
    this.eventServiceType = "global";
    this.globalSvc = new LocalEventService();
  }
  addListener(eventType, listener, async) {
    this.globalSvc.addEventListener(eventType, listener, async);
  }
  removeListener(eventType, listener, async) {
    this.globalSvc.removeEventListener(eventType, listener, async);
  }
  addGlobalListener(listener, async = false) {
    this.globalSvc.addGlobalListener(listener, async);
  }
  removeGlobalListener(listener, async = false) {
    this.globalSvc.removeGlobalListener(listener, async);
  }
  dispatchEvent(event) {
    this.globalSvc.dispatchEvent(this.gos.addCommon(event));
  }
  dispatchEventOnce(event) {
    this.globalSvc.dispatchEventOnce(this.gos.addCommon(event));
  }
};
var BaseDragService = class extends AgBeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "dragSvc";
    this.dragEndFunctions = [];
    this.dragSources = [];
  }
  destroy() {
    const { dragSources } = this;
    dragSources.forEach(this.removeListener.bind(this));
    dragSources.length = 0;
    super.destroy();
  }
  removeListener(dragSourceAndListener) {
    const element = dragSourceAndListener.dragSource.eElement;
    const mouseDownListener = dragSourceAndListener.mouseDownListener;
    element.removeEventListener("mousedown", mouseDownListener);
    if (dragSourceAndListener.touchEnabled) {
      const touchStartListener = dragSourceAndListener.touchStartListener;
      element.removeEventListener("touchstart", touchStartListener, { passive: true });
    }
  }
  removeDragSource(params) {
    const { dragSources } = this;
    const dragSourceAndListener = dragSources.find((item) => item.dragSource === params);
    if (!dragSourceAndListener) {
      return;
    }
    this.removeListener(dragSourceAndListener);
    _removeFromArray(dragSources, dragSourceAndListener);
  }
  addDragSource(params) {
    const mouseListener = this.onMouseDown.bind(this, params);
    const { eElement, includeTouch, stopPropagationForTouch } = params;
    eElement.addEventListener("mousedown", mouseListener);
    let touchListener = null;
    const suppressTouch = this.gos.get("suppressTouch");
    if (includeTouch && !suppressTouch) {
      touchListener = (touchEvent) => {
        if (_isFocusableFormField(touchEvent.target)) {
          return;
        }
        if (stopPropagationForTouch) {
          touchEvent.stopPropagation();
        }
        this.onTouchStart(params, touchEvent);
      };
      eElement.addEventListener("touchstart", touchListener, { passive: false });
    }
    this.dragSources.push({
      dragSource: params,
      mouseDownListener: mouseListener,
      touchStartListener: touchListener,
      touchEnabled: !!includeTouch
    });
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(params, touchEvent) {
    this.currentDragParams = params;
    this.dragging = false;
    const touch = touchEvent.touches[0];
    this.touchLastTime = touch;
    this.touchStart = touch;
    const touchMoveEvent = (e) => this.onTouchMove(e, params.eElement);
    const touchEndEvent = (e) => this.onTouchUp(e, params.eElement);
    const documentTouchMove = (e) => {
      if (e.cancelable) {
        e.preventDefault();
      }
    };
    const target = touchEvent.target;
    const events = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      {
        target: _getRootNode(this.beans),
        type: "touchmove",
        listener: documentTouchMove,
        options: { passive: false }
      },
      { target, type: "touchmove", listener: touchMoveEvent, options: { passive: true } },
      { target, type: "touchend", listener: touchEndEvent, options: { passive: true } },
      { target, type: "touchcancel", listener: touchEndEvent, options: { passive: true } }
    ];
    this.addTemporaryEvents(events);
    if (params.dragStartPixels === 0) {
      this.onCommonMove(touch, this.touchStart, params.eElement);
    }
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(params, mouseEvent) {
    const e = mouseEvent;
    if (params.skipMouseEvent && params.skipMouseEvent(mouseEvent)) {
      return;
    }
    if (e._alreadyProcessedByDragService) {
      return;
    }
    e._alreadyProcessedByDragService = true;
    if (mouseEvent.button !== 0) {
      return;
    }
    if (this.shouldPreventMouseEvent(mouseEvent)) {
      mouseEvent.preventDefault();
    }
    this.currentDragParams = params;
    this.dragging = false;
    this.mouseStartEvent = mouseEvent;
    this.startTarget = mouseEvent.target;
    const mouseMoveEvent = (event) => this.onMouseMove(event, params.eElement);
    const mouseUpEvent = (event) => this.onMouseUp(event, params.eElement);
    const contextEvent = (event) => event.preventDefault();
    const keydownEvent = (event) => {
      if (event.key === KeyCode.ESCAPE) {
        this.cancelDrag(params.eElement);
      }
    };
    const target = _getRootNode(this.beans);
    const events = [
      { target, type: "mousemove", listener: mouseMoveEvent },
      { target, type: "mouseup", listener: mouseUpEvent },
      { target, type: "contextmenu", listener: contextEvent },
      { target, type: "keydown", listener: keydownEvent }
    ];
    this.addTemporaryEvents(events);
    if (params.dragStartPixels === 0) {
      this.onMouseMove(mouseEvent, params.eElement);
    }
  }
  addTemporaryEvents(events) {
    events.forEach((currentEvent) => {
      const { target, type, listener, options } = currentEvent;
      target.addEventListener(type, listener, options);
    });
    this.dragEndFunctions.push(() => {
      events.forEach((currentEvent) => {
        const { target, type, listener, options } = currentEvent;
        target.removeEventListener(type, listener, options);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(currentEvent, startEvent) {
    const { dragStartPixels } = this.currentDragParams;
    const requiredPixelDiff = _exists(dragStartPixels) ? dragStartPixels : 4;
    return _areEventsNear(currentEvent, startEvent, requiredPixelDiff);
  }
  getFirstActiveTouch(touchList) {
    for (let i = 0; i < touchList.length; i++) {
      if (touchList[i].identifier === this.touchStart.identifier) {
        return touchList[i];
      }
    }
    return null;
  }
  onCommonMove(currentEvent, startEvent, el) {
    var _a4;
    if (!this.dragging) {
      if (this.isEventNearStartEvent(currentEvent, startEvent)) {
        return;
      }
      this.dragging = true;
      this.eventSvc.dispatchEvent({
        type: "dragStarted",
        target: el
      });
      this.currentDragParams.onDragStart(startEvent);
      if (!this.currentDragParams) {
        this.dragging = false;
        return;
      }
      this.currentDragParams.onDragging(startEvent);
    }
    (_a4 = this.currentDragParams) == null ? void 0 : _a4.onDragging(currentEvent);
  }
  onTouchMove(touchEvent, el) {
    const touch = this.getFirstActiveTouch(touchEvent.touches);
    if (!touch) {
      return;
    }
    this.onCommonMove(touch, this.touchStart, el);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(mouseEvent, el) {
    var _a4;
    if (_isBrowserSafari()) {
      const eDocument = _getDocument(this.beans);
      (_a4 = eDocument.getSelection()) == null ? void 0 : _a4.removeAllRanges();
    }
    if (this.shouldPreventMouseEvent(mouseEvent)) {
      mouseEvent.preventDefault();
    }
    this.onCommonMove(mouseEvent, this.mouseStartEvent, el);
  }
  shouldPreventMouseEvent(mouseEvent) {
    const isMouseMove = mouseEvent.type === "mousemove";
    const isOverFormFieldElement = (mouseEvent2) => {
      const el = mouseEvent2.target;
      const tagName = el == null ? void 0 : el.tagName.toLocaleLowerCase();
      return !!(tagName == null ? void 0 : tagName.match("^a$|textarea|input|select|button"));
    };
    return isMouseMove && mouseEvent.cancelable && _isEventFromThisInstance(this.beans, mouseEvent) && !isOverFormFieldElement(mouseEvent);
  }
  onTouchUp(touchEvent, el) {
    let touch = this.getFirstActiveTouch(touchEvent.changedTouches);
    if (!touch) {
      touch = this.touchLastTime;
    }
    this.onUpCommon(touch, el);
  }
  onMouseUp(mouseEvent, el) {
    this.onUpCommon(mouseEvent, el);
  }
  onUpCommon(eventOrTouch, el) {
    if (this.dragging) {
      this.dragging = false;
      this.currentDragParams.onDragStop(eventOrTouch);
      this.eventSvc.dispatchEvent({
        type: "dragStopped",
        target: el
      });
    }
    this.resetDragProperties();
  }
  cancelDrag(el) {
    var _a4, _b2;
    this.eventSvc.dispatchEvent({
      type: "dragCancelled",
      target: el
    });
    (_b2 = (_a4 = this.currentDragParams) == null ? void 0 : _a4.onDragCancel) == null ? void 0 : _b2.call(_a4);
    this.resetDragProperties();
  }
  resetDragProperties() {
    this.mouseStartEvent = null;
    this.startTarget = null;
    this.touchStart = null;
    this.touchLastTime = null;
    this.currentDragParams = null;
    const { dragEndFunctions } = this;
    dragEndFunctions.forEach((func) => func());
    dragEndFunctions.length = 0;
  }
};
var BaseDragAndDropService = class extends AgBeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "dragAndDrop";
    this.dragSourceAndParamsList = [];
    this.dragItem = null;
    this.lastMouseEvent = null;
    this.lastDraggingEvent = null;
    this.dragSource = null;
    this.dragImageParent = null;
    this.dragImageCompPromise = null;
    this.dragImageComp = null;
    this.dragImageLastIcon = void 0;
    this.dragImageLastLabel = void 0;
    this.dropTargets = [];
    this.lastDropTarget = null;
  }
  addDragSource(dragSource, allowTouch = false) {
    const entry = {
      dragSource,
      eElement: dragSource.eElement,
      dragStartPixels: dragSource.dragStartPixels,
      onDragStart: (mouseEvent) => this.onDragStart(dragSource, mouseEvent),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragCancel: this.onDragCancel.bind(this),
      includeTouch: allowTouch
    };
    this.dragSourceAndParamsList.push(entry);
    this.beans.dragSvc.addDragSource(entry);
  }
  setDragImageCompIcon(iconName, shake = false) {
    const component = this.dragImageComp;
    if (component && (shake || this.dragImageLastIcon !== iconName)) {
      this.dragImageLastIcon = iconName;
      component.setIcon(iconName, shake);
    }
  }
  removeDragSource(dragSource) {
    var _a4;
    const { dragSourceAndParamsList, beans } = this;
    const sourceAndParams = dragSourceAndParamsList.find((item) => item.dragSource === dragSource);
    if (sourceAndParams) {
      (_a4 = beans.dragSvc) == null ? void 0 : _a4.removeDragSource(sourceAndParams);
      _removeFromArray(dragSourceAndParamsList, sourceAndParams);
    }
  }
  destroy() {
    const { dragSourceAndParamsList, dropTargets, beans } = this;
    const dragSvc = beans.dragSvc;
    for (const sourceAndParams of dragSourceAndParamsList) {
      dragSvc == null ? void 0 : dragSvc.removeDragSource(sourceAndParams);
    }
    dragSourceAndParamsList.length = 0;
    dropTargets.length = 0;
    this.clearDragAndDropProperties();
    super.destroy();
  }
  nudge() {
    const lastMouseEvent = this.lastMouseEvent;
    if (lastMouseEvent) {
      this.onDragging(lastMouseEvent, true);
    }
  }
  onDragStart(dragSource, mouseEvent) {
    var _a4;
    this.lastMouseEvent = mouseEvent;
    this.dragSource = dragSource;
    this.dragItem = dragSource.getDragItem();
    (_a4 = dragSource.onDragStarted) == null ? void 0 : _a4.call(dragSource);
    this.createAndUpdateDragImageComp(dragSource);
  }
  onDragStop(mouseEvent) {
    var _a4, _b2;
    const { dragSource, lastDropTarget } = this;
    (_a4 = dragSource == null ? void 0 : dragSource.onDragStopped) == null ? void 0 : _a4.call(dragSource);
    if (lastDropTarget) {
      const dragEndEvent = this.dropTargetEvent(lastDropTarget, mouseEvent, false);
      (_b2 = lastDropTarget.onDragStop) == null ? void 0 : _b2.call(lastDropTarget, dragEndEvent);
    }
    this.clearDragAndDropProperties();
  }
  onDragCancel() {
    var _a4, _b2;
    const { dragSource, lastDropTarget, lastMouseEvent } = this;
    (_a4 = dragSource == null ? void 0 : dragSource.onDragCancelled) == null ? void 0 : _a4.call(dragSource);
    if (lastDropTarget && lastMouseEvent) {
      const dragCancelEvent = this.dropTargetEvent(lastDropTarget, lastMouseEvent, false);
      (_b2 = lastDropTarget.onDragCancel) == null ? void 0 : _b2.call(lastDropTarget, dragCancelEvent);
    }
    this.clearDragAndDropProperties();
  }
  onDragging(mouseEvent, fromNudge = false) {
    var _a4, _b2, _c;
    this.positionDragImageComp(mouseEvent);
    const dropTarget = this.findCurrentDropTarget(mouseEvent);
    const { lastDropTarget, dragSource, dragItem } = this;
    let needUpdate = false;
    if (dropTarget !== lastDropTarget) {
      needUpdate = true;
      if (lastDropTarget) {
        const dragLeaveEvent = this.dropTargetEvent(lastDropTarget, mouseEvent, fromNudge);
        (_a4 = lastDropTarget.onDragLeave) == null ? void 0 : _a4.call(lastDropTarget, dragLeaveEvent);
      }
      if (lastDropTarget !== null && !dropTarget) {
        this.handleExit(dragSource, dragItem);
      } else if (lastDropTarget === null && dropTarget) {
        this.handleEnter(dragSource, dragItem);
      }
      if (dropTarget) {
        const dragEnterEvent = this.dropTargetEvent(dropTarget, mouseEvent, fromNudge);
        (_b2 = dropTarget.onDragEnter) == null ? void 0 : _b2.call(dropTarget, dragEnterEvent);
      }
      this.lastDropTarget = dropTarget;
    } else if (dropTarget) {
      const dragMoveEvent = this.dropTargetEvent(dropTarget, mouseEvent, fromNudge);
      (_c = dropTarget.onDragging) == null ? void 0 : _c.call(dropTarget, dragMoveEvent);
      if (dragMoveEvent == null ? void 0 : dragMoveEvent.changed) {
        needUpdate = true;
      }
    }
    this.lastMouseEvent = mouseEvent;
    if (needUpdate) {
      this.updateDragImageComp();
    }
  }
  clearDragAndDropProperties() {
    this.removeDragImageComp(this.dragImageComp);
    this.dragImageCompPromise = null;
    this.dragImageParent = null;
    this.dragImageLastIcon = void 0;
    this.dragImageLastLabel = void 0;
    this.lastMouseEvent = null;
    this.lastDraggingEvent = null;
    this.lastDropTarget = null;
    this.dragItem = null;
    this.dragSource = null;
  }
  getAllContainersFromDropTarget(dropTarget) {
    const secondaryContainers = dropTarget.getSecondaryContainers ? dropTarget.getSecondaryContainers() : null;
    const containers = [[dropTarget.getContainer()]];
    return secondaryContainers ? containers.concat(secondaryContainers) : containers;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(mouseEvent, dropTarget) {
    const allContainersFromDropTarget = this.getAllContainersFromDropTarget(dropTarget);
    let mouseOverTarget = false;
    const allContainersIntersect = (mouseEvent2, containers) => {
      for (const container of containers) {
        const { width, height, left, right, top, bottom } = container.getBoundingClientRect();
        if (width === 0 || height === 0) {
          return false;
        }
        const horizontalFit = mouseEvent2.clientX >= left && mouseEvent2.clientX < right;
        const verticalFit = mouseEvent2.clientY >= top && mouseEvent2.clientY < bottom;
        if (!horizontalFit || !verticalFit) {
          return false;
        }
      }
      return true;
    };
    for (const currentContainers of allContainersFromDropTarget) {
      if (allContainersIntersect(mouseEvent, currentContainers)) {
        mouseOverTarget = true;
        break;
      }
    }
    const { eElement, type } = this.dragSource;
    if (dropTarget.targetContainsSource && !dropTarget.getContainer().contains(eElement)) {
      return false;
    }
    return mouseOverTarget && dropTarget.isInterestedIn(type, eElement);
  }
  findCurrentDropTarget(mouseEvent) {
    const validDropTargets = this.dropTargets.filter((target) => this.isMouseOnDropTarget(mouseEvent, target));
    const len = validDropTargets.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return validDropTargets[0];
    }
    const rootNode = _getRootNode(this.beans);
    const elementStack = rootNode.elementsFromPoint(mouseEvent.clientX, mouseEvent.clientY);
    for (const el of elementStack) {
      for (const dropTarget of validDropTargets) {
        const containers = this.getAllContainersFromDropTarget(dropTarget).flatMap((a) => a);
        if (containers.indexOf(el) !== -1) {
          return dropTarget;
        }
      }
    }
    return null;
  }
  addDropTarget(dropTarget) {
    this.dropTargets.push(dropTarget);
  }
  removeDropTarget(dropTarget) {
    this.dropTargets = this.dropTargets.filter((target) => target.getContainer() !== dropTarget.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((zones) => zones.external);
  }
  findExternalZone(container) {
    return this.dropTargets.find((zone) => zone.external && zone.getContainer() === container) || null;
  }
  dropTargetEvent(dropTarget, mouseEvent, fromNudge) {
    var _a4;
    const { dragSource, dragItem, lastDraggingEvent, lastMouseEvent } = this;
    const dropZoneTarget = dropTarget.getContainer();
    const rect = dropZoneTarget.getBoundingClientRect();
    const { clientX, clientY } = mouseEvent;
    const xDir = clientX - ((lastMouseEvent == null ? void 0 : lastMouseEvent.clientX) || 0);
    const yDir = clientY - ((lastMouseEvent == null ? void 0 : lastMouseEvent.clientY) || 0);
    const draggingEvent = this.createEvent({
      event: mouseEvent,
      x: clientX - rect.left,
      // relative x
      y: clientY - rect.top,
      // relative y
      vDirection: yDir > 0 ? "down" : yDir < 0 ? "up" : null,
      hDirection: xDir < 0 ? "left" : xDir > 0 ? "right" : null,
      dragSource,
      fromNudge,
      dragItem,
      dropZoneTarget,
      dropTarget: (_a4 = lastDraggingEvent == null ? void 0 : lastDraggingEvent.dropTarget) != null ? _a4 : null,
      // updated by rowDragFeature
      changed: !!(lastDraggingEvent == null ? void 0 : lastDraggingEvent.changed)
    });
    this.lastDraggingEvent = draggingEvent;
    return draggingEvent;
  }
  positionDragImageComp(event) {
    var _a4;
    const gui = (_a4 = this.dragImageComp) == null ? void 0 : _a4.getGui();
    if (gui) {
      _anchorElementToMouseMoveEvent(gui, event, this.beans);
    }
  }
  removeDragImageComp(comp) {
    var _a4;
    if (this.dragImageComp === comp) {
      this.dragImageComp = null;
    }
    if (comp) {
      const eGui = comp.getGui();
      (_a4 = this.dragImageParent) == null ? void 0 : _a4.removeChild(eGui);
      this.destroyBean(comp);
    }
  }
  createAndUpdateDragImageComp(dragSource) {
    var _a4;
    const promise = (_a4 = this.createDragImageComp(dragSource)) != null ? _a4 : null;
    this.dragImageCompPromise = promise;
    promise == null ? void 0 : promise.then((dragImageComp) => {
      if (promise !== this.dragImageCompPromise || !this.lastMouseEvent || !this.isAlive()) {
        this.destroyBean(dragImageComp);
        return;
      }
      this.dragImageCompPromise = null;
      this.dragImageLastIcon = void 0;
      this.dragImageLastLabel = void 0;
      const oldDragImageComp = this.dragImageComp;
      if (oldDragImageComp !== dragImageComp) {
        this.dragImageComp = dragImageComp;
        this.removeDragImageComp(oldDragImageComp);
      }
      if (dragImageComp) {
        this.appendDragImageComp(dragImageComp);
        this.updateDragImageComp();
      }
    });
  }
  appendDragImageComp(component) {
    const eGui = component.getGui();
    const style = eGui.style;
    style.setProperty("position", "absolute");
    style.setProperty("z-index", "9999");
    this.gos.setInstanceDomData(eGui);
    this.beans.environment.applyThemeClasses(eGui);
    style.top = "20px";
    style.left = "20px";
    const targetEl = _getPageBody(this.beans);
    this.dragImageParent = targetEl;
    if (!targetEl) {
      this.warnNoBody();
    } else {
      targetEl.appendChild(eGui);
    }
  }
  updateDragImageComp() {
    var _a4, _b2;
    const { dragImageComp, dragSource, lastDropTarget, lastDraggingEvent, dragImageLastLabel } = this;
    if (!dragImageComp) {
      return;
    }
    this.setDragImageCompIcon((_b2 = (_a4 = lastDropTarget == null ? void 0 : lastDropTarget.getIconName) == null ? void 0 : _a4.call(lastDropTarget, lastDraggingEvent)) != null ? _b2 : null);
    let label = dragSource == null ? void 0 : dragSource.dragItemName;
    if (typeof label === "function") {
      label = label(lastDraggingEvent);
    }
    label || (label = "");
    if (dragImageLastLabel !== label) {
      this.dragImageLastLabel = label;
      dragImageComp.setLabel(label);
    }
  }
};
var DragAndDropService = class extends BaseDragAndDropService {
  createEvent(event) {
    return _addGridCommonParams(this.gos, event);
  }
  createDragImageComp(dragSource) {
    const { gos, beans } = this;
    const userCompDetails = _getDragAndDropImageCompDetails(
      beans.userCompFactory,
      _addGridCommonParams(gos, {
        dragSource
      })
    );
    return userCompDetails == null ? void 0 : userCompDetails.newAgStackInstance();
  }
  handleEnter(dragSource, dragItem) {
    var _a4;
    (_a4 = dragSource == null ? void 0 : dragSource.onGridEnter) == null ? void 0 : _a4.call(dragSource, dragItem);
  }
  handleExit(dragSource, dragItem) {
    var _a4;
    (_a4 = dragSource == null ? void 0 : dragSource.onGridExit) == null ? void 0 : _a4.call(dragSource, dragItem);
  }
  warnNoBody() {
    _warn(54);
  }
  isDropZoneWithinThisGrid(draggingEvent) {
    return this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody.contains(draggingEvent.dropZoneTarget);
  }
  registerGridDropTarget(elementFn, ctrl) {
    const dropTarget = {
      getContainer: elementFn,
      isInterestedIn: (type) => type === 1 || type === 0,
      getIconName: () => "notAllowed"
    };
    this.addDropTarget(dropTarget);
    ctrl.addDestroyFunc(() => this.removeDropTarget(dropTarget));
  }
};
function createUniqueColumnGroupId(groupId, instanceId) {
  return groupId + "_" + instanceId;
}
function isColumnGroup(col) {
  return col instanceof AgColumnGroup;
}
var AgColumnGroup = class extends BeanStub {
  constructor(providedColumnGroup, groupId, partId, pinned) {
    super();
    this.providedColumnGroup = providedColumnGroup;
    this.groupId = groupId;
    this.partId = partId;
    this.pinned = pinned;
    this.isColumn = false;
    this.displayedChildren = [];
    this.autoHeaderHeight = null;
    this.parent = null;
    this.colIdSanitised = _escapeString(this.getUniqueId());
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null;
    this.children = null;
    this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  getUniqueId() {
    return createUniqueColumnGroupId(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const allLeafColumns = this.getProvidedColumnGroup().getLeafColumns();
    if (!allLeafColumns || allLeafColumns.length === 0) {
      return false;
    }
    return allLeafColumns.every((col) => col.isMoving());
  }
  checkLeft() {
    this.displayedChildren.forEach((child) => {
      if (isColumnGroup(child)) {
        child.checkLeft();
      }
    });
    if (this.displayedChildren.length > 0) {
      if (this.gos.get("enableRtl")) {
        const lastChild = _last(this.displayedChildren);
        const lastChildLeft = lastChild.getLeft();
        this.setLeft(lastChildLeft);
      } else {
        const firstChildLeft = this.displayedChildren[0].getLeft();
        this.setLeft(firstChildLeft);
      }
    } else {
      this.setLeft(null);
    }
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(left) {
    this.oldLeft = this.left;
    if (this.left !== left) {
      this.left = left;
      this.dispatchLocalEvent({ type: "leftChanged" });
    }
  }
  getPinned() {
    return this.pinned;
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  getActualWidth() {
    var _a4;
    let groupActualWidth = 0;
    (_a4 = this.displayedChildren) == null ? void 0 : _a4.forEach((child) => {
      groupActualWidth += child.getActualWidth();
    });
    return groupActualWidth;
  }
  isResizable() {
    if (!this.displayedChildren) {
      return false;
    }
    let result = false;
    this.displayedChildren.forEach((child) => {
      if (child.isResizable()) {
        result = true;
      }
    });
    return result;
  }
  getMinWidth() {
    let result = 0;
    this.displayedChildren.forEach((groupChild) => {
      result += groupChild.getMinWidth();
    });
    return result;
  }
  addChild(child) {
    if (!this.children) {
      this.children = [];
    }
    this.children.push(child);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const result = [];
    this.addLeafColumns(result);
    return result;
  }
  getDisplayedLeafColumns() {
    const result = [];
    this.addDisplayedLeafColumns(result);
    return result;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(expanded) {
    this.providedColumnGroup.setExpanded(expanded);
  }
  isAutoHeaderHeight() {
    var _a4;
    return !!((_a4 = this.getColGroupDef()) == null ? void 0 : _a4.autoHeaderHeight);
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(height) {
    const changed = height !== this.autoHeaderHeight;
    this.autoHeaderHeight = height;
    return changed;
  }
  addDisplayedLeafColumns(leafColumns) {
    this.displayedChildren.forEach((child) => {
      if (isColumn(child)) {
        leafColumns.push(child);
      } else if (isColumnGroup(child)) {
        child.addDisplayedLeafColumns(leafColumns);
      }
    });
  }
  addLeafColumns(leafColumns) {
    this.children.forEach((child) => {
      if (isColumn(child)) {
        leafColumns.push(child);
      } else if (isColumnGroup(child)) {
        child.addLeafColumns(leafColumns);
      }
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const parent = this.getParent();
    if (!this.isPadding() || !parent || !parent.isPadding()) {
      return 0;
    }
    return 1 + parent.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let parentWithExpansion = this;
    while (parentWithExpansion != null && parentWithExpansion.isPadding()) {
      parentWithExpansion = parentWithExpansion.getParent();
    }
    const isExpandable = parentWithExpansion ? parentWithExpansion.getProvidedColumnGroup().isExpandable() : false;
    if (!isExpandable) {
      this.displayedChildren = this.children;
      this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
      return;
    }
    this.children.forEach((child) => {
      var _a4;
      const emptyGroup = isColumnGroup(child) && !((_a4 = child.displayedChildren) == null ? void 0 : _a4.length);
      if (emptyGroup) {
        return;
      }
      const headerGroupShow = child.getColumnGroupShow();
      switch (headerGroupShow) {
        case "open":
          if (parentWithExpansion.getProvidedColumnGroup().isExpanded()) {
            this.displayedChildren.push(child);
          }
          break;
        case "closed":
          if (!parentWithExpansion.getProvidedColumnGroup().isExpanded()) {
            this.displayedChildren.push(child);
          }
          break;
        default:
          this.displayedChildren.push(child);
          break;
      }
    });
    this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
  }
};
var FILTER_HANDLER_MAP = {
  agSetColumnFilter: "agSetColumnFilterHandler",
  agMultiColumnFilter: "agMultiColumnFilterHandler",
  agGroupColumnFilter: "agGroupColumnFilterHandler",
  agNumberColumnFilter: "agNumberColumnFilterHandler",
  agDateColumnFilter: "agDateColumnFilterHandler",
  agTextColumnFilter: "agTextColumnFilterHandler"
};
var FILTER_HANDLERS = new Set(Object.values(FILTER_HANDLER_MAP));
function _createElement(params) {
  return _createAgElement(params);
}
var RESIZE_CONTAINER_STYLE = "ag-resizer-wrapper";
var makeDiv = (dataRefPrefix, classSuffix) => ({
  tag: "div",
  ref: `${dataRefPrefix}Resizer`,
  cls: `ag-resizer ag-resizer-${classSuffix}`
});
var RESIZE_TEMPLATE = {
  tag: "div",
  cls: RESIZE_CONTAINER_STYLE,
  children: [
    makeDiv("eTopLeft", "topLeft"),
    makeDiv("eTop", "top"),
    makeDiv("eTopRight", "topRight"),
    makeDiv("eRight", "right"),
    makeDiv("eBottomRight", "bottomRight"),
    makeDiv("eBottom", "bottom"),
    makeDiv("eBottomLeft", "bottomLeft"),
    makeDiv("eLeft", "left")
  ]
};
var AG_GRID_STOP_PROPAGATION = "__ag_Grid_Stop_Propagation";
function _stopPropagationForAgGrid(event) {
  event[AG_GRID_STOP_PROPAGATION] = true;
}
function _isStopPropagationForAgGrid(event) {
  return event[AG_GRID_STOP_PROPAGATION] === true;
}
var FOCUS_MANAGED_CLASS = "ag-focus-managed";
var ManagedFocusFeature = class extends BeanStub {
  constructor(eFocusable, callbacks = {}) {
    super();
    this.eFocusable = eFocusable;
    this.callbacks = callbacks;
    this.callbacks = {
      shouldStopEventPropagation: () => false,
      onTabKeyDown: (e) => {
        if (e.defaultPrevented) {
          return;
        }
        const nextRoot = _findNextFocusableElement(this.beans, this.eFocusable, false, e.shiftKey);
        if (!nextRoot) {
          return;
        }
        nextRoot.focus();
        e.preventDefault();
      },
      ...callbacks
    };
  }
  postConstruct() {
    const {
      eFocusable,
      callbacks: { onFocusIn, onFocusOut }
    } = this;
    eFocusable.classList.add(FOCUS_MANAGED_CLASS);
    this.addKeyDownListeners(eFocusable);
    if (onFocusIn) {
      this.addManagedElementListeners(eFocusable, { focusin: onFocusIn });
    }
    if (onFocusOut) {
      this.addManagedElementListeners(eFocusable, { focusout: onFocusOut });
    }
  }
  addKeyDownListeners(eGui) {
    this.addManagedElementListeners(eGui, {
      keydown: (e) => {
        if (e.defaultPrevented || _isStopPropagationForAgGrid(e)) {
          return;
        }
        const { callbacks } = this;
        if (callbacks.shouldStopEventPropagation(e)) {
          _stopPropagationForAgGrid(e);
          return;
        }
        if (e.key === KeyCode.TAB) {
          callbacks.onTabKeyDown(e);
        } else if (callbacks.handleKeyDown) {
          callbacks.handleKeyDown(e);
        }
      }
    });
  }
};
var LayoutCssClasses = {
  AUTO_HEIGHT: "ag-layout-auto-height",
  NORMAL: "ag-layout-normal",
  PRINT: "ag-layout-print"
};
var LayoutFeature = class extends BeanStub {
  constructor(view) {
    super();
    this.view = view;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this));
    this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const domLayout = this.gos.get("domLayout");
    const params = {
      autoHeight: domLayout === "autoHeight",
      normal: domLayout === "normal",
      print: domLayout === "print"
    };
    const cssClass = params.autoHeight ? LayoutCssClasses.AUTO_HEIGHT : params.print ? LayoutCssClasses.PRINT : LayoutCssClasses.NORMAL;
    this.view.updateLayoutClasses(cssClass, params);
  }
};
var VIEWPORT = "Viewport";
var FAKE_V_SCROLLBAR = "fakeVScrollComp";
var HORIZONTAL_SOURCES = [
  "fakeHScrollComp",
  "centerHeader",
  "topCenter",
  "bottomCenter",
  "stickyTopCenter",
  "stickyBottomCenter"
];
var SCROLL_DEBOUNCE_TIMEOUT = 100;
var SCROLL_END_TIMEOUT = 150;
var GridBodyScrollFeature = class extends BeanStub {
  constructor(eBodyViewport) {
    super();
    this.clearRetryListenerFncs = [];
    this.lastScrollSource = [null, null];
    this.scrollLeft = -1;
    this.nextScrollTop = -1;
    this.scrollTop = -1;
    this.lastOffsetHeight = -1;
    this.lastScrollTop = -1;
    this.lastIsHorizontalScrollShowing = false;
    this.scrollTimer = 0;
    this.isScrollActive = false;
    this.isVerticalPositionInvalidated = true;
    this.isHorizontalPositionInvalidated = true;
    this.eBodyViewport = eBodyViewport;
    this.resetLastHScrollDebounced = _debounce(
      this,
      () => this.lastScrollSource[
        1
        /* Horizontal */
      ] = null,
      SCROLL_END_TIMEOUT
    );
    this.resetLastVScrollDebounced = _debounce(
      this,
      () => this.lastScrollSource[
        0
        /* Vertical */
      ] = null,
      SCROLL_END_TIMEOUT
    );
  }
  wireBeans(beans) {
    this.ctrlsSvc = beans.ctrlsSvc;
    this.animationFrameSvc = beans.animationFrameSvc;
    this.visibleCols = beans.visibleCols;
  }
  destroy() {
    super.destroy();
    this.clearRetryListenerFncs = [];
    window.clearTimeout(this.scrollTimer);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl");
    const invalidateVerticalScroll = this.invalidateVerticalScroll.bind(this);
    const invalidateHorizontalScroll = this.invalidateHorizontalScroll.bind(this);
    this.addManagedEventListeners({
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
      gridSizeChanged: invalidateVerticalScroll,
      // We only invalidate horizontal scrolling when the viewport switches
      // between scrollable and non-scrollable, avoiding unnecessary
      // invalidation on every gridSizeChanged event. If more properties
      // require invalidation, read/write DOM cycles may be needed.
      scrollGapChanged: invalidateHorizontalScroll
    });
    this.addManagedElementListeners(this.eBodyViewport, {
      scroll: invalidateVerticalScroll
    });
    this.ctrlsSvc.whenReady(this, (p) => {
      this.centerRowsCtrl = p.center;
      this.onDisplayedColumnsWidthChanged();
      this.addScrollListener();
    });
  }
  invalidateHorizontalScroll() {
    this.isHorizontalPositionInvalidated = true;
  }
  invalidateVerticalScroll() {
    this.isVerticalPositionInvalidated = true;
  }
  addScrollListener() {
    this.addHorizontalScrollListeners();
    this.addVerticalScrollListeners();
  }
  addHorizontalScrollListeners() {
    this.addManagedElementListeners(this.centerRowsCtrl.eViewport, {
      scroll: this.onHScroll.bind(this, VIEWPORT)
    });
    for (const source of HORIZONTAL_SOURCES) {
      const scrollPartner = this.ctrlsSvc.get(source);
      this.registerScrollPartner(scrollPartner, this.onHScroll.bind(this, source));
    }
  }
  addVerticalScrollListeners() {
    const fakeVScrollComp = this.ctrlsSvc.get("fakeVScrollComp");
    const isDebounce = this.gos.get("debounceVerticalScrollbar");
    const onVScroll = isDebounce ? _debounce(this, this.onVScroll.bind(this, VIEWPORT), SCROLL_DEBOUNCE_TIMEOUT) : this.onVScroll.bind(this, VIEWPORT);
    const onFakeVScroll = isDebounce ? _debounce(this, this.onVScroll.bind(this, FAKE_V_SCROLLBAR), SCROLL_DEBOUNCE_TIMEOUT) : this.onVScroll.bind(this, FAKE_V_SCROLLBAR);
    this.addManagedElementListeners(this.eBodyViewport, { scroll: onVScroll });
    this.registerScrollPartner(fakeVScrollComp, onFakeVScroll);
  }
  registerScrollPartner(comp, callback) {
    comp.onScrollCallback(callback);
  }
  onDisplayedColumnsWidthChanged() {
    if (this.enableRtl) {
      this.horizontallyScrollHeaderCenterAndFloatingCenter();
    }
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft) {
    const notYetInitialised = this.centerRowsCtrl == null;
    if (notYetInitialised) {
      return;
    }
    if (scrollLeft === void 0) {
      scrollLeft = this.centerRowsCtrl.getCenterViewportScrollLeft();
    }
    this.setScrollLeftForAllContainersExceptCurrent(Math.abs(scrollLeft));
  }
  setScrollLeftForAllContainersExceptCurrent(scrollLeft) {
    for (const container of [...HORIZONTAL_SOURCES, VIEWPORT]) {
      if (this.lastScrollSource[
        1
        /* Horizontal */
      ] === container) {
        continue;
      }
      const viewport = this.getViewportForSource(container);
      _setScrollLeft(viewport, scrollLeft, this.enableRtl);
    }
  }
  getViewportForSource(source) {
    if (source === VIEWPORT) {
      return this.centerRowsCtrl.eViewport;
    }
    return this.ctrlsSvc.get(source).eViewport;
  }
  isControllingScroll(source, direction) {
    if (this.lastScrollSource[direction] == null) {
      if (direction === 0) {
        this.lastScrollSource[0] = source;
      } else {
        this.lastScrollSource[1] = source;
      }
      return true;
    }
    return this.lastScrollSource[direction] === source;
  }
  onHScroll(source) {
    if (!this.isControllingScroll(
      source,
      1
      /* Horizontal */
    )) {
      return;
    }
    const centerContainerViewport = this.centerRowsCtrl.eViewport;
    const { scrollLeft } = centerContainerViewport;
    if (this.shouldBlockScrollUpdate(1, scrollLeft, true)) {
      return;
    }
    const newScrollLeft = _getScrollLeft(this.getViewportForSource(source), this.enableRtl);
    this.doHorizontalScroll(newScrollLeft);
    this.resetLastHScrollDebounced();
  }
  onVScroll(source) {
    if (!this.isControllingScroll(
      source,
      0
      /* Vertical */
    )) {
      return;
    }
    let scrollTop;
    if (source === VIEWPORT) {
      scrollTop = this.eBodyViewport.scrollTop;
    } else {
      scrollTop = this.ctrlsSvc.get("fakeVScrollComp").getScrollPosition();
    }
    if (this.shouldBlockScrollUpdate(0, scrollTop, true)) {
      return;
    }
    const { animationFrameSvc } = this;
    animationFrameSvc == null ? void 0 : animationFrameSvc.setScrollTop(scrollTop);
    this.nextScrollTop = scrollTop;
    if (source === VIEWPORT) {
      this.ctrlsSvc.get("fakeVScrollComp").setScrollPosition(scrollTop);
    } else {
      this.eBodyViewport.scrollTop = scrollTop;
    }
    if (animationFrameSvc == null ? void 0 : animationFrameSvc.active) {
      animationFrameSvc.schedule();
    } else {
      this.scrollGridIfNeeded(true);
    }
    this.resetLastVScrollDebounced();
  }
  doHorizontalScroll(scrollLeft) {
    const fakeScrollLeft = this.ctrlsSvc.get("fakeHScrollComp").getScrollPosition();
    if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) {
      return;
    }
    this.scrollLeft = scrollLeft;
    this.fireScrollEvent(
      1
      /* Horizontal */
    );
    this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);
    this.centerRowsCtrl.onHorizontalViewportChanged(true);
  }
  isScrolling() {
    return this.isScrollActive;
  }
  fireScrollEvent(direction) {
    const bodyScrollEvent = {
      type: "bodyScroll",
      direction: direction === 1 ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.isScrollActive = true;
    this.eventSvc.dispatchEvent(bodyScrollEvent);
    window.clearTimeout(this.scrollTimer);
    this.scrollTimer = window.setTimeout(() => {
      this.scrollTimer = 0;
      this.isScrollActive = false;
      this.eventSvc.dispatchEvent({
        ...bodyScrollEvent,
        type: "bodyScrollEnd"
      });
    }, SCROLL_END_TIMEOUT);
  }
  shouldBlockScrollUpdate(direction, scrollTo, touchOnly = false) {
    if (touchOnly && !_isIOSUserAgent()) {
      return false;
    }
    if (direction === 0) {
      return this.shouldBlockVerticalScroll(scrollTo);
    }
    return this.shouldBlockHorizontalScroll(scrollTo);
  }
  shouldBlockVerticalScroll(scrollTo) {
    const clientHeight = _getInnerHeight(this.eBodyViewport);
    const { scrollHeight } = this.eBodyViewport;
    if (scrollTo < 0 || scrollTo + clientHeight > scrollHeight) {
      return true;
    }
    return false;
  }
  shouldBlockHorizontalScroll(scrollTo) {
    const clientWidth = this.centerRowsCtrl.getCenterWidth();
    const { scrollWidth } = this.centerRowsCtrl.eViewport;
    if (this.enableRtl) {
      if (scrollTo > 0) {
        return true;
      }
    } else if (scrollTo < 0) {
      return true;
    }
    if (Math.abs(scrollTo) + clientWidth > scrollWidth) {
      return true;
    }
    return false;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(
      0
      /* Vertical */
    );
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    const scrollLeft = this.scrollLeft;
    let hasHorizontalScrollersOutOfSync = false;
    for (const source of HORIZONTAL_SOURCES) {
      const viewport = this.getViewportForSource(source);
      if (viewport.scrollLeft !== scrollLeft) {
        hasHorizontalScrollersOutOfSync = true;
        break;
      }
    }
    if (hasHorizontalScrollersOutOfSync) {
      this.onHScroll(VIEWPORT);
    }
  }
  scrollGridIfNeeded(suppressedAnimationFrame = false) {
    const frameNeeded = this.scrollTop != this.nextScrollTop;
    if (frameNeeded) {
      this.scrollTop = this.nextScrollTop;
      if (suppressedAnimationFrame) {
        this.invalidateVerticalScroll();
      }
      this.redrawRowsAfterScroll();
    }
    return frameNeeded;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(hScrollPosition, fromAlignedGridsService = false) {
    const minScrollLeft = 0;
    const maxScrollLeft = this.centerRowsCtrl.eViewport.scrollWidth - this.centerRowsCtrl.getCenterWidth();
    if (!fromAlignedGridsService && this.shouldBlockScrollUpdate(1, hScrollPosition)) {
      if (this.enableRtl) {
        hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;
      } else {
        hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);
      }
    }
    _setScrollLeft(this.centerRowsCtrl.eViewport, Math.abs(hScrollPosition), this.enableRtl);
    this.doHorizontalScroll(hScrollPosition);
  }
  setVerticalScrollPosition(vScrollPosition) {
    this.invalidateVerticalScroll();
    this.eBodyViewport.scrollTop = vScrollPosition;
  }
  getVScrollPosition() {
    if (!this.isVerticalPositionInvalidated) {
      const { lastOffsetHeight, lastScrollTop } = this;
      return {
        top: lastScrollTop,
        bottom: lastScrollTop + lastOffsetHeight
      };
    }
    this.isVerticalPositionInvalidated = false;
    const { scrollTop, offsetHeight } = this.eBodyViewport;
    this.lastScrollTop = scrollTop;
    this.lastOffsetHeight = offsetHeight;
    return {
      top: scrollTop,
      bottom: scrollTop + offsetHeight
    };
  }
  /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */
  getApproximateVScollPosition() {
    if (this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0) {
      return {
        top: this.scrollTop,
        bottom: this.scrollTop + this.lastOffsetHeight
      };
    }
    return this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    if (this.isHorizontalPositionInvalidated) {
      this.lastIsHorizontalScrollShowing = this.centerRowsCtrl.isHorizontalScrollShowing();
      this.isHorizontalPositionInvalidated = false;
    }
    return this.lastIsHorizontalScrollShowing;
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(pixels) {
    const oldScrollPosition = this.centerRowsCtrl.eViewport.scrollLeft;
    this.setHorizontalScrollPosition(oldScrollPosition + pixels);
    return this.centerRowsCtrl.eViewport.scrollLeft - oldScrollPosition;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(comparator, position = null) {
    const { rowModel } = this.beans;
    const rowCount = rowModel.getRowCount();
    let indexToSelect = -1;
    for (let i = 0; i < rowCount; i++) {
      const node = rowModel.getRow(i);
      if (typeof comparator === "function") {
        const predicate = comparator;
        if (node && predicate(node)) {
          indexToSelect = i;
          break;
        }
      } else {
        if (comparator === node || comparator === node.data) {
          indexToSelect = i;
          break;
        }
      }
    }
    if (indexToSelect >= 0) {
      this.ensureIndexVisible(indexToSelect, position);
    }
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(index, position, retry = 0) {
    if (_isDomLayout(this.gos, "print")) {
      return;
    }
    const { rowModel } = this.beans;
    const rowCount = rowModel.getRowCount();
    if (typeof index !== "number" || index < 0 || index >= rowCount) {
      _warn(88, { index });
      return;
    }
    this.clearRetryListeners();
    const { frameworkOverrides, pageBounds, rowContainerHeight: heightScaler, rowRenderer } = this.beans;
    frameworkOverrides.wrapIncoming(() => {
      var _a4, _b2;
      const gridBodyCtrl = this.ctrlsSvc.getGridBodyCtrl();
      const rowNode = rowModel.getRow(index);
      let rowGotShiftedDuringOperation;
      let stickyHeightsChanged;
      let attempt = 0;
      this.invalidateVerticalScroll();
      do {
        const { stickyTopHeight, stickyBottomHeight } = gridBodyCtrl;
        const startingRowTop = rowNode.rowTop;
        const startingRowHeight = rowNode.rowHeight;
        const paginationOffset = pageBounds.getPixelOffset();
        const rowTopPixel = rowNode.rowTop - paginationOffset;
        const rowBottomPixel = rowTopPixel + rowNode.rowHeight;
        const scrollPosition = this.getVScrollPosition();
        const heightOffset = heightScaler.divStretchOffset;
        const vScrollTop = scrollPosition.top + heightOffset;
        const vScrollBottom = scrollPosition.bottom + heightOffset;
        const viewportHeight = vScrollBottom - vScrollTop;
        const pxTop = heightScaler.getScrollPositionForPixel(rowTopPixel);
        const pxBottom = heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);
        const pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);
        const rowAboveViewport = vScrollTop + stickyTopHeight > rowTopPixel;
        const rowBelowViewport = vScrollBottom - stickyBottomHeight < rowBottomPixel;
        let newScrollPosition = null;
        if (position === "top") {
          newScrollPosition = pxTop - stickyTopHeight;
        } else if (position === "bottom") {
          newScrollPosition = pxBottom + stickyBottomHeight;
        } else if (position === "middle") {
          newScrollPosition = pxMiddle;
        } else if (rowAboveViewport) {
          newScrollPosition = pxTop - stickyTopHeight;
        } else if (rowBelowViewport) {
          if (pxBottom - pxTop > viewportHeight) {
            newScrollPosition = pxTop - stickyTopHeight;
          } else {
            newScrollPosition = pxBottom + stickyBottomHeight;
          }
        }
        if (newScrollPosition !== null) {
          this.setVerticalScrollPosition(newScrollPosition);
          rowRenderer.redraw({ afterScroll: true });
        }
        rowGotShiftedDuringOperation = startingRowTop !== rowNode.rowTop || startingRowHeight !== rowNode.rowHeight;
        stickyHeightsChanged = stickyTopHeight !== gridBodyCtrl.stickyTopHeight || stickyBottomHeight !== gridBodyCtrl.stickyBottomHeight;
        attempt++;
      } while ((rowGotShiftedDuringOperation || stickyHeightsChanged) && attempt < 10);
      (_a4 = this.animationFrameSvc) == null ? void 0 : _a4.flushAllFrames();
      if (retry < 10 && ((rowNode == null ? void 0 : rowNode.stub) || !((_b2 = this.beans.rowAutoHeight) == null ? void 0 : _b2.areRowsMeasured()))) {
        const scrollTop = this.getVScrollPosition().top;
        this.clearRetryListenerFncs = this.addManagedEventListeners({
          bodyScroll: () => {
            const newScrollTop = this.getVScrollPosition().top;
            if (scrollTop === newScrollTop) {
              return;
            }
            this.clearRetryListeners();
          },
          modelUpdated: () => {
            this.clearRetryListeners();
            if (index >= rowModel.getRowCount()) {
              return;
            }
            this.ensureIndexVisible(index, position, retry + 1);
          }
        });
      }
    });
  }
  clearRetryListeners() {
    this.clearRetryListenerFncs.forEach((callback) => callback());
    this.clearRetryListenerFncs = [];
  }
  ensureColumnVisible(key, position = "auto") {
    const { colModel, frameworkOverrides } = this.beans;
    const column = colModel.getCol(key);
    if (!column) {
      return;
    }
    if (column.isPinned()) {
      return;
    }
    if (!this.visibleCols.isColDisplayed(column)) {
      return;
    }
    const newHorizontalScroll = this.getPositionedHorizontalScroll(column, position);
    frameworkOverrides.wrapIncoming(() => {
      var _a4;
      if (newHorizontalScroll !== null) {
        this.centerRowsCtrl.setCenterViewportScrollLeft(newHorizontalScroll);
      }
      this.centerRowsCtrl.onHorizontalViewportChanged();
      (_a4 = this.animationFrameSvc) == null ? void 0 : _a4.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(column, position) {
    const { columnBeforeStart, columnAfterEnd } = this.isColumnOutsideViewport(column);
    const viewportTooSmallForColumn = this.centerRowsCtrl.getCenterWidth() < column.getActualWidth();
    const viewportWidth = this.centerRowsCtrl.getCenterWidth();
    const isRtl = this.enableRtl;
    let alignColToStart = (isRtl ? columnBeforeStart : columnAfterEnd) || viewportTooSmallForColumn;
    let alignColToEnd = isRtl ? columnAfterEnd : columnBeforeStart;
    if (position !== "auto") {
      alignColToStart = position === "start";
      alignColToEnd = position === "end";
    }
    const isMiddle = position === "middle";
    if (alignColToStart || alignColToEnd || isMiddle) {
      const { colLeft, colMiddle, colRight } = this.getColumnBounds(column);
      if (isMiddle) {
        return colMiddle - viewportWidth / 2;
      }
      if (alignColToStart) {
        return isRtl ? colRight : colLeft;
      }
      return isRtl ? colLeft - viewportWidth : colRight - viewportWidth;
    }
    return null;
  }
  isColumnOutsideViewport(column) {
    const { start: viewportStart, end: viewportEnd } = this.getViewportBounds();
    const { colLeft, colRight } = this.getColumnBounds(column);
    const isRtl = this.enableRtl;
    const columnBeforeStart = isRtl ? viewportStart > colRight : viewportEnd < colRight;
    const columnAfterEnd = isRtl ? viewportEnd < colLeft : viewportStart > colLeft;
    return { columnBeforeStart, columnAfterEnd };
  }
  getColumnBounds(column) {
    const isRtl = this.enableRtl;
    const bodyWidth = this.visibleCols.bodyWidth;
    const colWidth = column.getActualWidth();
    const colLeft = column.getLeft();
    const multiplier = isRtl ? -1 : 1;
    const colLeftPixel = isRtl ? bodyWidth - colLeft : colLeft;
    const colRightPixel = colLeftPixel + colWidth * multiplier;
    const colMidPixel = colLeftPixel + colWidth / 2 * multiplier;
    return { colLeft: colLeftPixel, colMiddle: colMidPixel, colRight: colRightPixel };
  }
  getViewportBounds() {
    const viewportWidth = this.centerRowsCtrl.getCenterWidth();
    const scrollPosition = this.centerRowsCtrl.getCenterViewportScrollLeft();
    const viewportStartPixel = scrollPosition;
    const viewportEndPixel = viewportWidth + scrollPosition;
    return { start: viewportStartPixel, end: viewportEndPixel, width: viewportWidth };
  }
};
var CenterWidthFeature = class extends BeanStub {
  constructor(callback, addSpacer = false) {
    super();
    this.callback = callback;
    this.addSpacer = addSpacer;
  }
  postConstruct() {
    const listener = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", listener);
    this.addManagedEventListeners({
      columnContainerWidthChanged: listener,
      displayedColumnsChanged: listener,
      leftPinnedWidthChanged: listener
    });
    if (this.addSpacer) {
      this.addManagedEventListeners({
        rightPinnedWidthChanged: listener,
        scrollVisibilityChanged: listener,
        scrollbarWidthChanged: listener
      });
    }
    this.setWidth();
  }
  setWidth() {
    const printLayout = _isDomLayout(this.gos, "print");
    const { visibleCols, scrollVisibleSvc } = this.beans;
    const centerWidth = visibleCols.bodyWidth;
    const leftWidth = visibleCols.getColsLeftWidth();
    const rightWidth = visibleCols.getDisplayedColumnsRightWidth();
    let totalWidth;
    if (printLayout) {
      totalWidth = centerWidth + leftWidth + rightWidth;
    } else {
      totalWidth = centerWidth;
      if (this.addSpacer) {
        const relevantWidth = this.gos.get("enableRtl") ? leftWidth : rightWidth;
        if (relevantWidth === 0 && scrollVisibleSvc.verticalScrollShowing) {
          totalWidth += scrollVisibleSvc.getScrollbarWidth();
        }
      }
    }
    this.callback(totalWidth);
  }
};
var ViewportSizeFeature = class extends BeanStub {
  constructor(centerContainerCtrl) {
    super();
    this.centerContainerCtrl = centerContainerCtrl;
  }
  wireBeans(beans) {
    this.scrollVisibleSvc = beans.scrollVisibleSvc;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCtrl = p.gridBodyCtrl;
      this.listenForResize();
    });
    this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) });
    this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const { beans, centerContainerCtrl, gridBodyCtrl } = this;
    const listener = () => {
      _requestAnimationFrame(beans, () => {
        this.onCenterViewportResized();
      });
    };
    centerContainerCtrl.registerViewportResizeListener(listener);
    gridBodyCtrl.registerBodyViewportResizeListener(listener);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    this.scrollVisibleSvc.updateScrollGap();
    if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
      const { pinnedCols, colFlex } = this.beans;
      pinnedCols == null ? void 0 : pinnedCols.keepPinnedColumnsNarrowerThanViewport();
      this.checkViewportAndScrolls();
      const newWidth = this.centerContainerCtrl.getCenterWidth();
      if (newWidth !== this.centerWidth) {
        this.centerWidth = newWidth;
        colFlex == null ? void 0 : colFlex.refreshFlexedColumns({
          viewportWidth: this.centerWidth,
          updateBodyWidths: true,
          fireResizedEvent: true
        });
      }
    } else {
      this.bodyHeight = 0;
    }
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService();
    this.checkBodyHeight();
    this.onHorizontalViewportChanged();
    this.gridBodyCtrl.scrollFeature.checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const eBodyViewport = this.gridBodyCtrl.eBodyViewport;
    const bodyHeight = _getInnerHeight(eBodyViewport);
    if (this.bodyHeight !== bodyHeight) {
      this.bodyHeight = bodyHeight;
      this.eventSvc.dispatchEvent({
        type: "bodyHeightChanged"
      });
    }
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl();
    setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    if (!this.isAlive()) {
      return;
    }
    const params = {
      horizontalScrollShowing: this.centerContainerCtrl.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleSvc.setScrollsVisible(params);
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const scrollWidth = this.centerContainerCtrl.getCenterWidth();
    const scrollPosition = this.centerContainerCtrl.getViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(scrollWidth, scrollPosition);
  }
};
function _suppressCellMouseEvent(gos, column, node, event) {
  var _a4;
  const suppressMouseEventHandling = (_a4 = column.getColDef().cellRendererParams) == null ? void 0 : _a4.suppressMouseEventHandling;
  return suppressMouseEvent(gos, column, node, event, suppressMouseEventHandling);
}
function _suppressFullWidthMouseEvent(gos, cellRendererParams, node, event) {
  const suppressMouseEventHandling = cellRendererParams == null ? void 0 : cellRendererParams.suppressMouseEventHandling;
  return suppressMouseEvent(gos, void 0, node, event, suppressMouseEventHandling);
}
function suppressMouseEvent(gos, column, node, event, suppressMouseEventHandling) {
  if (!suppressMouseEventHandling) {
    return false;
  }
  return suppressMouseEventHandling(
    _addGridCommonParams(gos, {
      column,
      node,
      event
    })
  );
}
function _getCtrlForEventTarget(gos, eventTarget, type) {
  let sourceElement = eventTarget;
  while (sourceElement) {
    const renderedComp = _getDomData(gos, sourceElement, type);
    if (renderedComp) {
      return renderedComp;
    }
    sourceElement = sourceElement.parentElement;
  }
  return null;
}
var DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
function _getCellCtrlForEventTarget(gos, eventTarget) {
  return _getCtrlForEventTarget(gos, eventTarget, DOM_DATA_KEY_CELL_CTRL);
}
var DOM_DATA_KEY_ROW_CTRL = "renderedRow";
function _getRowCtrlForEventTarget(gos, eventTarget) {
  return _getCtrlForEventTarget(gos, eventTarget, DOM_DATA_KEY_ROW_CTRL);
}
function _isUserSuppressingKeyboardEvent(gos, keyboardEvent, rowNode, column, editing) {
  const colDefFunc = column ? column.getColDef().suppressKeyboardEvent : void 0;
  if (!colDefFunc) {
    return false;
  }
  const params = _addGridCommonParams(gos, {
    event: keyboardEvent,
    editing,
    column,
    node: rowNode,
    data: rowNode.data,
    colDef: column.getColDef()
  });
  if (colDefFunc) {
    const colDefFuncResult = colDefFunc(params);
    if (colDefFuncResult) {
      return true;
    }
  }
  return false;
}
function _selectAllCells(beans) {
  var _a4, _b2, _c;
  const { pinnedRowModel, rowModel } = beans;
  const [isEmptyPinnedTop, isEmptyPinnedBottom] = [
    (_a4 = pinnedRowModel == null ? void 0 : pinnedRowModel.isEmpty("top")) != null ? _a4 : true,
    (_b2 = pinnedRowModel == null ? void 0 : pinnedRowModel.isEmpty("bottom")) != null ? _b2 : true
  ];
  const floatingStart = isEmptyPinnedTop ? null : "top";
  let floatingEnd;
  let rowEnd;
  if (isEmptyPinnedBottom) {
    floatingEnd = null;
    rowEnd = rowModel.getRowCount() - 1;
  } else {
    floatingEnd = "bottom";
    rowEnd = (_c = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedBottomRowCount()) != null ? _c : 0 - 1;
  }
  const { visibleCols, rangeSvc } = beans;
  const allDisplayedColumns = visibleCols.allCols;
  if (!rangeSvc || !(allDisplayedColumns == null ? void 0 : allDisplayedColumns.length)) {
    return;
  }
  rangeSvc.setCellRange({
    rowStartIndex: 0,
    rowStartPinned: floatingStart,
    rowEndIndex: rowEnd,
    rowEndPinned: floatingEnd
  });
}
var A_KEYCODE = 65;
var C_KEYCODE = 67;
var V_KEYCODE = 86;
var D_KEYCODE = 68;
var Z_KEYCODE = 90;
var Y_KEYCODE = 89;
function _normaliseQwertyAzerty(keyboardEvent) {
  const { keyCode } = keyboardEvent;
  let code;
  switch (keyCode) {
    case A_KEYCODE:
      code = KeyCode.A;
      break;
    case C_KEYCODE:
      code = KeyCode.C;
      break;
    case V_KEYCODE:
      code = KeyCode.V;
      break;
    case D_KEYCODE:
      code = KeyCode.D;
      break;
    case Z_KEYCODE:
      code = KeyCode.Z;
      break;
    case Y_KEYCODE:
      code = KeyCode.Y;
      break;
    default:
      code = keyboardEvent.code;
  }
  return code;
}
var RowContainerEventsFeature = class extends BeanStub {
  constructor(element) {
    super();
    this.element = element;
  }
  postConstruct() {
    var _a4;
    this.addKeyboardListeners();
    this.addMouseListeners();
    (_a4 = this.beans.touchSvc) == null ? void 0 : _a4.mockRowContextMenu(this);
    this.editSvc = this.beans.editSvc;
  }
  addKeyboardListeners() {
    const eventName = "keydown";
    const listener = this.processKeyboardEvent.bind(this, eventName);
    this.addManagedElementListeners(this.element, { [eventName]: listener });
  }
  addMouseListeners() {
    const mouseDownEvent = _isEventSupported("touchstart") ? "touchstart" : "mousedown";
    const eventNames = ["dblclick", "contextmenu", "mouseover", "mouseout", "click", mouseDownEvent];
    eventNames.forEach((eventName) => {
      const listener = this.processMouseEvent.bind(this, eventName);
      this.addManagedElementListeners(this.element, { [eventName]: listener });
    });
  }
  processMouseEvent(eventName, mouseEvent) {
    var _a4;
    if (!_isEventFromThisInstance(this.beans, mouseEvent) || _isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(mouseEvent.target);
    if (eventName === "contextmenu") {
      if (cellCtrl == null ? void 0 : cellCtrl.column) {
        cellCtrl.dispatchCellContextMenuEvent(mouseEvent);
      }
      (_a4 = this.beans.contextMenuSvc) == null ? void 0 : _a4.handleContextMenuMouseEvent(mouseEvent, void 0, rowCtrl, cellCtrl);
    } else {
      if (cellCtrl) {
        cellCtrl.onMouseEvent(eventName, mouseEvent);
      }
      if (rowCtrl) {
        rowCtrl.onMouseEvent(eventName, mouseEvent);
      }
    }
  }
  getControlsForEventTarget(target) {
    const { gos } = this;
    return {
      cellCtrl: _getCellCtrlForEventTarget(gos, target),
      rowCtrl: _getRowCtrlForEventTarget(gos, target)
    };
  }
  processKeyboardEvent(eventName, keyboardEvent) {
    const { cellCtrl, rowCtrl } = this.getControlsForEventTarget(keyboardEvent.target);
    if (keyboardEvent.defaultPrevented) {
      return;
    }
    if (cellCtrl) {
      this.processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent);
    } else if (rowCtrl == null ? void 0 : rowCtrl.isFullWidth()) {
      this.processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent);
    }
  }
  processCellKeyboardEvent(cellCtrl, eventName, keyboardEvent) {
    var _a4, _b2, _c;
    const editing = (_b2 = (_a4 = this.editSvc) == null ? void 0 : _a4.isEditing(cellCtrl, { withOpenEditor: true })) != null ? _b2 : false;
    const gridProcessingAllowed = !_isUserSuppressingKeyboardEvent(
      this.gos,
      keyboardEvent,
      cellCtrl.rowNode,
      cellCtrl.column,
      editing
    );
    if (gridProcessingAllowed) {
      if (eventName === "keydown") {
        const wasScrollKey = !editing && ((_c = this.beans.navigation) == null ? void 0 : _c.handlePageScrollingKey(keyboardEvent));
        if (!wasScrollKey) {
          cellCtrl.onKeyDown(keyboardEvent);
        }
        this.doGridOperations(keyboardEvent, editing);
        if (_isEventFromPrintableCharacter(keyboardEvent)) {
          cellCtrl.processCharacter(keyboardEvent);
        }
      }
    }
    if (eventName === "keydown") {
      this.eventSvc.dispatchEvent(cellCtrl.createEvent(keyboardEvent, "cellKeyDown"));
    }
  }
  processFullWidthRowKeyboardEvent(rowCtrl, eventName, keyboardEvent) {
    const { rowNode } = rowCtrl;
    const { focusSvc, navigation } = this.beans;
    const focusedCell = focusSvc.getFocusedCell();
    const column = focusedCell == null ? void 0 : focusedCell.column;
    const gridProcessingAllowed = !_isUserSuppressingKeyboardEvent(this.gos, keyboardEvent, rowNode, column, false);
    if (gridProcessingAllowed) {
      const key = keyboardEvent.key;
      if (eventName === "keydown") {
        switch (key) {
          case KeyCode.PAGE_HOME:
          case KeyCode.PAGE_END:
          case KeyCode.PAGE_UP:
          case KeyCode.PAGE_DOWN:
            navigation == null ? void 0 : navigation.handlePageScrollingKey(keyboardEvent, true);
            break;
          case KeyCode.LEFT:
          case KeyCode.RIGHT:
            if (!this.gos.get("embedFullWidthRows")) {
              break;
            }
          case KeyCode.UP:
          case KeyCode.DOWN:
            rowCtrl.onKeyboardNavigate(keyboardEvent);
            break;
          case KeyCode.TAB:
            rowCtrl.onTabKeyDown(keyboardEvent);
            break;
          default:
        }
      }
    }
    if (eventName === "keydown") {
      this.eventSvc.dispatchEvent(rowCtrl.createRowEvent("cellKeyDown", keyboardEvent));
    }
  }
  doGridOperations(keyboardEvent, editing) {
    if (!keyboardEvent.ctrlKey && !keyboardEvent.metaKey) {
      return;
    }
    if (editing) {
      return;
    }
    if (!_isEventFromThisInstance(this.beans, keyboardEvent)) {
      return;
    }
    const keyCode = _normaliseQwertyAzerty(keyboardEvent);
    const { clipboardSvc, undoRedo } = this.beans;
    if (keyCode === KeyCode.A) {
      return this.onCtrlAndA(keyboardEvent);
    }
    if (keyCode === KeyCode.C) {
      return this.onCtrlAndC(clipboardSvc, keyboardEvent);
    }
    if (keyCode === KeyCode.D) {
      return this.onCtrlAndD(clipboardSvc, keyboardEvent);
    }
    if (keyCode === KeyCode.V) {
      return this.onCtrlAndV(clipboardSvc, keyboardEvent);
    }
    if (keyCode === KeyCode.X) {
      return this.onCtrlAndX(clipboardSvc, keyboardEvent);
    }
    if (keyCode === KeyCode.Y) {
      return this.onCtrlAndY(undoRedo);
    }
    if (keyCode === KeyCode.Z) {
      return this.onCtrlAndZ(undoRedo, keyboardEvent);
    }
  }
  onCtrlAndA(event) {
    const {
      beans: { rowModel, rangeSvc, selectionSvc },
      gos
    } = this;
    if (rangeSvc && _isCellSelectionEnabled(gos) && rowModel.isRowsToRender()) {
      _selectAllCells(this.beans);
    } else if (selectionSvc) {
      selectionSvc == null ? void 0 : selectionSvc.selectAllRowNodes({ source: "keyboardSelectAll", selectAll: _getSelectAll(gos) });
    }
    event.preventDefault();
  }
  onCtrlAndC(clipboardSvc, event) {
    var _a4;
    if (!clipboardSvc || this.gos.get("enableCellTextSelection")) {
      return;
    }
    const { cellCtrl } = this.getControlsForEventTarget(event.target);
    if ((_a4 = this.editSvc) == null ? void 0 : _a4.isEditing(cellCtrl, { withOpenEditor: true })) {
      return;
    }
    event.preventDefault();
    clipboardSvc.copyToClipboard();
  }
  onCtrlAndX(clipboardSvc, event) {
    var _a4;
    if (!clipboardSvc || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard")) {
      return;
    }
    const { cellCtrl } = this.getControlsForEventTarget(event.target);
    if ((_a4 = this.editSvc) == null ? void 0 : _a4.isEditing(cellCtrl, { withOpenEditor: true })) {
      return;
    }
    event.preventDefault();
    clipboardSvc.cutToClipboard(void 0, "ui");
  }
  onCtrlAndV(clipboardSvc, event) {
    var _a4;
    const { cellCtrl } = this.getControlsForEventTarget(event.target);
    if ((_a4 = this.editSvc) == null ? void 0 : _a4.isEditing(cellCtrl, { withOpenEditor: true })) {
      return;
    }
    if (clipboardSvc && !this.gos.get("suppressClipboardPaste")) {
      clipboardSvc.pasteFromClipboard();
    }
  }
  onCtrlAndD(clipboardSvc, event) {
    if (clipboardSvc && !this.gos.get("suppressClipboardPaste")) {
      clipboardSvc.copyRangeDown();
    }
    event.preventDefault();
  }
  onCtrlAndZ(undoRedo, event) {
    if (!this.gos.get("undoRedoCellEditing") || !undoRedo) {
      return;
    }
    event.preventDefault();
    if (event.shiftKey) {
      undoRedo.redo("ui");
    } else {
      undoRedo.undo("ui");
    }
  }
  onCtrlAndY(undoRedo) {
    undoRedo == null ? void 0 : undoRedo.redo("ui");
  }
};
var SetHeightFeature = class extends BeanStub {
  constructor(eContainer, eViewport) {
    super();
    this.eContainer = eContainer;
    this.eViewport = eViewport;
  }
  postConstruct() {
    this.addManagedEventListeners({
      rowContainerHeightChanged: this.onHeightChanged.bind(this, this.beans.rowContainerHeight)
    });
  }
  onHeightChanged(maxDivHeightScaler) {
    const height = maxDivHeightScaler.uiContainerHeight;
    const heightString = height != null ? `${height}px` : ``;
    this.eContainer.style.height = heightString;
    if (this.eViewport) {
      this.eViewport.style.height = heightString;
    }
  }
};
var getTopRowCtrls = (r) => r.topRowCtrls;
var getStickyTopRowCtrls = (r) => r.getStickyTopRowCtrls();
var getStickyBottomRowCtrls = (r) => r.getStickyBottomRowCtrls();
var getBottomRowCtrls = (r) => r.bottomRowCtrls;
var getCentreRowCtrls = (r) => r.allRowCtrls;
var getSpannedTopRowCtrls = (r) => r.getCtrls("top");
var getSpannedCenterRowCtrls = (r) => r.getCtrls("center");
var getSpannedBottomRowCtrls = (r) => r.getCtrls("bottom");
var ContainerCssClasses = {
  center: {
    type: "center",
    name: "center-cols",
    getRowCtrls: getCentreRowCtrls,
    getSpannedRowCtrls: getSpannedCenterRowCtrls
  },
  left: {
    type: "left",
    name: "pinned-left-cols",
    pinnedType: "left",
    getRowCtrls: getCentreRowCtrls,
    getSpannedRowCtrls: getSpannedCenterRowCtrls
  },
  right: {
    type: "right",
    name: "pinned-right-cols",
    pinnedType: "right",
    getRowCtrls: getCentreRowCtrls,
    getSpannedRowCtrls: getSpannedCenterRowCtrls
  },
  fullWidth: {
    type: "fullWidth",
    name: "full-width",
    fullWidth: true,
    getRowCtrls: getCentreRowCtrls
  },
  topCenter: {
    type: "center",
    name: "floating-top",
    getRowCtrls: getTopRowCtrls,
    getSpannedRowCtrls: getSpannedTopRowCtrls
  },
  topLeft: {
    type: "left",
    name: "pinned-left-floating",
    container: "ag-pinned-left-floating-top",
    pinnedType: "left",
    getRowCtrls: getTopRowCtrls,
    getSpannedRowCtrls: getSpannedTopRowCtrls
  },
  topRight: {
    type: "right",
    name: "pinned-right-floating",
    container: "ag-pinned-right-floating-top",
    pinnedType: "right",
    getRowCtrls: getTopRowCtrls,
    getSpannedRowCtrls: getSpannedTopRowCtrls
  },
  topFullWidth: {
    type: "fullWidth",
    name: "floating-top-full-width",
    fullWidth: true,
    getRowCtrls: getTopRowCtrls
  },
  stickyTopCenter: {
    type: "center",
    name: "sticky-top",
    getRowCtrls: getStickyTopRowCtrls
  },
  stickyTopLeft: {
    type: "left",
    name: "pinned-left-sticky-top",
    container: "ag-pinned-left-sticky-top",
    pinnedType: "left",
    getRowCtrls: getStickyTopRowCtrls
  },
  stickyTopRight: {
    type: "right",
    name: "pinned-right-sticky-top",
    container: "ag-pinned-right-sticky-top",
    pinnedType: "right",
    getRowCtrls: getStickyTopRowCtrls
  },
  stickyTopFullWidth: {
    type: "fullWidth",
    name: "sticky-top-full-width",
    fullWidth: true,
    getRowCtrls: getStickyTopRowCtrls
  },
  stickyBottomCenter: {
    type: "center",
    name: "sticky-bottom",
    getRowCtrls: getStickyBottomRowCtrls
  },
  stickyBottomLeft: {
    type: "left",
    name: "pinned-left-sticky-bottom",
    container: "ag-pinned-left-sticky-bottom",
    pinnedType: "left",
    getRowCtrls: getStickyBottomRowCtrls
  },
  stickyBottomRight: {
    type: "right",
    name: "pinned-right-sticky-bottom",
    container: "ag-pinned-right-sticky-bottom",
    pinnedType: "right",
    getRowCtrls: getStickyBottomRowCtrls
  },
  stickyBottomFullWidth: {
    type: "fullWidth",
    name: "sticky-bottom-full-width",
    fullWidth: true,
    getRowCtrls: getStickyBottomRowCtrls
  },
  bottomCenter: {
    type: "center",
    name: "floating-bottom",
    getRowCtrls: getBottomRowCtrls,
    getSpannedRowCtrls: getSpannedBottomRowCtrls
  },
  bottomLeft: {
    type: "left",
    name: "pinned-left-floating-bottom",
    container: "ag-pinned-left-floating-bottom",
    pinnedType: "left",
    getRowCtrls: getBottomRowCtrls,
    getSpannedRowCtrls: getSpannedBottomRowCtrls
  },
  bottomRight: {
    type: "right",
    name: "pinned-right-floating-bottom",
    container: "ag-pinned-right-floating-bottom",
    pinnedType: "right",
    getRowCtrls: getBottomRowCtrls,
    getSpannedRowCtrls: getSpannedBottomRowCtrls
  },
  bottomFullWidth: {
    type: "fullWidth",
    name: "floating-bottom-full-width",
    fullWidth: true,
    getRowCtrls: getBottomRowCtrls
  }
};
function _getRowViewportClass(name) {
  const options = _getRowContainerOptions(name);
  return `ag-${options.name}-viewport`;
}
function _getRowContainerClass(name) {
  var _a4;
  const options = _getRowContainerOptions(name);
  return (_a4 = options.container) != null ? _a4 : `ag-${options.name}-container`;
}
function _getRowSpanContainerClass(name) {
  const options = _getRowContainerOptions(name);
  return `ag-${options.name}-spanned-cells-container`;
}
function _getRowContainerOptions(name) {
  return ContainerCssClasses[name];
}
var allTopNoFW = ["topCenter", "topLeft", "topRight"];
var allBottomNoFW = ["bottomCenter", "bottomLeft", "bottomRight"];
var allMiddleNoFW = ["center", "left", "right"];
var allMiddle = ["center", "left", "right", "fullWidth"];
var allCenter = ["stickyTopCenter", "stickyBottomCenter", "center", "topCenter", "bottomCenter"];
var allLeft = ["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"];
var allRight = ["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"];
var allStickyTopNoFW = ["stickyTopCenter", "stickyTopLeft", "stickyTopRight"];
var allStickyBottomNoFW = ["stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"];
var allStickyContainers = [
  ...allStickyTopNoFW,
  "stickyTopFullWidth",
  ...allStickyBottomNoFW,
  "stickyBottomFullWidth"
];
var allNoFW = [
  ...allTopNoFW,
  ...allBottomNoFW,
  ...allMiddleNoFW,
  ...allStickyTopNoFW,
  ...allStickyBottomNoFW
];
var RowContainerCtrl = class extends BeanStub {
  constructor(name) {
    super();
    this.name = name;
    this.visible = true;
    this.EMPTY_CTRLS = [];
    this.options = _getRowContainerOptions(name);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl");
    this.forContainers(["center"], () => {
      this.viewportSizeFeature = this.createManagedBean(new ViewportSizeFeature(this));
      this.addManagedEventListeners({
        stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this)
      });
    });
  }
  onStickyTopOffsetChanged(event) {
    this.comp.setOffsetTop(`${event.offset}px`);
  }
  registerWithCtrlsService() {
    if (this.options.fullWidth)
      return;
    this.beans.ctrlsSvc.register(this.name, this);
  }
  forContainers(names, callback) {
    if (names.indexOf(this.name) >= 0) {
      callback();
    }
  }
  setComp(view, eContainer, eSpannedContainer, eViewport) {
    var _a4;
    this.comp = view;
    this.eContainer = eContainer;
    this.eSpannedContainer = eSpannedContainer;
    this.eViewport = eViewport;
    this.createManagedBean(new RowContainerEventsFeature((_a4 = this.eViewport) != null ? _a4 : this.eContainer));
    this.addPreventScrollWhileDragging();
    this.listenOnDomOrder();
    const { pinnedCols, rangeSvc } = this.beans;
    const pinnedWidthChanged = () => this.onPinnedWidthChanged();
    this.forContainers(allLeft, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        pinnedCols == null ? void 0 : pinnedCols.createPinnedWidthFeature(true, this.eContainer, this.eSpannedContainer)
      );
      this.addManagedEventListeners({ leftPinnedWidthChanged: pinnedWidthChanged });
    });
    this.forContainers(allRight, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        pinnedCols == null ? void 0 : pinnedCols.createPinnedWidthFeature(false, this.eContainer, this.eSpannedContainer)
      );
      this.addManagedEventListeners({ rightPinnedWidthChanged: pinnedWidthChanged });
    });
    this.forContainers(
      allMiddle,
      () => this.createManagedBean(
        new SetHeightFeature(this.eContainer, this.name === "center" ? eViewport : void 0)
      )
    );
    if (rangeSvc) {
      this.forContainers(
        allNoFW,
        () => this.createManagedBean(rangeSvc.createDragListenerFeature(this.eContainer))
      );
    }
    this.forContainers(
      allCenter,
      () => this.createManagedBean(new CenterWidthFeature((width) => this.comp.setContainerWidth(`${width}px`)))
    );
    this.visible = this.isContainerVisible();
    this.addListeners();
    this.registerWithCtrlsService();
  }
  onScrollCallback(fn) {
    this.addManagedElementListeners(this.eViewport, { scroll: fn });
  }
  addListeners() {
    const { spannedRowRenderer, gos } = this.beans;
    const onDisplayedColumnsChanged = this.onDisplayedColumnsChanged.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: onDisplayedColumnsChanged,
      displayedColumnsWidthChanged: onDisplayedColumnsChanged,
      displayedRowsChanged: (params) => this.onDisplayedRowsChanged(params.afterScroll)
    });
    onDisplayedColumnsChanged();
    this.onDisplayedRowsChanged();
    if (spannedRowRenderer && this.options.getSpannedRowCtrls && gos.get("enableCellSpan")) {
      this.addManagedListeners(spannedRowRenderer, {
        spannedRowsUpdated: () => {
          const spannedCtrls = this.options.getSpannedRowCtrls(spannedRowRenderer);
          if (!spannedCtrls) {
            return;
          }
          this.comp.setSpannedRowCtrls(spannedCtrls, false);
        }
      });
    }
  }
  listenOnDomOrder() {
    const isStickContainer = allStickyContainers.indexOf(this.name) >= 0;
    if (isStickContainer) {
      this.comp.setDomOrder(true);
      return;
    }
    const listener = () => {
      const isEnsureDomOrder = this.gos.get("ensureDomOrder");
      const isPrintLayout = _isDomLayout(this.gos, "print");
      this.comp.setDomOrder(isEnsureDomOrder || isPrintLayout);
    };
    this.addManagedPropertyListener("domLayout", listener);
    listener();
  }
  onDisplayedColumnsChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const { dragSvc } = this.beans;
    if (!dragSvc) {
      return;
    }
    const preventScroll = (e) => {
      if (dragSvc.dragging) {
        if (e.cancelable) {
          e.preventDefault();
        }
      }
    };
    this.eContainer.addEventListener("touchmove", preventScroll, { passive: false });
    this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", preventScroll));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged(afterScroll = false) {
    const scrollWidth = this.getCenterWidth();
    const scrollPosition = this.getCenterViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(scrollWidth, scrollPosition, afterScroll);
  }
  hasHorizontalScrollGap() {
    return this.eContainer.clientWidth - this.eViewport.clientWidth < 0;
  }
  hasVerticalScrollGap() {
    return this.eContainer.clientHeight - this.eViewport.clientHeight < 0;
  }
  getCenterWidth() {
    return _getInnerWidth(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return _getScrollLeft(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(listener) {
    const unsubscribeFromResize = _observeResize(this.beans, this.eViewport, listener);
    this.addDestroyFunc(() => unsubscribeFromResize());
  }
  isViewportInTheDOMTree() {
    return _isInDOM(this.eViewport);
  }
  getViewportScrollLeft() {
    return _getScrollLeft(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    const isAlwaysShowHorizontalScroll = this.gos.get("alwaysShowHorizontalScroll");
    return isAlwaysShowHorizontalScroll || _isHorizontalScrollShowing(this.eViewport);
  }
  setHorizontalScroll(offset) {
    this.comp.setHorizontalScroll(offset);
  }
  getHScrollPosition() {
    const res = {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
    return res;
  }
  setCenterViewportScrollLeft(value) {
    _setScrollLeft(this.eViewport, value, this.enableRtl);
  }
  isContainerVisible() {
    const pinned = this.options.pinnedType != null;
    return !pinned || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const visible = this.isContainerVisible();
    if (this.visible != visible) {
      this.visible = visible;
      this.onDisplayedRowsChanged();
    }
  }
  onDisplayedRowsChanged(afterScroll = false) {
    const rows = this.options.getRowCtrls(this.beans.rowRenderer);
    if (!this.visible || rows.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const printLayout = _isDomLayout(this.gos, "print");
    const embedFullWidthRows = this.gos.get("embedFullWidthRows");
    const embedFW = embedFullWidthRows || printLayout;
    const rowsThisContainer = rows.filter((rowCtrl) => {
      const fullWidthRow = rowCtrl.isFullWidth();
      const match = this.options.fullWidth ? !embedFW && fullWidthRow : embedFW || !fullWidthRow;
      return match;
    });
    this.comp.setRowCtrls({ rowCtrls: rowsThisContainer, useFlushSync: afterScroll });
  }
};
var CSS_CLASS_FORCE_VERTICAL_SCROLL = "ag-force-vertical-scroll";
var CSS_CLASS_CELL_SELECTABLE = "ag-selectable";
var CSS_CLASS_COLUMN_MOVING = "ag-column-moving";
var GridBodyCtrl = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.stickyTopHeight = 0;
    this.stickyBottomHeight = 0;
  }
  wireBeans(beans) {
    this.ctrlsSvc = beans.ctrlsSvc;
    this.colModel = beans.colModel;
    this.scrollVisibleSvc = beans.scrollVisibleSvc;
    this.pinnedRowModel = beans.pinnedRowModel;
    this.filterManager = beans.filterManager;
    this.rowGroupColsSvc = beans.rowGroupColsSvc;
  }
  setComp(comp, eGridBody, eBodyViewport, eTop, eBottom, eStickyTop, eStickyBottom) {
    var _a4, _b2;
    this.comp = comp;
    this.eGridBody = eGridBody;
    this.eBodyViewport = eBodyViewport;
    this.eTop = eTop;
    this.eBottom = eBottom;
    this.eStickyTop = eStickyTop;
    this.eStickyBottom = eStickyBottom;
    this.eCenterColsViewport = eBodyViewport.querySelector(`.${_getRowViewportClass("center")}`);
    this.eFullWidthContainer = eBodyViewport.querySelector(`.${_getRowContainerClass("fullWidth")}`);
    this.eStickyTopFullWidthContainer = eStickyTop.querySelector(
      `.${_getRowContainerClass("stickyTopFullWidth")}`
    );
    this.eStickyBottomFullWidthContainer = eStickyBottom.querySelector(
      `.${_getRowContainerClass("stickyBottomFullWidth")}`
    );
    this.setCellTextSelection(this.gos.get("enableCellTextSelection"));
    this.addManagedPropertyListener(
      "enableCellTextSelection",
      (props) => this.setCellTextSelection(props.currentValue)
    );
    this.createManagedBean(new LayoutFeature(this.comp));
    this.scrollFeature = this.createManagedBean(new GridBodyScrollFeature(eBodyViewport));
    (_a4 = this.beans.rowDragSvc) == null ? void 0 : _a4.setupRowDrag(eBodyViewport, this);
    this.setupRowAnimationCssClass();
    this.addEventListeners();
    this.addFocusListeners([eTop, eBodyViewport, eBottom, eStickyTop, eStickyBottom]);
    this.setGridRootRole();
    this.onGridColumnsChanged();
    this.addBodyViewportListener();
    this.setFloatingHeights();
    this.disableBrowserDragging();
    this.addStopEditingWhenGridLosesFocus();
    this.updateScrollingClasses();
    (_b2 = this.filterManager) == null ? void 0 : _b2.setupAdvFilterHeaderComp(eTop);
    this.ctrlsSvc.register("gridBodyCtrl", this);
  }
  addEventListeners() {
    const setFloatingHeights = this.setFloatingHeights.bind(this);
    const setGridRootRole = this.setGridRootRole.bind(this);
    const toggleRowResizeStyle = this.toggleRowResizeStyles.bind(this);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
      scrollGapChanged: this.updateScrollingClasses.bind(this),
      pinnedRowDataChanged: setFloatingHeights,
      pinnedHeightChanged: setFloatingHeights,
      pinnedRowsChanged: setFloatingHeights,
      headerHeightChanged: this.setStickyTopOffsetTop.bind(this),
      columnRowGroupChanged: setGridRootRole,
      columnPivotChanged: setGridRootRole,
      rowResizeStarted: toggleRowResizeStyle,
      rowResizeEnded: toggleRowResizeStyle
    });
    this.addManagedPropertyListener("treeData", setGridRootRole);
  }
  toggleRowResizeStyles(params) {
    const isResizingRow = params.type === "rowResizeStarted";
    this.eBodyViewport.classList.toggle("ag-prevent-animation", isResizingRow);
  }
  onGridColumnsChanged() {
    const columns = this.beans.colModel.getCols();
    this.comp.setColumnCount(columns.length);
  }
  onScrollVisibilityChanged() {
    const { scrollVisibleSvc } = this;
    const visible = scrollVisibleSvc.verticalScrollShowing;
    this.setVerticalScrollPaddingVisible(visible);
    this.setStickyWidth(visible);
    this.setStickyBottomOffsetBottom();
    const scrollbarWidth = visible ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
    const pad = _isInvisibleScrollbar() ? 16 : 0;
    const width = `calc(100% + ${scrollbarWidth + pad}px)`;
    _requestAnimationFrame(this.beans, () => this.comp.setBodyViewportWidth(width));
    this.updateScrollingClasses();
  }
  setGridRootRole() {
    const { rowGroupColsSvc, colModel } = this;
    let isTreeGrid = this.gos.get("treeData");
    if (!isTreeGrid) {
      const isPivotActive = colModel.isPivotMode();
      const rowGroupColumnLen = !rowGroupColsSvc ? 0 : rowGroupColsSvc.columns.length;
      const columnsNeededForGrouping = isPivotActive ? 2 : 1;
      isTreeGrid = rowGroupColumnLen >= columnsNeededForGrouping;
    }
    this.comp.setGridRootRole(isTreeGrid ? "treegrid" : "grid");
  }
  addFocusListeners(elements) {
    elements.forEach((element) => {
      this.addManagedElementListeners(element, {
        focusin: (e) => {
          const { target } = e;
          const isFocusedElementNested = _isElementChildOfClass(target, "ag-root", element);
          element.classList.toggle("ag-has-focus", !isFocusedElementNested);
        },
        focusout: (e) => {
          const { target, relatedTarget } = e;
          const gridContainRelatedTarget = element.contains(relatedTarget);
          const isNestedRelatedTarget = _isElementChildOfClass(
            relatedTarget,
            "ag-root",
            element
          );
          const isNestedTarget = _isElementChildOfClass(target, "ag-root", element);
          if (isNestedTarget) {
            return;
          }
          if (!gridContainRelatedTarget || isNestedRelatedTarget) {
            element.classList.remove("ag-has-focus");
          }
        }
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(moving) {
    this.comp.setColumnMovingCss(CSS_CLASS_COLUMN_MOVING, moving);
  }
  setCellTextSelection(selectable = false) {
    this.comp.setCellSelectableCss(CSS_CLASS_CELL_SELECTABLE, selectable);
  }
  updateScrollingClasses() {
    const {
      eGridBody: { classList },
      scrollVisibleSvc
    } = this;
    classList.toggle("ag-body-vertical-content-no-gap", !scrollVisibleSvc.verticalScrollGap);
    classList.toggle("ag-body-horizontal-content-no-gap", !scrollVisibleSvc.horizontalScrollGap);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedElementListeners(this.eGridBody, {
      dragstart: (event) => {
        if (event.target instanceof HTMLImageElement) {
          event.preventDefault();
          return false;
        }
      }
    });
  }
  addStopEditingWhenGridLosesFocus() {
    var _a4;
    (_a4 = this.beans.editSvc) == null ? void 0 : _a4.addStopEditingWhenGridLosesFocus([
      this.eBodyViewport,
      this.eBottom,
      this.eTop,
      this.eStickyTop,
      this.eStickyBottom
    ]);
  }
  updateRowCount() {
    var _a4, _b2, _c, _d;
    const headerCount = ((_b2 = (_a4 = this.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : _a4.getRowCount()) != null ? _b2 : 0) + ((_d = (_c = this.filterManager) == null ? void 0 : _c.getHeaderRowCount()) != null ? _d : 0);
    const { rowModel } = this.beans;
    const rowCount = rowModel.isLastRowIndexKnown() ? rowModel.getRowCount() : -1;
    const total = rowCount === -1 ? -1 : headerCount + rowCount;
    this.comp.setRowCount(total);
  }
  registerBodyViewportResizeListener(listener) {
    this.comp.registerBodyViewportResizeListener(listener);
  }
  setVerticalScrollPaddingVisible(visible) {
    const overflowY = visible ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(overflowY);
  }
  isVerticalScrollShowing() {
    const show = this.gos.get("alwaysShowVerticalScroll");
    const cssClass = show ? CSS_CLASS_FORCE_VERTICAL_SCROLL : null;
    const allowVerticalScroll = _isDomLayout(this.gos, "normal");
    this.comp.setAlwaysVerticalScrollClass(cssClass, show);
    return show || allowVerticalScroll && _isVerticalScrollShowing(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    const { rowContainerHeight, environment } = this.beans;
    let initialSizeMeasurementComplete = environment.sizesMeasured;
    const updateAnimationClass = () => {
      const animateRows = initialSizeMeasurementComplete && _isAnimateRows(this.gos) && !rowContainerHeight.stretching;
      const animateRowsCssClass = animateRows ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(animateRowsCssClass, animateRows);
    };
    updateAnimationClass();
    this.addManagedEventListeners({ heightScaleChanged: updateAnimationClass });
    this.addManagedPropertyListener("animateRows", updateAnimationClass);
    this.addManagedEventListeners({
      gridStylesChanged: () => {
        if (!initialSizeMeasurementComplete && environment.sizesMeasured) {
          initialSizeMeasurementComplete = true;
          updateAnimationClass();
        }
      }
    });
  }
  addBodyViewportListener() {
    const {
      eBodyViewport,
      eStickyTop,
      eStickyBottom,
      eTop,
      eBottom,
      beans: { popupSvc, touchSvc }
    } = this;
    const listener = this.onBodyViewportContextMenu.bind(this);
    this.addManagedElementListeners(eBodyViewport, { contextmenu: listener });
    touchSvc == null ? void 0 : touchSvc.mockBodyContextMenu(this, listener);
    this.addManagedElementListeners(eBodyViewport, {
      wheel: this.onBodyViewportWheel.bind(this, popupSvc)
    });
    const onStickyWheel = this.onStickyWheel.bind(this);
    for (const container of [eStickyTop, eStickyBottom, eTop, eBottom]) {
      this.addManagedElementListeners(container, { wheel: onStickyWheel });
    }
    const onHorizontalWheel = this.onHorizontalWheel.bind(this);
    for (const container of ["left", "right", "topLeft", "topRight", "bottomLeft", "bottomRight"]) {
      this.addManagedElementListeners(this.ctrlsSvc.get(container).eContainer, {
        wheel: onHorizontalWheel
      });
    }
    this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    this.addManagedElementListeners(this.eFullWidthContainer, {
      wheel: (e) => this.onFullWidthContainerWheel(e)
    });
  }
  onFullWidthContainerWheel(e) {
    const { deltaX, deltaY, shiftKey } = e;
    const isHorizontalScroll = shiftKey || Math.abs(deltaX) > Math.abs(deltaY);
    if (isHorizontalScroll && _isEventFromThisInstance(this.beans, e)) {
      this.scrollGridBodyToMatchEvent(e);
    }
  }
  onStickyWheel(e) {
    const { deltaY } = e;
    const scrolled = this.scrollVertically(deltaY);
    if (scrolled > 0) {
      e.preventDefault();
    }
  }
  onHorizontalWheel(e) {
    const { deltaX, deltaY, shiftKey } = e;
    const isHorizontalScroll = shiftKey || Math.abs(deltaX) > Math.abs(deltaY);
    if (!isHorizontalScroll) {
      return;
    }
    this.scrollGridBodyToMatchEvent(e);
  }
  scrollGridBodyToMatchEvent(e) {
    const { deltaX, deltaY } = e;
    e.preventDefault();
    this.eCenterColsViewport.scrollBy({ left: deltaX || deltaY });
  }
  onBodyViewportContextMenu(mouseEvent, touch, touchEvent) {
    var _a4;
    if (!mouseEvent && !touchEvent) {
      return;
    }
    if (this.gos.get("preventDefaultOnContextMenu")) {
      const event = mouseEvent || touchEvent;
      event.preventDefault();
    }
    const { target } = mouseEvent || touch;
    if (target === this.eBodyViewport || target === this.ctrlsSvc.get("center").eViewport) {
      (_a4 = this.beans.contextMenuSvc) == null ? void 0 : _a4.showContextMenu({
        mouseEvent,
        touchEvent,
        value: null,
        anchorToElement: this.eGridBody,
        source: "ui"
      });
    }
  }
  onBodyViewportWheel(popupSvc, e) {
    if (!this.gos.get("suppressScrollWhenPopupsAreOpen")) {
      return;
    }
    if (popupSvc == null ? void 0 : popupSvc.hasAnchoredPopup()) {
      e.preventDefault();
    }
  }
  // called by rowDragFeature
  scrollVertically(pixels) {
    const oldScrollPosition = this.eBodyViewport.scrollTop;
    this.scrollFeature.setVerticalScrollPosition(oldScrollPosition + pixels);
    return this.eBodyViewport.scrollTop - oldScrollPosition;
  }
  setFloatingHeights() {
    const {
      pinnedRowModel,
      beans: { environment }
    } = this;
    const floatingTopHeight = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedTopTotalHeight();
    const floatingBottomHeight = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedBottomTotalHeight();
    const pinnedBorderWidth = environment.getPinnedRowBorderWidth();
    const rowBorderWidth = environment.getRowBorderWidth();
    const additionalHeight = pinnedBorderWidth - rowBorderWidth;
    const normalisedFloatingTopHeight = !floatingTopHeight ? 0 : additionalHeight + floatingTopHeight;
    const normalisedFloatingBottomHeight = !floatingBottomHeight ? 0 : additionalHeight + floatingBottomHeight;
    this.comp.setTopHeight(normalisedFloatingTopHeight);
    this.comp.setBottomHeight(normalisedFloatingBottomHeight);
    this.comp.setTopInvisible(normalisedFloatingTopHeight <= 0);
    this.comp.setBottomInvisible(normalisedFloatingBottomHeight <= 0);
    this.setStickyTopOffsetTop();
    this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(height = 0) {
    this.comp.setStickyTopHeight(`${height}px`);
    this.stickyTopHeight = height;
  }
  setStickyBottomHeight(height = 0) {
    this.comp.setStickyBottomHeight(`${height}px`);
    this.stickyBottomHeight = height;
  }
  setStickyWidth(vScrollVisible) {
    if (!vScrollVisible) {
      this.comp.setStickyTopWidth("100%");
      this.comp.setStickyBottomWidth("100%");
    } else {
      const scrollbarWidth = this.scrollVisibleSvc.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${scrollbarWidth}px)`);
      this.comp.setStickyBottomWidth(`calc(100% - ${scrollbarWidth}px)`);
    }
  }
  setStickyTopOffsetTop() {
    var _a4, _b2, _c, _d;
    const headerCtrl = this.ctrlsSvc.get("gridHeaderCtrl");
    const headerHeight = headerCtrl.headerHeight + ((_b2 = (_a4 = this.filterManager) == null ? void 0 : _a4.getHeaderHeight()) != null ? _b2 : 0);
    const pinnedTopHeight = (_d = (_c = this.pinnedRowModel) == null ? void 0 : _c.getPinnedTopTotalHeight()) != null ? _d : 0;
    let height = 0;
    if (headerHeight > 0) {
      height += headerHeight;
    }
    if (pinnedTopHeight > 0) {
      height += pinnedTopHeight;
    }
    if (height > 0) {
      height += 1;
    }
    this.comp.setStickyTopTop(`${height}px`);
  }
  setStickyBottomOffsetBottom() {
    var _a4;
    const { pinnedRowModel, scrollVisibleSvc, comp } = this;
    const pinnedBottomHeight = (_a4 = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedBottomTotalHeight()) != null ? _a4 : 0;
    const hScrollShowing = scrollVisibleSvc.horizontalScrollShowing;
    const scrollbarWidth = hScrollShowing ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
    const height = pinnedBottomHeight + scrollbarWidth;
    comp.setStickyBottomBottom(`${height}px`);
  }
};
function _getCellPositionForEvent(gos, event) {
  var _a4, _b2;
  return (_b2 = (_a4 = _getCellCtrlForEventTarget(gos, event.target)) == null ? void 0 : _a4.getFocusedCellPosition()) != null ? _b2 : null;
}
var AbstractFakeScrollComp = class extends Component {
  constructor(template, direction) {
    super();
    this.direction = direction;
    this.eViewport = RefPlaceholder;
    this.eContainer = RefPlaceholder;
    this.hideTimeout = 0;
    this.setTemplate(template);
  }
  postConstruct() {
    this.addManagedEventListeners({
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this)
    });
    this.onScrollVisibilityChanged();
    this.toggleCss("ag-apple-scrollbar", _isMacOsUserAgent() || _isIOSUserAgent());
  }
  destroy() {
    super.destroy();
    window.clearTimeout(this.hideTimeout);
  }
  initialiseInvisibleScrollbar() {
    if (this.invisibleScrollbar !== void 0) {
      return;
    }
    this.invisibleScrollbar = _isInvisibleScrollbar();
    if (this.invisibleScrollbar) {
      this.hideAndShowInvisibleScrollAsNeeded();
      this.addActiveListenerToggles();
    }
  }
  addActiveListenerToggles() {
    const eGui = this.getGui();
    const onActivate = () => this.toggleCss("ag-scrollbar-active", true);
    const onDeactivate = () => this.toggleCss("ag-scrollbar-active", false);
    this.addManagedListeners(eGui, {
      mouseenter: onActivate,
      mousedown: onActivate,
      touchstart: onActivate,
      mouseleave: onDeactivate,
      touchend: onDeactivate
    });
  }
  onScrollVisibilityChanged() {
    if (this.invisibleScrollbar === void 0) {
      this.initialiseInvisibleScrollbar();
    }
    _requestAnimationFrame(this.beans, () => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedEventListeners({
      bodyScroll: (params) => {
        if (params.direction === this.direction) {
          if (this.hideTimeout) {
            window.clearTimeout(this.hideTimeout);
            this.hideTimeout = 0;
          }
          this.toggleCss("ag-scrollbar-scrolling", true);
        }
      },
      bodyScrollEnd: () => {
        this.hideTimeout = window.setTimeout(() => {
          this.toggleCss("ag-scrollbar-scrolling", false);
          this.hideTimeout = 0;
        }, 400);
      }
    });
  }
  attemptSettingScrollPosition(value) {
    const viewport = this.eViewport;
    _waitUntil(
      this,
      () => _isVisible(viewport),
      () => this.setScrollPosition(value),
      100
    );
  }
  onScrollCallback(fn) {
    this.addManagedElementListeners(this.eViewport, { scroll: fn });
  }
};
var FakeHScrollElement = {
  tag: "div",
  cls: "ag-body-horizontal-scroll",
  attrs: { "aria-hidden": "true" },
  children: [
    { tag: "div", ref: "eLeftSpacer", cls: "ag-horizontal-left-spacer" },
    {
      tag: "div",
      ref: "eViewport",
      cls: "ag-body-horizontal-scroll-viewport",
      children: [{ tag: "div", ref: "eContainer", cls: "ag-body-horizontal-scroll-container" }]
    },
    { tag: "div", ref: "eRightSpacer", cls: "ag-horizontal-right-spacer" }
  ]
};
var FakeHScrollComp = class extends AbstractFakeScrollComp {
  constructor() {
    super(FakeHScrollElement, "horizontal");
    this.eLeftSpacer = RefPlaceholder;
    this.eRightSpacer = RefPlaceholder;
    this.setScrollVisibleDebounce = 0;
  }
  wireBeans(beans) {
    this.visibleCols = beans.visibleCols;
    this.scrollVisibleSvc = beans.scrollVisibleSvc;
  }
  postConstruct() {
    super.postConstruct();
    const spacerWidthsListener = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: spacerWidthsListener,
      displayedColumnsWidthChanged: spacerWidthsListener,
      pinnedRowDataChanged: this.refreshCompBottom.bind(this)
    });
    this.addManagedPropertyListener("domLayout", spacerWidthsListener);
    this.beans.ctrlsSvc.register("fakeHScrollComp", this);
    this.createManagedBean(new CenterWidthFeature((width) => this.eContainer.style.width = `${width}px`));
    this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  destroy() {
    window.clearTimeout(this.setScrollVisibleDebounce);
    super.destroy();
  }
  initialiseInvisibleScrollbar() {
    if (this.invisibleScrollbar !== void 0) {
      return;
    }
    this.enableRtl = this.gos.get("enableRtl");
    super.initialiseInvisibleScrollbar();
    if (this.invisibleScrollbar) {
      this.refreshCompBottom();
    }
  }
  refreshCompBottom() {
    var _a4, _b2;
    if (!this.invisibleScrollbar) {
      return;
    }
    const bottomPinnedHeight = (_b2 = (_a4 = this.beans.pinnedRowModel) == null ? void 0 : _a4.getPinnedBottomTotalHeight()) != null ? _b2 : 0;
    this.getGui().style.bottom = `${bottomPinnedHeight}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged();
    this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const vScrollShowing = this.scrollVisibleSvc.verticalScrollShowing;
    let rightSpacing = this.visibleCols.getDisplayedColumnsRightWidth();
    const scrollOnRight = !this.enableRtl && vScrollShowing;
    const scrollbarWidth = this.scrollVisibleSvc.getScrollbarWidth();
    if (scrollOnRight) {
      rightSpacing += scrollbarWidth;
    }
    _setFixedWidth(this.eRightSpacer, rightSpacing);
    this.eRightSpacer.classList.toggle("ag-scroller-corner", rightSpacing <= scrollbarWidth);
    let leftSpacing = this.visibleCols.getColsLeftWidth();
    const scrollOnLeft = this.enableRtl && vScrollShowing;
    if (scrollOnLeft) {
      leftSpacing += scrollbarWidth;
    }
    _setFixedWidth(this.eLeftSpacer, leftSpacing);
    this.eLeftSpacer.classList.toggle("ag-scroller-corner", leftSpacing <= scrollbarWidth);
  }
  setScrollVisible() {
    const hScrollShowing = this.scrollVisibleSvc.horizontalScrollShowing;
    const invisibleScrollbar2 = this.invisibleScrollbar;
    const isSuppressHorizontalScroll = this.gos.get("suppressHorizontalScroll");
    const scrollbarWidth = hScrollShowing ? this.scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
    const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
    const scrollContainerSize = !isSuppressHorizontalScroll ? adjustedScrollbarWidth : 0;
    const apply = () => {
      this.setScrollVisibleDebounce = 0;
      this.toggleCss("ag-scrollbar-invisible", invisibleScrollbar2);
      _setFixedHeight(this.getGui(), scrollContainerSize);
      _setFixedHeight(this.eViewport, scrollContainerSize);
      _setFixedHeight(this.eContainer, scrollContainerSize);
      if (!scrollContainerSize) {
        this.eContainer.style.setProperty("min-height", "1px");
      }
      this.setVisible(hScrollShowing, { skipAriaHidden: true });
    };
    window.clearTimeout(this.setScrollVisibleDebounce);
    if (!hScrollShowing) {
      apply();
    } else {
      this.setScrollVisibleDebounce = window.setTimeout(apply, 100);
    }
  }
  getScrollPosition() {
    return _getScrollLeft(this.eViewport, this.enableRtl);
  }
  setScrollPosition(value) {
    if (!_isVisible(this.eViewport)) {
      this.attemptSettingScrollPosition(value);
    }
    _setScrollLeft(this.eViewport, value, this.enableRtl);
  }
};
var FakeHScrollSelector = {
  selector: "AG-FAKE-HORIZONTAL-SCROLL",
  component: FakeHScrollComp
};
var FakeVScrollElement = {
  tag: "div",
  cls: "ag-body-vertical-scroll",
  attrs: { "aria-hidden": "true" },
  children: [
    {
      tag: "div",
      ref: "eViewport",
      cls: "ag-body-vertical-scroll-viewport",
      children: [{ tag: "div", ref: "eContainer", cls: "ag-body-vertical-scroll-container" }]
    }
  ]
};
var FakeVScrollComp = class extends AbstractFakeScrollComp {
  constructor() {
    super(FakeVScrollElement, "vertical");
  }
  postConstruct() {
    super.postConstruct();
    this.createManagedBean(new SetHeightFeature(this.eContainer));
    const { ctrlsSvc } = this.beans;
    ctrlsSvc.register("fakeVScrollComp", this);
    this.addManagedEventListeners({
      rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this, ctrlsSvc)
    });
  }
  setScrollVisible() {
    const { scrollVisibleSvc } = this.beans;
    const vScrollShowing = scrollVisibleSvc.verticalScrollShowing;
    const invisibleScrollbar2 = this.invisibleScrollbar;
    const scrollbarWidth = vScrollShowing ? scrollVisibleSvc.getScrollbarWidth() || 0 : 0;
    const adjustedScrollbarWidth = scrollbarWidth === 0 && invisibleScrollbar2 ? 16 : scrollbarWidth;
    this.toggleCss("ag-scrollbar-invisible", invisibleScrollbar2);
    _setFixedWidth(this.getGui(), adjustedScrollbarWidth);
    _setFixedWidth(this.eViewport, adjustedScrollbarWidth);
    _setFixedWidth(this.eContainer, adjustedScrollbarWidth);
    this.setDisplayed(vScrollShowing, { skipAriaHidden: true });
  }
  onRowContainerHeightChanged(ctrlsSvc) {
    const gridBodyCtrl = ctrlsSvc.getGridBodyCtrl();
    const gridBodyViewportEl = gridBodyCtrl.eBodyViewport;
    const eViewportScrollTop = this.getScrollPosition();
    const gridBodyViewportScrollTop = gridBodyViewportEl.scrollTop;
    if (eViewportScrollTop != gridBodyViewportScrollTop) {
      this.setScrollPosition(gridBodyViewportScrollTop, true);
    }
  }
  getScrollPosition() {
    return this.eViewport.scrollTop;
  }
  setScrollPosition(value, force) {
    if (!force && !_isVisible(this.eViewport)) {
      this.attemptSettingScrollPosition(value);
    }
    this.eViewport.scrollTop = value;
  }
};
var FakeVScrollSelector = {
  selector: "AG-FAKE-VERTICAL-SCROLL",
  component: FakeVScrollComp
};
var CSS_FIRST_COLUMN = "ag-column-first";
var CSS_LAST_COLUMN = "ag-column-last";
function _getHeaderClassesFromColDef(abstractColDef, gos, column, columnGroup) {
  if (_missing(abstractColDef)) {
    return [];
  }
  return getColumnClassesFromCollDef(abstractColDef.headerClass, abstractColDef, gos, column, columnGroup);
}
function refreshFirstAndLastStyles(comp, column, presentedColsService) {
  comp.toggleCss(CSS_FIRST_COLUMN, presentedColsService.isColAtEdge(column, "first"));
  comp.toggleCss(CSS_LAST_COLUMN, presentedColsService.isColAtEdge(column, "last"));
}
function getClassParams(abstractColDef, gos, column, columnGroup) {
  return _addGridCommonParams(gos, {
    // bad naming, as colDef here can be a group or a column,
    // however most people won't appreciate the difference,
    // so keeping it as colDef to avoid confusion.
    colDef: abstractColDef,
    column,
    columnGroup
  });
}
function getColumnClassesFromCollDef(classesOrFunc, abstractColDef, gos, column, columnGroup) {
  if (_missing(classesOrFunc)) {
    return [];
  }
  let classToUse;
  if (typeof classesOrFunc === "function") {
    const params = getClassParams(abstractColDef, gos, column, columnGroup);
    classToUse = classesOrFunc(params);
  } else {
    classToUse = classesOrFunc;
  }
  if (typeof classToUse === "string") {
    return [classToUse];
  }
  if (Array.isArray(classToUse)) {
    return [...classToUse];
  }
  return [];
}
function _isHeaderFocusSuppressed(beans) {
  var _a4;
  return beans.gos.get("suppressHeaderFocus") || !!((_a4 = beans.overlays) == null ? void 0 : _a4.isExclusive());
}
function _isCellFocusSuppressed(beans) {
  var _a4;
  return beans.gos.get("suppressCellFocus") || !!((_a4 = beans.overlays) == null ? void 0 : _a4.isExclusive());
}
function _focusNextGridCoreContainer(beans, backwards, forceOut = false) {
  const gridCtrl = beans.ctrlsSvc.get("gridCtrl");
  if (!forceOut && gridCtrl.focusNextInnerContainer(backwards)) {
    return true;
  }
  if (forceOut || !backwards && !gridCtrl.isDetailGrid()) {
    gridCtrl.forceFocusOutOfContainer(backwards);
  }
  return false;
}
function getFocusHeaderRowCount(beans) {
  var _a4, _b2;
  return (_b2 = (_a4 = beans.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : _a4.getRowCount()) != null ? _b2 : 0;
}
function getGroupRowsHeight(beans) {
  const heights = [];
  const headerRowContainerCtrls = beans.ctrlsSvc.getHeaderRowContainerCtrls();
  for (const headerRowContainerCtrl of headerRowContainerCtrls) {
    if (!headerRowContainerCtrl) {
      continue;
    }
    const groupRowCount = headerRowContainerCtrl.getGroupRowCount() || 0;
    for (let i = 0; i < groupRowCount; i++) {
      const headerRowCtrl = headerRowContainerCtrl.getGroupRowCtrlAtIndex(i);
      const currentHeightAtPos = heights[i];
      if (headerRowCtrl) {
        const newHeight = getColumnGroupHeaderRowHeight(beans, headerRowCtrl);
        if (currentHeightAtPos == null || newHeight > currentHeightAtPos) {
          heights[i] = newHeight;
        }
      }
    }
  }
  return heights;
}
function getColumnGroupHeaderRowHeight(beans, headerRowCtrl) {
  const defaultHeight = beans.colModel.isPivotMode() ? getPivotGroupHeaderHeight(beans) : getGroupHeaderHeight(beans);
  let maxDisplayedHeight = defaultHeight;
  const headerRowCellCtrls = headerRowCtrl.getHeaderCellCtrls();
  for (const headerCellCtrl of headerRowCellCtrls) {
    const { column } = headerCellCtrl;
    const height = column.getAutoHeaderHeight();
    if (height != null && height > maxDisplayedHeight && column.isAutoHeaderHeight()) {
      maxDisplayedHeight = height;
    }
  }
  return maxDisplayedHeight;
}
function getColumnHeaderRowHeight(beans) {
  const defaultHeight = beans.colModel.isPivotMode() ? getPivotHeaderHeight(beans) : getHeaderHeight(beans);
  let maxDisplayedHeight = defaultHeight;
  beans.colModel.forAllCols((col) => {
    const height = col.getAutoHeaderHeight();
    if (height != null && height > maxDisplayedHeight && col.isAutoHeaderHeight()) {
      maxDisplayedHeight = height;
    }
  });
  return maxDisplayedHeight;
}
function getHeaderHeight(beans) {
  var _a4;
  return (_a4 = beans.gos.get("headerHeight")) != null ? _a4 : beans.environment.getDefaultHeaderHeight();
}
function getFloatingFiltersHeight(beans) {
  var _a4;
  return (_a4 = beans.gos.get("floatingFiltersHeight")) != null ? _a4 : getHeaderHeight(beans);
}
function getGroupHeaderHeight(beans) {
  var _a4;
  return (_a4 = beans.gos.get("groupHeaderHeight")) != null ? _a4 : getHeaderHeight(beans);
}
function getPivotHeaderHeight(beans) {
  var _a4;
  return (_a4 = beans.gos.get("pivotHeaderHeight")) != null ? _a4 : getHeaderHeight(beans);
}
function getPivotGroupHeaderHeight(beans) {
  var _a4;
  return (_a4 = beans.gos.get("pivotGroupHeaderHeight")) != null ? _a4 : getGroupHeaderHeight(beans);
}
var GridHeaderCtrl = class extends BeanStub {
  setComp(comp, eGui, eFocusableElement) {
    this.comp = comp;
    this.eGui = eGui;
    const { beans } = this;
    const { headerNavigation, touchSvc, ctrlsSvc } = beans;
    if (headerNavigation) {
      this.createManagedBean(
        new ManagedFocusFeature(eFocusableElement, {
          onTabKeyDown: this.onTabKeyDown.bind(this),
          handleKeyDown: this.handleKeyDown.bind(this),
          onFocusOut: this.onFocusOut.bind(this)
        })
      );
    }
    this.addManagedEventListeners({
      columnPivotModeChanged: this.onPivotModeChanged.bind(this, beans),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this, beans)
    });
    this.onPivotModeChanged(beans);
    this.setupHeaderHeight();
    const listener = this.onHeaderContextMenu.bind(this);
    this.addManagedElementListeners(this.eGui, { contextmenu: listener });
    touchSvc == null ? void 0 : touchSvc.mockHeaderContextMenu(this, listener);
    ctrlsSvc.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const listener = this.setHeaderHeight.bind(this);
    listener();
    this.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      listener
    );
    this.addManagedEventListeners({
      headerRowsChanged: listener,
      columnHeaderHeightChanged: listener,
      // add this to the animation frame to avoid a feedback loop
      columnGroupHeaderHeightChanged: () => _requestAnimationFrame(this.beans, () => listener()),
      gridStylesChanged: listener,
      advancedFilterEnabledChanged: listener
    });
  }
  setHeaderHeight() {
    var _a4;
    const { beans } = this;
    let totalHeaderHeight = 0;
    const groupHeight = getGroupRowsHeight(beans).reduce((prev, curr) => prev + curr, 0);
    const headerHeight = getColumnHeaderRowHeight(beans);
    if ((_a4 = beans.filterManager) == null ? void 0 : _a4.hasFloatingFilters()) {
      totalHeaderHeight += getFloatingFiltersHeight(beans);
    }
    totalHeaderHeight += groupHeight;
    totalHeaderHeight += headerHeight;
    if (this.headerHeight === totalHeaderHeight) {
      return;
    }
    this.headerHeight = totalHeaderHeight;
    const px = `${totalHeaderHeight + 1}px`;
    this.comp.setHeightAndMinHeight(px);
    this.eventSvc.dispatchEvent({
      type: "headerHeightChanged"
    });
  }
  onPivotModeChanged(beans) {
    const pivotMode = beans.colModel.isPivotMode();
    this.comp.toggleCss("ag-pivot-on", pivotMode);
    this.comp.toggleCss("ag-pivot-off", !pivotMode);
  }
  onDisplayedColumnsChanged(beans) {
    const columns = beans.visibleCols.allCols;
    const shouldAllowOverflow = columns.some((col) => col.isSpanHeaderHeight());
    this.comp.toggleCss("ag-header-allow-overflow", shouldAllowOverflow);
  }
  onTabKeyDown(e) {
    const isRtl = this.gos.get("enableRtl");
    const backwards = e.shiftKey;
    const direction = backwards !== isRtl ? "LEFT" : "RIGHT";
    const { beans } = this;
    const { headerNavigation, focusSvc } = beans;
    if (headerNavigation.navigateHorizontally(direction, true, e) || !backwards && focusSvc.focusOverlay(false) || _focusNextGridCoreContainer(beans, backwards, true)) {
      e.preventDefault();
    }
  }
  handleKeyDown(e) {
    let direction = null;
    const { headerNavigation } = this.beans;
    switch (e.key) {
      case KeyCode.LEFT:
        direction = "LEFT";
      case KeyCode.RIGHT: {
        if (!_exists(direction)) {
          direction = "RIGHT";
        }
        if (headerNavigation.navigateHorizontally(direction, false, e)) {
          e.preventDefault();
        }
        break;
      }
      case KeyCode.UP:
        direction = "UP";
      case KeyCode.DOWN: {
        if (!_exists(direction)) {
          direction = "DOWN";
        }
        if (headerNavigation.navigateVertically(direction, e)) {
          e.preventDefault();
        }
        break;
      }
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget } = e;
    const { eGui, beans } = this;
    if (!relatedTarget && eGui.contains(_getActiveDomElement(beans))) {
      return;
    }
    if (!eGui.contains(relatedTarget)) {
      beans.focusSvc.focusedHeader = null;
    }
  }
  onHeaderContextMenu(mouseEvent, touch, touchEvent) {
    var _a4;
    const { menuSvc, ctrlsSvc } = this.beans;
    if (!mouseEvent && !touchEvent || !(menuSvc == null ? void 0 : menuSvc.isHeaderContextMenuEnabled())) {
      return;
    }
    const { target } = mouseEvent != null ? mouseEvent : touch;
    if (target === this.eGui || target === ((_a4 = ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : _a4.eViewport)) {
      menuSvc.showHeaderContextMenu(void 0, mouseEvent, touchEvent);
    }
  }
};
var AbstractHeaderCellComp = class extends Component {
  constructor(template, ctrl) {
    super(template);
    this.ctrl = ctrl;
  }
  getCtrl() {
    return this.ctrl;
  }
};
var HeaderCellElement = {
  tag: "div",
  cls: "ag-header-cell",
  role: "columnheader",
  children: [
    { tag: "div", ref: "eResize", cls: "ag-header-cell-resize", role: "presentation" },
    { tag: "div", ref: "eHeaderCompWrapper", cls: "ag-header-cell-comp-wrapper", role: "presentation" }
  ]
};
var HeaderCellComp = class extends AbstractHeaderCellComp {
  constructor(ctrl) {
    super(HeaderCellElement, ctrl);
    this.eResize = RefPlaceholder;
    this.eHeaderCompWrapper = RefPlaceholder;
    this.headerCompVersion = 0;
  }
  postConstruct() {
    const eGui = this.getGui();
    const refreshSelectAllGui = () => {
      const selectAllGui = this.ctrl.getSelectAllGui();
      if (selectAllGui) {
        this.eResize.insertAdjacentElement("afterend", selectAllGui);
        this.addDestroyFunc(() => selectAllGui.remove());
      }
    };
    const compProxy = {
      setWidth: (width) => eGui.style.width = width,
      toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
      setUserStyles: (styles) => _addStylesToElement(eGui, styles),
      setAriaSort: (sort) => sort ? _setAriaSort(eGui, sort) : _removeAriaSort(eGui),
      setUserCompDetails: (compDetails) => this.setUserCompDetails(compDetails),
      getUserCompInstance: () => this.headerComp,
      refreshSelectAllGui,
      removeSelectAllGui: () => {
        var _a4;
        return (_a4 = this.ctrl.getSelectAllGui()) == null ? void 0 : _a4.remove();
      }
    };
    this.ctrl.setComp(compProxy, this.getGui(), this.eResize, this.eHeaderCompWrapper, void 0);
    refreshSelectAllGui();
  }
  destroy() {
    this.destroyHeaderComp();
    super.destroy();
  }
  destroyHeaderComp() {
    if (this.headerComp) {
      this.eHeaderCompWrapper.removeChild(this.headerCompGui);
      this.headerComp = this.destroyBean(this.headerComp);
      this.headerCompGui = void 0;
    }
  }
  setUserCompDetails(compDetails) {
    this.headerCompVersion++;
    const versionCopy = this.headerCompVersion;
    compDetails.newAgStackInstance().then((comp) => this.afterCompCreated(versionCopy, comp));
  }
  afterCompCreated(version, headerComp) {
    if (version != this.headerCompVersion || !this.isAlive()) {
      this.destroyBean(headerComp);
      return;
    }
    this.destroyHeaderComp();
    this.headerComp = headerComp;
    this.headerCompGui = headerComp.getGui();
    this.eHeaderCompWrapper.appendChild(this.headerCompGui);
    this.ctrl.setDragSource(this.getGui());
  }
};
var HeaderGroupCellCompElement = {
  tag: "div",
  cls: "ag-header-group-cell",
  role: "columnheader",
  children: [
    { tag: "div", ref: "eHeaderCompWrapper", cls: "ag-header-cell-comp-wrapper", role: "presentation" },
    { tag: "div", ref: "eResize", cls: "ag-header-cell-resize", role: "presentation" }
  ]
};
var HeaderGroupCellComp = class extends AbstractHeaderCellComp {
  constructor(ctrl) {
    super(HeaderGroupCellCompElement, ctrl);
    this.eResize = RefPlaceholder;
    this.eHeaderCompWrapper = RefPlaceholder;
  }
  postConstruct() {
    const eGui = this.getGui();
    const setAttribute = (key, value) => value != void 0 ? eGui.setAttribute(key, value) : eGui.removeAttribute(key);
    const compProxy = {
      toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
      setUserStyles: (styles) => _addStylesToElement(eGui, styles),
      setHeaderWrapperHidden: (hidden) => {
        if (hidden) {
          this.eHeaderCompWrapper.style.setProperty("display", "none");
        } else {
          this.eHeaderCompWrapper.style.removeProperty("display");
        }
      },
      setHeaderWrapperMaxHeight: (value) => {
        if (value != null) {
          this.eHeaderCompWrapper.style.setProperty("max-height", `${value}px`);
        } else {
          this.eHeaderCompWrapper.style.removeProperty("max-height");
        }
        this.eHeaderCompWrapper.classList.toggle("ag-header-cell-comp-wrapper-limited-height", value != null);
      },
      setResizableDisplayed: (displayed) => _setDisplayed(this.eResize, displayed),
      setWidth: (width) => eGui.style.width = width,
      setAriaExpanded: (expanded) => setAttribute("aria-expanded", expanded),
      setUserCompDetails: (details) => this.setUserCompDetails(details),
      getUserCompInstance: () => this.headerGroupComp
    };
    this.ctrl.setComp(compProxy, eGui, this.eResize, this.eHeaderCompWrapper, void 0);
  }
  setUserCompDetails(details) {
    details.newAgStackInstance().then((comp) => this.afterHeaderCompCreated(comp));
  }
  afterHeaderCompCreated(headerGroupComp) {
    const destroyFunc = () => this.destroyBean(headerGroupComp);
    if (!this.isAlive()) {
      destroyFunc();
      return;
    }
    const eGui = this.getGui();
    const eHeaderGroupGui = headerGroupComp.getGui();
    this.eHeaderCompWrapper.appendChild(eHeaderGroupGui);
    this.addDestroyFunc(destroyFunc);
    this.headerGroupComp = headerGroupComp;
    this.ctrl.setDragSource(eGui);
  }
};
var HeaderFilterCellCompElement = {
  tag: "div",
  cls: "ag-header-cell ag-floating-filter",
  role: "gridcell",
  children: [
    { tag: "div", ref: "eFloatingFilterBody", role: "presentation" },
    {
      tag: "div",
      ref: "eButtonWrapper",
      cls: "ag-floating-filter-button ag-hidden",
      role: "presentation",
      children: [
        {
          tag: "button",
          ref: "eButtonShowMainFilter",
          cls: "ag-button ag-floating-filter-button-button",
          attrs: { type: "button", tabindex: "-1" }
        }
      ]
    }
  ]
};
var HeaderFilterCellComp = class extends AbstractHeaderCellComp {
  constructor(ctrl) {
    super(HeaderFilterCellCompElement, ctrl);
    this.eFloatingFilterBody = RefPlaceholder;
    this.eButtonWrapper = RefPlaceholder;
    this.eButtonShowMainFilter = RefPlaceholder;
  }
  postConstruct() {
    const eGui = this.getGui();
    const compProxy = {
      toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
      setUserStyles: (styles) => _addStylesToElement(eGui, styles),
      addOrRemoveBodyCssClass: (cssClassName, on) => this.eFloatingFilterBody.classList.toggle(cssClassName, on),
      setButtonWrapperDisplayed: (displayed) => _setDisplayed(this.eButtonWrapper, displayed),
      setCompDetails: (compDetails) => this.setCompDetails(compDetails),
      getFloatingFilterComp: () => this.compPromise,
      setWidth: (width) => eGui.style.width = width,
      setMenuIcon: (eIcon) => this.eButtonShowMainFilter.appendChild(eIcon)
    };
    this.ctrl.setComp(compProxy, eGui, this.eButtonShowMainFilter, this.eFloatingFilterBody, void 0);
  }
  setCompDetails(compDetails) {
    if (!compDetails) {
      this.destroyFloatingFilterComp();
      this.compPromise = null;
      return;
    }
    this.compPromise = compDetails.newAgStackInstance();
    this.compPromise.then((comp) => this.afterCompCreated(comp));
  }
  destroy() {
    this.destroyFloatingFilterComp();
    super.destroy();
  }
  destroyFloatingFilterComp() {
    if (this.floatingFilterComp) {
      this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui());
      this.floatingFilterComp = this.destroyBean(this.floatingFilterComp);
    }
  }
  afterCompCreated(comp) {
    if (!comp) {
      return;
    }
    if (!this.isAlive()) {
      this.destroyBean(comp);
      return;
    }
    this.destroyFloatingFilterComp();
    this.floatingFilterComp = comp;
    this.eFloatingFilterBody.appendChild(comp.getGui());
    if (comp.afterGuiAttached) {
      comp.afterGuiAttached();
    }
  }
};
var HeaderRowComp = class extends Component {
  constructor(ctrl) {
    super({ tag: "div", cls: ctrl.headerRowClass, role: "row" });
    this.ctrl = ctrl;
    this.headerComps = {};
  }
  postConstruct() {
    const eGui = this.getGui();
    eGui.setAttribute("tabindex", String(this.gos.get("tabIndex")));
    _setAriaRowIndex(this.getGui(), this.ctrl.getAriaRowIndex());
    const compProxy = {
      setHeight: (height) => this.getGui().style.height = height,
      setTop: (top) => this.getGui().style.top = top,
      setHeaderCtrls: (ctrls, forceOrder) => this.setHeaderCtrls(ctrls, forceOrder),
      setWidth: (width) => this.getGui().style.width = width,
      setRowIndex: (rowIndex) => _setAriaRowIndex(this.getGui(), rowIndex)
    };
    this.ctrl.setComp(compProxy, void 0);
  }
  destroy() {
    this.setHeaderCtrls([], false);
    super.destroy();
  }
  setHeaderCtrls(ctrls, forceOrder) {
    if (!this.isAlive()) {
      return;
    }
    const oldComps = this.headerComps;
    this.headerComps = {};
    ctrls.forEach((ctrl) => {
      const id = ctrl.instanceId;
      let comp = oldComps[id];
      delete oldComps[id];
      if (comp == null) {
        comp = this.createHeaderComp(ctrl);
        this.getGui().appendChild(comp.getGui());
      }
      this.headerComps[id] = comp;
    });
    Object.values(oldComps).forEach((comp) => {
      this.getGui().removeChild(comp.getGui());
      this.destroyBean(comp);
    });
    if (forceOrder) {
      const comps = Object.values(this.headerComps);
      comps.sort(
        (a, b) => {
          const leftA = a.getCtrl().column.getLeft();
          const leftB = b.getCtrl().column.getLeft();
          return leftA - leftB;
        }
      );
      const elementsInOrder = comps.map((c) => c.getGui());
      _setDomChildOrder(this.getGui(), elementsInOrder);
    }
  }
  createHeaderComp(headerCtrl) {
    let result;
    switch (this.ctrl.type) {
      case "group":
        result = new HeaderGroupCellComp(headerCtrl);
        break;
      case "filter":
        result = new HeaderFilterCellComp(headerCtrl);
        break;
      default:
        result = new HeaderCellComp(headerCtrl);
        break;
    }
    this.createBean(result);
    result.setParentComponent(this);
    return result;
  }
};
var SetLeftFeature = class extends BeanStub {
  constructor(columnOrGroup, eCell, beans, colsSpanning) {
    super();
    this.columnOrGroup = columnOrGroup;
    this.eCell = eCell;
    this.colsSpanning = colsSpanning;
    this.columnOrGroup = columnOrGroup;
    this.ariaEl = eCell.querySelector("[role=columnheader]") || eCell;
    this.beans = beans;
  }
  setColsSpanning(colsSpanning) {
    this.colsSpanning = colsSpanning;
    this.onLeftChanged();
  }
  getColumnOrGroup() {
    const { beans, colsSpanning } = this;
    if (beans.gos.get("enableRtl") && colsSpanning) {
      return _last(colsSpanning);
    }
    return this.columnOrGroup;
  }
  postConstruct() {
    const onLeftChanged = this.onLeftChanged.bind(this);
    this.addManagedListeners(this.columnOrGroup, { leftChanged: onLeftChanged });
    this.setLeftFirstTime();
    this.addManagedEventListeners({ displayedColumnsWidthChanged: onLeftChanged });
    this.addManagedPropertyListener("domLayout", onLeftChanged);
  }
  setLeftFirstTime() {
    const { gos, colAnimation } = this.beans;
    const suppressMoveAnimation = gos.get("suppressColumnMoveAnimation");
    const oldLeftExists = _exists(this.columnOrGroup.getOldLeft());
    const animateColumnMove = (colAnimation == null ? void 0 : colAnimation.isActive()) && oldLeftExists && !suppressMoveAnimation;
    if (animateColumnMove) {
      this.animateInLeft();
    } else {
      this.onLeftChanged();
    }
  }
  animateInLeft() {
    const colOrGroup = this.getColumnOrGroup();
    const oldActualLeft = this.modifyLeftForPrintLayout(colOrGroup, colOrGroup.getOldLeft());
    const actualLeft = this.modifyLeftForPrintLayout(colOrGroup, colOrGroup.getLeft());
    this.setLeft(oldActualLeft);
    this.actualLeft = actualLeft;
    this.beans.colAnimation.executeNextVMTurn(() => {
      if (this.actualLeft === actualLeft) {
        this.setLeft(actualLeft);
      }
    });
  }
  onLeftChanged() {
    const colOrGroup = this.getColumnOrGroup();
    const left = colOrGroup.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(colOrGroup, left);
    this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(colOrGroup, leftPosition) {
    const { gos, visibleCols } = this.beans;
    const printLayout = _isDomLayout(gos, "print");
    if (!printLayout) {
      return leftPosition;
    }
    if (colOrGroup.getPinned() === "left") {
      return leftPosition;
    }
    const leftWidth = visibleCols.getColsLeftWidth();
    if (colOrGroup.getPinned() === "right") {
      const bodyWidth = visibleCols.bodyWidth;
      return leftWidth + bodyWidth + leftPosition;
    }
    return leftWidth + leftPosition;
  }
  setLeft(value) {
    if (_exists(value)) {
      this.eCell.style.left = `${value}px`;
    }
    if (isColumnGroup(this.columnOrGroup)) {
      const children = this.columnOrGroup.getLeafColumns();
      if (!children.length) {
        return;
      }
      if (children.length > 1) {
        _setAriaColSpan(this.ariaEl, children.length);
      }
    }
  }
};
var instanceIdSequence2 = 0;
var DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
var AbstractHeaderCellCtrl = class extends BeanStub {
  constructor(column, rowCtrl) {
    super();
    this.column = column;
    this.rowCtrl = rowCtrl;
    this.resizeToggleTimeout = 0;
    this.resizeMultiplier = 1;
    this.resizeFeature = null;
    this.lastFocusEvent = null;
    this.dragSource = null;
    this.reAttemptToFocus = false;
    this.instanceId = column.getUniqueId() + "-" + instanceIdSequence2++;
  }
  postConstruct() {
    const refreshTabIndex = this.refreshTabIndex.bind(this);
    this.addManagedPropertyListeners(["suppressHeaderFocus"], refreshTabIndex);
    this.addManagedEventListeners({
      overlayExclusiveChanged: refreshTabIndex
    });
  }
  setComp(comp, eGui, eResize, eHeaderCompWrapper, compBean) {
    var _a4;
    eGui.setAttribute("col-id", this.column.colIdSanitised);
    this.wireComp(comp, eGui, eResize, eHeaderCompWrapper, compBean);
    if (this.reAttemptToFocus) {
      this.reAttemptToFocus = false;
      this.focus((_a4 = this.lastFocusEvent) != null ? _a4 : void 0);
    }
  }
  shouldStopEventPropagation(event) {
    const { headerRowIndex, column } = this.beans.focusSvc.focusedHeader;
    const colDef = column.getDefinition();
    const colDefFunc = colDef && colDef.suppressHeaderKeyboardEvent;
    if (!_exists(colDefFunc)) {
      return false;
    }
    const params = _addGridCommonParams(this.gos, {
      colDef,
      column,
      headerRowIndex,
      event
    });
    return !!colDefFunc(params);
  }
  getWrapperHasFocus() {
    const activeEl = _getActiveDomElement(this.beans);
    return activeEl === this.eGui;
  }
  setGui(eGui, compBean) {
    this.eGui = eGui;
    this.addDomData(compBean);
    compBean.addManagedListeners(this.beans.eventSvc, {
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    });
    compBean.addManagedElementListeners(this.eGui, {
      focus: this.onGuiFocus.bind(this)
    });
    this.onDisplayedColumnsChanged();
    this.refreshTabIndex();
  }
  refreshHeaderStyles() {
    const colDef = this.column.getDefinition();
    if (!colDef) {
      return;
    }
    const { headerStyle } = colDef;
    let styles;
    if (typeof headerStyle === "function") {
      const cellStyleParams = this.getHeaderClassParams();
      styles = headerStyle(cellStyleParams);
    } else {
      styles = headerStyle;
    }
    if (styles) {
      this.comp.setUserStyles(styles);
    }
  }
  onGuiFocus() {
    this.eventSvc.dispatchEvent({
      type: "headerFocused",
      column: this.column
    });
  }
  setupAutoHeight(params) {
    const { wrapperElement, checkMeasuringCallback, compBean } = params;
    const { beans } = this;
    const measureHeight = (timesCalled) => {
      if (!this.isAlive() || !compBean.isAlive()) {
        return;
      }
      const { paddingTop, paddingBottom, borderBottomWidth, borderTopWidth } = _getElementSize(this.eGui);
      const extraHeight = paddingTop + paddingBottom + borderBottomWidth + borderTopWidth;
      const wrapperHeight = wrapperElement.offsetHeight;
      const autoHeight = wrapperHeight + extraHeight;
      if (timesCalled < 5) {
        const doc = _getDocument(beans);
        const notYetInDom = !doc || !doc.contains(wrapperElement);
        const possiblyNoContentYet = autoHeight == 0;
        if (notYetInDom || possiblyNoContentYet) {
          _batchCall(() => measureHeight(timesCalled + 1), "raf", beans);
          return;
        }
      }
      this.setColHeaderHeight(this.column, autoHeight);
    };
    let isMeasuring = false;
    let stopResizeObserver;
    const checkMeasuring = () => {
      const newValue = this.column.isAutoHeaderHeight();
      if (newValue && !isMeasuring) {
        startMeasuring();
      }
      if (!newValue && isMeasuring) {
        stopMeasuring();
      }
    };
    const startMeasuring = () => {
      isMeasuring = true;
      this.comp.toggleCss("ag-header-cell-auto-height", true);
      measureHeight(0);
      stopResizeObserver = _observeResize(this.beans, wrapperElement, () => measureHeight(0));
    };
    const stopMeasuring = () => {
      isMeasuring = false;
      if (stopResizeObserver) {
        stopResizeObserver();
      }
      this.comp.toggleCss("ag-header-cell-auto-height", false);
      stopResizeObserver = void 0;
    };
    checkMeasuring();
    compBean.addDestroyFunc(() => stopMeasuring());
    compBean.addManagedListeners(this.column, { widthChanged: () => isMeasuring && measureHeight(0) });
    compBean.addManagedEventListeners({
      sortChanged: () => {
        if (isMeasuring) {
          window.setTimeout(() => measureHeight(0));
        }
      }
    });
    if (checkMeasuringCallback) {
      checkMeasuringCallback(checkMeasuring);
    }
  }
  onDisplayedColumnsChanged() {
    const { comp, column, beans, eGui } = this;
    if (!comp || !column || !eGui) {
      return;
    }
    refreshFirstAndLastStyles(comp, column, beans.visibleCols);
    _setAriaColIndex(eGui, beans.visibleCols.getAriaColIndex(column));
  }
  addResizeAndMoveKeyboardListeners(compBean) {
    compBean.addManagedListeners(this.eGui, {
      keydown: this.onGuiKeyDown.bind(this),
      keyup: this.onGuiKeyUp.bind(this)
    });
  }
  refreshTabIndex() {
    const suppressHeaderFocus = _isHeaderFocusSuppressed(this.beans);
    if (this.eGui) {
      _addOrRemoveAttribute(this.eGui, "tabindex", suppressHeaderFocus ? null : "-1");
    }
  }
  onGuiKeyDown(e) {
    var _a4;
    const activeEl = _getActiveDomElement(this.beans);
    const isLeftOrRight = e.key === KeyCode.LEFT || e.key === KeyCode.RIGHT;
    if (this.isResizing) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
    if (
      // if elements within the header are focused, we don't process the event
      activeEl !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
      !e.shiftKey && !e.altKey
    ) {
      return;
    }
    if (this.isResizing || isLeftOrRight) {
      e.preventDefault();
      e.stopImmediatePropagation();
    }
    if (!isLeftOrRight) {
      return;
    }
    const isLeft = e.key === KeyCode.LEFT !== this.gos.get("enableRtl");
    const direction = isLeft ? "left" : "right";
    if (e.altKey) {
      this.isResizing = true;
      this.resizeMultiplier += 1;
      const diff = this.getViewportAdjustedResizeDiff(e);
      this.resizeHeader(diff, e.shiftKey);
      (_a4 = this.resizeFeature) == null ? void 0 : _a4.toggleColumnResizing(true);
    } else {
      this.moveHeader(direction);
    }
  }
  moveHeader(hDirection) {
    var _a4;
    (_a4 = this.beans.colMoves) == null ? void 0 : _a4.moveHeader(hDirection, this.eGui, this.column, this.rowCtrl.pinned, this);
  }
  getViewportAdjustedResizeDiff(e) {
    const diff = this.getResizeDiff(e);
    const { pinnedCols } = this.beans;
    return pinnedCols ? pinnedCols.getHeaderResizeDiff(diff, this.column) : diff;
  }
  getResizeDiff(e) {
    const { gos, column } = this;
    let isLeft = e.key === KeyCode.LEFT !== gos.get("enableRtl");
    const pinned = column.getPinned();
    const isRtl = gos.get("enableRtl");
    if (pinned) {
      if (isRtl !== (pinned === "right")) {
        isLeft = !isLeft;
      }
    }
    return (isLeft ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    if (!this.isResizing) {
      return;
    }
    if (this.resizeToggleTimeout) {
      window.clearTimeout(this.resizeToggleTimeout);
      this.resizeToggleTimeout = 0;
    }
    this.isResizing = false;
    this.resizeMultiplier = 1;
    this.resizeToggleTimeout = window.setTimeout(() => {
      var _a4;
      (_a4 = this.resizeFeature) == null ? void 0 : _a4.toggleColumnResizing(false);
    }, 150);
  }
  handleKeyDown(e) {
    const wrapperHasFocus = this.getWrapperHasFocus();
    switch (e.key) {
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAGE_HOME:
      case KeyCode.PAGE_END:
        if (wrapperHasFocus) {
          e.preventDefault();
        }
    }
  }
  addDomData(compBean) {
    const key = DOM_DATA_KEY_HEADER_CTRL;
    const { eGui, gos } = this;
    _setDomData(gos, eGui, key, this);
    compBean.addDestroyFunc(() => _setDomData(gos, eGui, key, null));
  }
  focus(event) {
    if (!this.isAlive()) {
      return false;
    }
    const { eGui } = this;
    if (!eGui) {
      this.reAttemptToFocus = true;
    } else {
      eGui.focus();
      this.lastFocusEvent = event || null;
    }
    return true;
  }
  focusThis() {
    this.beans.focusSvc.focusedHeader = { headerRowIndex: this.rowCtrl.rowIndex, column: this.column };
  }
  removeDragSource() {
    var _a4;
    if (this.dragSource) {
      (_a4 = this.beans.dragAndDrop) == null ? void 0 : _a4.removeDragSource(this.dragSource);
      this.dragSource = null;
    }
  }
  handleContextMenuMouseEvent(mouseEvent, touchEvent, column) {
    const event = mouseEvent != null ? mouseEvent : touchEvent;
    const { menuSvc, gos } = this.beans;
    if (gos.get("preventDefaultOnContextMenu")) {
      event.preventDefault();
    }
    if (menuSvc == null ? void 0 : menuSvc.isHeaderContextMenuEnabled(column)) {
      menuSvc.showHeaderContextMenu(column, mouseEvent, touchEvent);
    }
    this.dispatchColumnMouseEvent("columnHeaderContextMenu", column);
  }
  dispatchColumnMouseEvent(eventType, column) {
    this.eventSvc.dispatchEvent({
      type: eventType,
      column
    });
  }
  setColHeaderHeight(col, height) {
    if (!col.setAutoHeaderHeight(height)) {
      return;
    }
    const { eventSvc } = this;
    if (col.isColumn) {
      eventSvc.dispatchEvent({
        type: "columnHeaderHeightChanged",
        column: col,
        columns: [col],
        source: "autosizeColumnHeaderHeight"
      });
    } else {
      eventSvc.dispatchEvent({
        type: "columnGroupHeaderHeightChanged",
        columnGroup: col,
        source: "autosizeColumnGroupHeaderHeight"
      });
    }
  }
  clearComponent() {
    this.removeDragSource();
    this.resizeFeature = null;
    this.comp = null;
    this.eGui = null;
  }
  destroy() {
    super.destroy();
    this.column = null;
    this.lastFocusEvent = null;
    this.rowCtrl = null;
  }
};
var HeaderCellCtrl = class extends AbstractHeaderCellCtrl {
  constructor() {
    super(...arguments);
    this.refreshFunctions = {};
    this.userHeaderClasses = /* @__PURE__ */ new Set();
    this.ariaDescriptionProperties = /* @__PURE__ */ new Map();
  }
  wireComp(comp, eGui, eResize, eHeaderCompWrapper, compBeanInput) {
    this.comp = comp;
    const { rowCtrl, column, beans } = this;
    const { colResize, context, colHover, rangeSvc } = beans;
    const compBean = setupCompBean(this, context, compBeanInput);
    this.setGui(eGui, compBean);
    this.updateState();
    this.setupWidth(compBean);
    this.setupMovingCss(compBean);
    this.setupMenuClass(compBean);
    this.setupSortableClass(compBean);
    this.setupWrapTextClass();
    this.refreshSpanHeaderHeight();
    this.setupAutoHeight({
      wrapperElement: eHeaderCompWrapper,
      checkMeasuringCallback: (checkMeasuring) => this.setRefreshFunction("measuring", checkMeasuring),
      compBean
    });
    this.addColumnHoverListener(compBean);
    this.setupFilterClass(compBean);
    this.setupStylesFromColDef();
    this.setupClassesFromColDef();
    this.setupTooltip();
    this.addActiveHeaderMouseListeners(compBean);
    this.setupSelectAll(compBean);
    this.setupUserComp();
    this.refreshAria();
    if (colResize) {
      this.resizeFeature = compBean.createManagedBean(
        colResize.createResizeFeature(rowCtrl.pinned, column, eResize, comp, this)
      );
    } else {
      _setDisplayed(eResize, false);
    }
    colHover == null ? void 0 : colHover.createHoverFeature(compBean, [column], eGui);
    rangeSvc == null ? void 0 : rangeSvc.createRangeHighlightFeature(compBean, column, comp);
    compBean.createManagedBean(new SetLeftFeature(column, eGui, beans));
    compBean.createManagedBean(
      new ManagedFocusFeature(eGui, {
        shouldStopEventPropagation: (e) => this.shouldStopEventPropagation(e),
        onTabKeyDown: () => null,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    );
    this.addResizeAndMoveKeyboardListeners(compBean);
    compBean.addManagedPropertyListeners(
      ["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader", "enableAdvancedFilter"],
      () => this.refresh()
    );
    compBean.addManagedListeners(column, { colDefChanged: () => this.refresh() });
    compBean.addManagedListeners(column, { headerHighlightChanged: this.onHeaderHighlightChanged.bind(this) });
    const listener = () => this.checkDisplayName();
    compBean.addManagedEventListeners({
      columnValueChanged: listener,
      columnRowGroupChanged: listener,
      columnPivotChanged: listener,
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    });
    compBean.addDestroyFunc(() => {
      this.refreshFunctions = {};
      this.selectAllFeature = null;
      this.dragSourceElement = void 0;
      this.userCompDetails = null;
      this.userHeaderClasses.clear();
      this.ariaDescriptionProperties.clear();
      this.clearComponent();
    });
  }
  resizeHeader(delta, shiftKey) {
    var _a4;
    (_a4 = this.beans.colResize) == null ? void 0 : _a4.resizeHeader(this.column, delta, shiftKey);
  }
  getHeaderClassParams() {
    const { column, beans } = this;
    const colDef = column.colDef;
    return _addGridCommonParams(beans.gos, {
      colDef,
      column,
      floatingFilter: false
    });
  }
  setupUserComp() {
    const compDetails = this.lookupUserCompDetails();
    if (compDetails) {
      this.setCompDetails(compDetails);
    }
  }
  setCompDetails(compDetails) {
    this.userCompDetails = compDetails;
    this.comp.setUserCompDetails(compDetails);
  }
  lookupUserCompDetails() {
    const params = this.createParams();
    const colDef = this.column.getColDef();
    return _getHeaderCompDetails(this.beans.userCompFactory, colDef, params);
  }
  createParams() {
    const { menuSvc, sortSvc, colFilter, gos } = this.beans;
    const params = _addGridCommonParams(gos, {
      column: this.column,
      displayName: this.displayName,
      enableSorting: this.column.isSortable(),
      enableMenu: this.menuEnabled,
      enableFilterButton: this.openFilterEnabled && !!(menuSvc == null ? void 0 : menuSvc.isHeaderFilterButtonEnabled(this.column)),
      enableFilterIcon: !!colFilter && (!this.openFilterEnabled || _isLegacyMenuEnabled(this.gos)),
      showColumnMenu: (buttonElement, onClosedCallback) => {
        menuSvc == null ? void 0 : menuSvc.showColumnMenu({
          column: this.column,
          buttonElement,
          positionBy: "button",
          onClosedCallback
        });
      },
      showColumnMenuAfterMouseClick: (mouseEvent, onClosedCallback) => {
        menuSvc == null ? void 0 : menuSvc.showColumnMenu({
          column: this.column,
          mouseEvent,
          positionBy: "mouse",
          onClosedCallback
        });
      },
      showFilter: (buttonElement) => {
        menuSvc == null ? void 0 : menuSvc.showFilterMenu({
          column: this.column,
          buttonElement,
          containerType: "columnFilter",
          positionBy: "button"
        });
      },
      progressSort: (multiSort) => {
        sortSvc == null ? void 0 : sortSvc.progressSort(this.column, !!multiSort, "uiColumnSorted");
      },
      setSort: (sort, multiSort) => {
        sortSvc == null ? void 0 : sortSvc.setSortForColumn(this.column, sort, !!multiSort, "uiColumnSorted");
      },
      eGridHeader: this.eGui,
      setTooltip: (value, shouldDisplayTooltip) => {
        gos.assertModuleRegistered("Tooltip", 3);
        this.setupTooltip(value, shouldDisplayTooltip);
      }
    });
    return params;
  }
  setupSelectAll(compBean) {
    var _a4;
    const { selectionSvc } = this.beans;
    if (!selectionSvc) {
      return;
    }
    this.selectAllFeature = compBean.createOptionalManagedBean(selectionSvc.createSelectAllFeature(this.column));
    (_a4 = this.selectAllFeature) == null ? void 0 : _a4.setComp(this);
    compBean.addManagedPropertyListener("rowSelection", () => {
      var _a5;
      const selectAllFeature = selectionSvc.createSelectAllFeature(this.column);
      if (selectAllFeature && !this.selectAllFeature) {
        this.selectAllFeature = compBean.createManagedBean(selectAllFeature);
        (_a5 = this.selectAllFeature) == null ? void 0 : _a5.setComp(this);
        this.comp.refreshSelectAllGui();
      } else if (this.selectAllFeature && !selectAllFeature) {
        this.comp.removeSelectAllGui();
        this.selectAllFeature = this.destroyBean(this.selectAllFeature);
      }
    });
  }
  getSelectAllGui() {
    var _a4;
    return (_a4 = this.selectAllFeature) == null ? void 0 : _a4.getCheckboxGui();
  }
  handleKeyDown(e) {
    var _a4;
    super.handleKeyDown(e);
    if (e.key === KeyCode.SPACE) {
      (_a4 = this.selectAllFeature) == null ? void 0 : _a4.onSpaceKeyDown(e);
    }
    if (e.key === KeyCode.ENTER) {
      this.onEnterKeyDown(e);
    }
    if (e.key === KeyCode.DOWN && e.altKey) {
      this.showMenuOnKeyPress(e, false);
    }
  }
  onEnterKeyDown(e) {
    var _a4;
    if (e.ctrlKey || e.metaKey) {
      this.showMenuOnKeyPress(e, true);
    } else if (this.sortable) {
      (_a4 = this.beans.sortSvc) == null ? void 0 : _a4.progressSort(this.column, e.shiftKey, "uiColumnSorted");
    }
  }
  showMenuOnKeyPress(e, isFilterShortcut) {
    const headerComp = this.comp.getUserCompInstance();
    if (!isHeaderComp(headerComp)) {
      return;
    }
    if (headerComp.onMenuKeyboardShortcut(isFilterShortcut)) {
      e.preventDefault();
    }
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      this.focusThis();
      this.announceAriaDescription();
    }
    if (_isKeyboardMode()) {
      this.setActiveHeader(true);
    }
  }
  onFocusOut(e) {
    if (this.eGui.contains(e.relatedTarget)) {
      return;
    }
    this.setActiveHeader(false);
  }
  setupTooltip(value, shouldDisplayTooltip) {
    var _a4;
    this.tooltipFeature = (_a4 = this.beans.tooltipSvc) == null ? void 0 : _a4.setupHeaderTooltip(
      this.tooltipFeature,
      this,
      value,
      shouldDisplayTooltip
    );
  }
  setupStylesFromColDef() {
    this.setRefreshFunction("headerStyles", this.refreshHeaderStyles.bind(this));
    this.refreshHeaderStyles();
  }
  setupClassesFromColDef() {
    const refreshHeaderClasses = () => {
      const colDef = this.column.getColDef();
      const classes = _getHeaderClassesFromColDef(colDef, this.gos, this.column, null);
      const oldClasses = this.userHeaderClasses;
      this.userHeaderClasses = new Set(classes);
      classes.forEach((c) => {
        if (oldClasses.has(c)) {
          oldClasses.delete(c);
        } else {
          this.comp.toggleCss(c, true);
        }
      });
      oldClasses.forEach((c) => this.comp.toggleCss(c, false));
    };
    this.setRefreshFunction("headerClasses", refreshHeaderClasses);
    refreshHeaderClasses();
  }
  setDragSource(eSource) {
    var _a4, _b2;
    this.dragSourceElement = eSource;
    this.removeDragSource();
    if (!eSource || !this.draggable) {
      return;
    }
    this.dragSource = (_b2 = (_a4 = this.beans.colMoves) == null ? void 0 : _a4.setDragSourceForHeader(eSource, this.column, this.displayName)) != null ? _b2 : null;
  }
  updateState() {
    const { menuSvc } = this.beans;
    this.menuEnabled = !!(menuSvc == null ? void 0 : menuSvc.isColumnMenuInHeaderEnabled(this.column));
    this.openFilterEnabled = !!(menuSvc == null ? void 0 : menuSvc.isFilterMenuInHeaderEnabled(this.column));
    this.sortable = this.column.isSortable();
    this.displayName = this.calculateDisplayName();
    this.draggable = this.workOutDraggable();
  }
  setRefreshFunction(name, func) {
    this.refreshFunctions[name] = func;
  }
  refresh() {
    this.updateState();
    this.refreshHeaderComp();
    this.refreshAria();
    Object.values(this.refreshFunctions).forEach((f) => f());
  }
  refreshHeaderComp() {
    const newCompDetails = this.lookupUserCompDetails();
    if (!newCompDetails) {
      return;
    }
    const compInstance = this.comp.getUserCompInstance();
    const attemptRefresh = compInstance != null && this.userCompDetails.componentClass == newCompDetails.componentClass;
    const headerCompRefreshed = attemptRefresh ? this.attemptHeaderCompRefresh(newCompDetails.params) : false;
    if (headerCompRefreshed) {
      this.setDragSource(this.dragSourceElement);
    } else {
      this.setCompDetails(newCompDetails);
    }
  }
  attemptHeaderCompRefresh(params) {
    const headerComp = this.comp.getUserCompInstance();
    if (!headerComp) {
      return false;
    }
    if (!headerComp.refresh) {
      return false;
    }
    const res = headerComp.refresh(params);
    return res;
  }
  calculateDisplayName() {
    return this.beans.colNames.getDisplayNameForColumn(this.column, "header", true);
  }
  checkDisplayName() {
    if (this.displayName !== this.calculateDisplayName()) {
      this.refresh();
    }
  }
  workOutDraggable() {
    const colDef = this.column.getColDef();
    const isSuppressMovableColumns = this.gos.get("suppressMovableColumns");
    const colCanMove = !isSuppressMovableColumns && !colDef.suppressMovable && !colDef.lockPosition;
    return !!colCanMove || !!colDef.enableRowGroup || !!colDef.enablePivot;
  }
  setupWidth(compBean) {
    const listener = () => {
      const columnWidth = this.column.getActualWidth();
      this.comp.setWidth(`${columnWidth}px`);
    };
    compBean.addManagedListeners(this.column, { widthChanged: listener });
    listener();
  }
  setupMovingCss(compBean) {
    const listener = () => {
      this.comp.toggleCss("ag-header-cell-moving", this.column.isMoving());
    };
    compBean.addManagedListeners(this.column, { movingChanged: listener });
    listener();
  }
  setupMenuClass(compBean) {
    const listener = () => {
      var _a4;
      (_a4 = this.comp) == null ? void 0 : _a4.toggleCss("ag-column-menu-visible", this.column.isMenuVisible());
    };
    compBean.addManagedListeners(this.column, { menuVisibleChanged: listener });
    listener();
  }
  setupSortableClass(compBean) {
    const updateSortableCssClass = () => {
      this.comp.toggleCss("ag-header-cell-sortable", !!this.sortable);
    };
    updateSortableCssClass();
    this.setRefreshFunction("updateSortable", updateSortableCssClass);
    compBean.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
  }
  setupFilterClass(compBean) {
    const listener = () => {
      const isFilterActive = this.column.isFilterActive();
      this.comp.toggleCss("ag-header-cell-filtered", isFilterActive);
      this.refreshAria();
    };
    compBean.addManagedListeners(this.column, { filterActiveChanged: listener });
    listener();
  }
  setupWrapTextClass() {
    const listener = () => {
      const wrapText = !!this.column.getColDef().wrapHeaderText;
      this.comp.toggleCss("ag-header-cell-wrap-text", wrapText);
    };
    listener();
    this.setRefreshFunction("wrapText", listener);
  }
  onHeaderHighlightChanged() {
    const highlighted = this.column.getHighlighted();
    const beforeOn = highlighted === 0;
    const afterOn = highlighted === 1;
    this.comp.toggleCss("ag-header-highlight-before", beforeOn);
    this.comp.toggleCss("ag-header-highlight-after", afterOn);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged();
    if (!this.isAlive()) {
      return;
    }
    this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    var _a4, _b2;
    const { eGui, column, comp, beans } = this;
    const groupHeaderHeight = getGroupRowsHeight(this.beans);
    const isZeroGroupHeight = groupHeaderHeight.reduce((total, next) => total += next, 0) === 0;
    comp.toggleCss("ag-header-parent-hidden", isZeroGroupHeight);
    if (!column.isSpanHeaderHeight()) {
      eGui.style.removeProperty("top");
      eGui.style.removeProperty("height");
      comp.toggleCss("ag-header-span-height", false);
      comp.toggleCss("ag-header-span-total", false);
      return;
    }
    const { numberOfParents, isSpanningTotal } = this.column.getColumnGroupPaddingInfo();
    comp.toggleCss("ag-header-span-height", numberOfParents > 0);
    const headerHeight = getColumnHeaderRowHeight(beans);
    if (numberOfParents === 0) {
      comp.toggleCss("ag-header-span-total", false);
      eGui.style.setProperty("top", `0px`);
      eGui.style.setProperty("height", `${headerHeight}px`);
      return;
    }
    comp.toggleCss("ag-header-span-total", isSpanningTotal);
    const indexToStartSpanning = ((_b2 = (_a4 = this.column.getFirstRealParent()) == null ? void 0 : _a4.getLevel()) != null ? _b2 : -1) + 1;
    const rowsToSpan = groupHeaderHeight.length - indexToStartSpanning;
    let extraHeight = 0;
    for (let i = 0; i < rowsToSpan; i++) {
      extraHeight += groupHeaderHeight[groupHeaderHeight.length - 1 - i];
    }
    eGui.style.setProperty("top", `${-extraHeight}px`);
    eGui.style.setProperty("height", `${headerHeight + extraHeight}px`);
  }
  refreshAriaSort() {
    var _a4;
    if (this.sortable) {
      const translate = this.getLocaleTextFunc();
      const sort = ((_a4 = this.beans.sortSvc) == null ? void 0 : _a4.getDisplaySortForColumn(this.column)) || null;
      this.comp.setAriaSort(_getAriaSortState(sort));
      this.setAriaDescriptionProperty("sort", translate("ariaSortableColumn", "Press ENTER to sort"));
    } else {
      this.comp.setAriaSort();
      this.setAriaDescriptionProperty("sort", null);
    }
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const translate = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", translate("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else {
      this.setAriaDescriptionProperty("menu", null);
    }
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !_isLegacyMenuEnabled(this.gos)) {
      const translate = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty(
        "filterButton",
        translate("ariaFilterColumn", "Press CTRL ENTER to open filter")
      );
    } else {
      this.setAriaDescriptionProperty("filterButton", null);
    }
  }
  refreshAriaFiltered() {
    const translate = this.getLocaleTextFunc();
    const isFilterActive = this.column.isFilterActive();
    if (isFilterActive) {
      this.setAriaDescriptionProperty("filter", translate("ariaColumnFiltered", "Column Filtered"));
    } else {
      this.setAriaDescriptionProperty("filter", null);
    }
  }
  setAriaDescriptionProperty(property, value) {
    if (value != null) {
      this.ariaDescriptionProperties.set(property, value);
    } else {
      this.ariaDescriptionProperties.delete(property);
    }
  }
  announceAriaDescription() {
    var _a4;
    if (!this.eGui.contains(_getActiveDomElement(this.beans))) {
      return;
    }
    const ariaDescription = Array.from(this.ariaDescriptionProperties.keys()).sort((a, b) => a === "filter" ? -1 : b.charCodeAt(0) - a.charCodeAt(0)).map((key) => this.ariaDescriptionProperties.get(key)).join(". ");
    (_a4 = this.beans.ariaAnnounce) == null ? void 0 : _a4.announceValue(ariaDescription, "columnHeader");
  }
  refreshAria() {
    this.refreshAriaSort();
    this.refreshAriaMenu();
    this.refreshAriaFilterButton();
    this.refreshAriaFiltered();
  }
  addColumnHoverListener(compBean) {
    var _a4;
    (_a4 = this.beans.colHover) == null ? void 0 : _a4.addHeaderColumnHoverListener(compBean, this.comp, this.column);
  }
  addActiveHeaderMouseListeners(compBean) {
    const listener = (e) => this.handleMouseOverChange(e.type === "mouseenter");
    const clickListener = () => {
      this.setActiveHeader(true);
      this.dispatchColumnMouseEvent("columnHeaderClicked", this.column);
    };
    const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, void 0, this.column);
    compBean.addManagedListeners(this.eGui, {
      mouseenter: listener,
      mouseleave: listener,
      click: clickListener,
      contextmenu: contextMenuListener
    });
  }
  handleMouseOverChange(isMouseOver) {
    this.setActiveHeader(isMouseOver);
    this.eventSvc.dispatchEvent({
      type: isMouseOver ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column
    });
  }
  setActiveHeader(active) {
    this.comp.toggleCss("ag-header-active", active);
  }
  getAnchorElementForMenu(isFilter) {
    const headerComp = this.comp.getUserCompInstance();
    if (isHeaderComp(headerComp)) {
      return headerComp.getAnchorElementForMenu(isFilter);
    }
    return this.eGui;
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature);
    super.destroy();
  }
};
function isHeaderComp(headerComp) {
  return typeof (headerComp == null ? void 0 : headerComp.getAnchorElementForMenu) === "function" && typeof headerComp.onMenuKeyboardShortcut === "function";
}
var instanceIdSequence3 = 0;
var HeaderRowCtrl = class extends BeanStub {
  constructor(rowIndex, pinned, type) {
    super();
    this.rowIndex = rowIndex;
    this.pinned = pinned;
    this.type = type;
    this.instanceId = instanceIdSequence3++;
    this.comp = null;
    this.allCtrls = [];
    let typeClass = "ag-header-row-column";
    if (type === "group") {
      typeClass = "ag-header-row-group";
    } else if (type === "filter") {
      typeClass = "ag-header-row-filter";
    }
    this.headerRowClass = `ag-header-row ${typeClass}`;
  }
  setRowIndex(rowIndex) {
    var _a4;
    this.rowIndex = rowIndex;
    (_a4 = this.comp) == null ? void 0 : _a4.setRowIndex(this.getAriaRowIndex());
    this.onRowHeightChanged();
  }
  postConstruct() {
    this.isPrintLayout = _isDomLayout(this.gos, "print");
    this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  /** Checks that every header cell that is currently visible has been rendered.
   * Can only be false under some circumstances when using React
   */
  areCellsRendered() {
    if (!this.comp) {
      return false;
    }
    return this.allCtrls.every((ctrl) => ctrl.eGui != null);
  }
  /**
   *
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */
  setComp(comp, compBean, initCompState = true) {
    this.comp = comp;
    compBean = setupCompBean(this, this.beans.context, compBean);
    if (initCompState) {
      this.setRowIndex(this.rowIndex);
      this.onVirtualColumnsChanged();
    }
    this.setWidth();
    this.addEventListeners(compBean);
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners(compBean) {
    const onHeightChanged = this.onRowHeightChanged.bind(this);
    const onDisplayedColumnsChanged = this.onDisplayedColumnsChanged.bind(this);
    compBean.addManagedEventListeners({
      columnResized: this.setWidth.bind(this),
      displayedColumnsChanged: onDisplayedColumnsChanged,
      virtualColumnsChanged: (params) => this.onVirtualColumnsChanged(params.afterScroll),
      columnGroupHeaderHeightChanged: onHeightChanged,
      columnHeaderHeightChanged: onHeightChanged,
      gridStylesChanged: onHeightChanged,
      advancedFilterEnabledChanged: onHeightChanged
    });
    compBean.addManagedPropertyListener("domLayout", onDisplayedColumnsChanged);
    compBean.addManagedPropertyListener("ensureDomOrder", (e) => this.isEnsureDomOrder = e.currentValue);
    compBean.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      onHeightChanged
    );
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = _isDomLayout(this.gos, "print");
    this.onVirtualColumnsChanged();
    this.setWidth();
    this.onRowHeightChanged();
  }
  setWidth() {
    if (!this.comp) {
      return;
    }
    const width = this.getWidthForRow();
    this.comp.setWidth(`${width}px`);
  }
  getWidthForRow() {
    const { visibleCols } = this.beans;
    if (this.isPrintLayout) {
      const pinned = this.pinned != null;
      if (pinned) {
        return 0;
      }
      return visibleCols.getContainerWidth("right") + visibleCols.getContainerWidth("left") + visibleCols.getContainerWidth(null);
    }
    return visibleCols.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    if (!this.comp) {
      return;
    }
    const { topOffset, rowHeight } = this.getTopAndHeight();
    this.comp.setTop(topOffset + "px");
    this.comp.setHeight(rowHeight + "px");
  }
  getTopAndHeight() {
    let topOffset = 0;
    const groupHeadersHeight = getGroupRowsHeight(this.beans);
    for (let i = 0; i < groupHeadersHeight.length; i++) {
      if (i === this.rowIndex && this.type === "group") {
        return { topOffset, rowHeight: groupHeadersHeight[i] };
      }
      topOffset += groupHeadersHeight[i];
    }
    const headerHeight = getColumnHeaderRowHeight(this.beans);
    if (this.type === "column") {
      return { topOffset, rowHeight: headerHeight };
    }
    topOffset += headerHeight;
    const filterHeight = getFloatingFiltersHeight(this.beans);
    return { topOffset, rowHeight: filterHeight };
  }
  onVirtualColumnsChanged(afterScroll = false) {
    if (!this.comp) {
      return;
    }
    const ctrlsToDisplay = this.getUpdatedHeaderCtrls();
    const forceOrder = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(ctrlsToDisplay, forceOrder, afterScroll);
  }
  /**
   * Recycles the header cell ctrls and creates new ones for the columns in the viewport
   * @returns The updated header cell ctrls
   */
  getUpdatedHeaderCtrls() {
    const oldCtrls = this.ctrlsById;
    this.ctrlsById = /* @__PURE__ */ new Map();
    const columns = this.getColumnsInViewport();
    for (const child of columns) {
      this.recycleAndCreateHeaderCtrls(child, this.ctrlsById, oldCtrls);
    }
    const isFocusedAndDisplayed = (ctrl) => {
      const { focusSvc, visibleCols } = this.beans;
      const isFocused = focusSvc.isHeaderWrapperFocused(ctrl);
      if (!isFocused) {
        return false;
      }
      const isDisplayed = visibleCols.isVisible(ctrl.column);
      return isDisplayed;
    };
    if (oldCtrls) {
      for (const [id, oldCtrl] of oldCtrls) {
        const keepCtrl = isFocusedAndDisplayed(oldCtrl);
        if (keepCtrl) {
          this.ctrlsById.set(id, oldCtrl);
        } else {
          this.destroyBean(oldCtrl);
        }
      }
    }
    this.allCtrls = Array.from(this.ctrlsById.values());
    return this.allCtrls;
  }
  /** Get the current header cell ctrls */
  getHeaderCellCtrls() {
    return this.allCtrls;
  }
  recycleAndCreateHeaderCtrls(headerColumn, currCtrls, oldCtrls) {
    if (headerColumn.isEmptyGroup()) {
      return;
    }
    const idOfChild = headerColumn.getUniqueId();
    let headerCtrl;
    if (oldCtrls) {
      headerCtrl = oldCtrls.get(idOfChild);
      oldCtrls.delete(idOfChild);
    }
    const forOldColumn = headerCtrl && headerCtrl.column != headerColumn;
    if (forOldColumn) {
      this.destroyBean(headerCtrl);
      headerCtrl = void 0;
    }
    if (headerCtrl == null) {
      switch (this.type) {
        case "filter": {
          headerCtrl = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerFilterCellCtrl",
              true,
              headerColumn,
              this
            )
          );
          break;
        }
        case "group":
          headerCtrl = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerGroupCellCtrl",
              true,
              headerColumn,
              this
            )
          );
          break;
        default:
          headerCtrl = this.createBean(new HeaderCellCtrl(headerColumn, this));
          break;
      }
    }
    currCtrls.set(idOfChild, headerCtrl);
  }
  getColumnsInViewport() {
    if (!this.isPrintLayout) {
      return this.getComponentsToRender();
    }
    if (this.pinned) {
      return [];
    }
    const viewportColumns = [];
    ["left", null, "right"].forEach((pinned) => {
      viewportColumns.push(...this.getComponentsToRender(pinned));
    });
    return viewportColumns;
  }
  getComponentsToRender(pinned = this.pinned) {
    if (this.type === "group") {
      return this.beans.colViewport.getHeadersToRender(pinned, this.rowIndex);
    }
    return this.beans.colViewport.getColumnHeadersToRender(pinned);
  }
  focusHeader(column, event) {
    const ctrl = this.allCtrls.find((ctrl2) => ctrl2.column == column);
    if (!ctrl) {
      return false;
    }
    const focused = ctrl.focus(event);
    return focused;
  }
  destroy() {
    this.allCtrls = this.destroyBeans(this.allCtrls);
    this.ctrlsById = void 0;
    this.comp = null;
    super.destroy();
  }
};
var HeaderRowContainerCtrl = class extends BeanStub {
  constructor(pinned) {
    super();
    this.pinned = pinned;
    this.hidden = false;
    this.includeFloatingFilter = false;
    this.groupsRowCtrls = [];
  }
  setComp(comp, eGui) {
    this.comp = comp;
    this.eViewport = eGui;
    const { pinnedCols, ctrlsSvc, colModel, colMoves } = this.beans;
    this.setupCenterWidth();
    pinnedCols == null ? void 0 : pinnedCols.setupHeaderPinnedWidth(this);
    this.setupDragAndDrop(colMoves, this.eViewport);
    const onDisplayedColsChanged = this.refresh.bind(this, true);
    this.addManagedEventListeners({
      displayedColumnsChanged: onDisplayedColsChanged,
      advancedFilterEnabledChanged: onDisplayedColsChanged
    });
    const headerType = `${typeof this.pinned === "string" ? this.pinned : "center"}Header`;
    ctrlsSvc.register(headerType, this);
    if (colModel.ready) {
      this.refresh();
    }
  }
  getAllCtrls() {
    const res = [...this.groupsRowCtrls];
    if (this.columnsRowCtrl) {
      res.push(this.columnsRowCtrl);
    }
    if (this.filtersRowCtrl) {
      res.push(this.filtersRowCtrl);
    }
    return res;
  }
  refresh(keepColumns = false) {
    const { focusSvc, filterManager, visibleCols } = this.beans;
    let sequence = 0;
    const focusedHeaderPosition = focusSvc.getFocusHeaderToUseAfterRefresh();
    const refreshColumnGroups = () => {
      const groupRowCount = visibleCols.headerGroupRowCount;
      sequence = groupRowCount;
      const currentGroupCount = this.groupsRowCtrls.length;
      if (currentGroupCount === groupRowCount) {
        return;
      }
      if (currentGroupCount > groupRowCount) {
        for (let i = groupRowCount; i < currentGroupCount; i++) {
          this.destroyBean(this.groupsRowCtrls[i]);
        }
        this.groupsRowCtrls.length = groupRowCount;
        return;
      }
      for (let i = currentGroupCount; i < groupRowCount; i++) {
        const ctrl = this.createBean(new HeaderRowCtrl(i, this.pinned, "group"));
        this.groupsRowCtrls.push(ctrl);
      }
    };
    const refreshColumns = () => {
      const rowIndex = sequence++;
      if (this.hidden) {
        this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
        return;
      }
      if (this.columnsRowCtrl == null || !keepColumns) {
        this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
        this.columnsRowCtrl = this.createBean(new HeaderRowCtrl(rowIndex, this.pinned, "column"));
      } else if (this.columnsRowCtrl.rowIndex !== rowIndex) {
        this.columnsRowCtrl.setRowIndex(rowIndex);
      }
    };
    const refreshFilters = () => {
      this.includeFloatingFilter = !!(filterManager == null ? void 0 : filterManager.hasFloatingFilters()) && !this.hidden;
      const destroyPreviousComp = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        destroyPreviousComp();
        return;
      }
      if (!keepColumns) {
        destroyPreviousComp();
      }
      const rowIndex = sequence++;
      if (this.filtersRowCtrl) {
        const rowIndexMismatch = this.filtersRowCtrl.rowIndex !== rowIndex;
        if (rowIndexMismatch) {
          this.filtersRowCtrl.setRowIndex(rowIndex);
        }
      } else {
        this.filtersRowCtrl = this.createBean(new HeaderRowCtrl(rowIndex, this.pinned, "filter"));
      }
    };
    const oldCtrls = this.getAllCtrls();
    refreshColumnGroups();
    refreshColumns();
    refreshFilters();
    const allCtrls = this.getAllCtrls();
    this.comp.setCtrls(allCtrls);
    this.restoreFocusOnHeader(focusSvc, focusedHeaderPosition);
    if (oldCtrls.length !== allCtrls.length) {
      this.beans.eventSvc.dispatchEvent({
        type: "headerRowsChanged"
      });
    }
  }
  getHeaderCtrlForColumn(column) {
    const findCtrl = (ctrl) => ctrl == null ? void 0 : ctrl.getHeaderCellCtrls().find((ctrl2) => ctrl2.column === column);
    if (isColumn(column)) {
      return findCtrl(this.columnsRowCtrl);
    }
    if (this.groupsRowCtrls.length === 0) {
      return;
    }
    for (let i = 0; i < this.groupsRowCtrls.length; i++) {
      const ctrl = findCtrl(this.groupsRowCtrls[i]);
      if (ctrl) {
        return ctrl;
      }
    }
  }
  getHtmlElementForColumnHeader(column) {
    var _a4, _b2;
    return (_b2 = (_a4 = this.getHeaderCtrlForColumn(column)) == null ? void 0 : _a4.eGui) != null ? _b2 : null;
  }
  getRowType(rowIndex) {
    var _a4;
    return (_a4 = this.getAllCtrls()[rowIndex]) == null ? void 0 : _a4.type;
  }
  focusHeader(rowIndex, column, event) {
    const allCtrls = this.getAllCtrls();
    const ctrl = allCtrls[rowIndex];
    if (!ctrl) {
      return false;
    }
    return ctrl.focusHeader(column, event);
  }
  getGroupRowCount() {
    return this.groupsRowCtrls.length;
  }
  getGroupRowCtrlAtIndex(index) {
    return this.groupsRowCtrls[index];
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  setHorizontalScroll(offset) {
    this.comp.setViewportScrollLeft(offset);
  }
  onScrollCallback(fn) {
    this.addManagedElementListeners(this.eViewport, { scroll: fn });
  }
  destroy() {
    this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
    this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl);
    this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
    super.destroy();
  }
  setupDragAndDrop(colMoves, dropContainer) {
    const bodyDropTarget = colMoves == null ? void 0 : colMoves.createBodyDropTarget(this.pinned, dropContainer);
    if (bodyDropTarget) {
      this.createManagedBean(bodyDropTarget);
    }
  }
  restoreFocusOnHeader(focusSvc, position) {
    if (!position) {
      return;
    }
    const { column } = position;
    if (column.getPinned() != this.pinned) {
      return;
    }
    focusSvc.focusHeaderPosition({ headerPosition: position });
  }
  setupCenterWidth() {
    if (this.pinned != null) {
      return;
    }
    this.createManagedBean(new CenterWidthFeature((width) => this.comp.setCenterWidth(`${width}px`), true));
  }
};
var OverlayComponent = class extends Component {
  constructor() {
    super();
  }
};
var LoadingOverlayElement = {
  tag: "span",
  cls: "ag-overlay-loading-center"
};
var LoadingOverlayComponent2 = class extends OverlayComponent {
  init() {
    var _a4;
    const customTemplate = _makeNull((_a4 = this.gos.get("overlayLoadingTemplate")) == null ? void 0 : _a4.trim());
    this.setTemplate(customTemplate != null ? customTemplate : LoadingOverlayElement);
    if (!customTemplate) {
      const localeTextFunc = this.getLocaleTextFunc();
      const loadingText = localeTextFunc("loadingOoo", "Loading...");
      this.getGui().textContent = loadingText;
      this.beans.ariaAnnounce.announceValue(loadingText, "overlay");
    }
  }
};
var NoRowsOverlayElement = { tag: "span", cls: "ag-overlay-no-rows-center" };
var NoRowsOverlayComponent2 = class extends OverlayComponent {
  init() {
    var _a4;
    const customTemplate = _makeNull((_a4 = this.gos.get("overlayNoRowsTemplate")) == null ? void 0 : _a4.trim());
    this.setTemplate(customTemplate != null ? customTemplate : NoRowsOverlayElement);
    if (!customTemplate) {
      const localeTextFunc = this.getLocaleTextFunc();
      const noRowsText = localeTextFunc("noRowsToShow", "No Rows To Show");
      this.getGui().textContent = noRowsText;
      this.beans.ariaAnnounce.announceValue(noRowsText, "overlay");
    }
  }
};
function _createIcon(iconName, beans, column) {
  const iconContents = _createIconNoSpan(iconName, beans, column);
  if (iconContents) {
    const { className } = iconContents;
    if (typeof className === "string" && className.indexOf("ag-icon") > -1 || typeof className === "object" && className["ag-icon"]) {
      return iconContents;
    }
  }
  const eResult = _createElement({ tag: "span" });
  eResult.appendChild(iconContents);
  return eResult;
}
function _createIconNoSpan(iconName, beans, column) {
  var _a4;
  let userProvidedIcon = null;
  if (iconName === "smallDown") {
    _warn(262);
  } else if (iconName === "smallLeft") {
    _warn(263);
  } else if (iconName === "smallRight") {
    _warn(264);
  }
  const icons = column && column.getColDef().icons;
  if (icons) {
    userProvidedIcon = icons[iconName];
  }
  if (beans.gos && !userProvidedIcon) {
    const optionsIcons = beans.gos.get("icons");
    if (optionsIcons) {
      userProvidedIcon = optionsIcons[iconName];
    }
  }
  if (userProvidedIcon) {
    let rendererResult;
    if (typeof userProvidedIcon === "function") {
      rendererResult = userProvidedIcon();
    } else if (typeof userProvidedIcon === "string") {
      rendererResult = userProvidedIcon;
    } else {
      _warn(38, { iconName });
      return void 0;
    }
    if (typeof rendererResult === "string") {
      return _loadTemplate(rendererResult);
    }
    if (_isNodeOrElement(rendererResult)) {
      return rendererResult;
    }
    _warn(133, { iconName });
    return void 0;
  } else {
    const iconValue = beans.registry.getIcon(iconName);
    if (!iconValue) {
      (_a4 = beans.validation) == null ? void 0 : _a4.validateIcon(iconName);
    }
    return _createElement({
      tag: "span",
      cls: `ag-icon ag-icon-${iconValue != null ? iconValue : iconName}`,
      role: "presentation",
      attrs: { unselectable: "on" }
    });
  }
}
var dragAndDropImageComponentCSS = (
  /*css*/
  `.ag-dnd-ghost{align-items:center;background-color:var(--ag-drag-and-drop-image-background-color);border:var(--ag-drag-and-drop-image-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-drag-and-drop-image-shadow);color:var(--ag-text-color);cursor:move;display:flex;font-weight:500;gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);text-overflow:ellipsis;transform:translateY(calc(var(--ag-spacing)*2));white-space:nowrap}.ag-dnd-ghost-not-allowed{border:var(--ag-drag-and-drop-image-not-allowed-border)}`
);
var DragAndDropElement = {
  tag: "div",
  children: [
    {
      tag: "div",
      ref: "eGhost",
      cls: "ag-dnd-ghost ag-unselectable",
      children: [
        { tag: "span", ref: "eIcon", cls: "ag-dnd-ghost-icon ag-shake-left-to-right" },
        { tag: "div", ref: "eLabel", cls: "ag-dnd-ghost-label" }
      ]
    }
  ]
};
var DragAndDropImageComponent2 = class extends Component {
  constructor() {
    super();
    this.dragSource = null;
    this.eIcon = RefPlaceholder;
    this.eLabel = RefPlaceholder;
    this.eGhost = RefPlaceholder;
    this.registerCSS(dragAndDropImageComponentCSS);
  }
  postConstruct() {
    const create = (iconName) => _createIcon(iconName, this.beans, null);
    this.dropIconMap = {
      pinned: create("columnMovePin"),
      hide: create("columnMoveHide"),
      move: create("columnMoveMove"),
      left: create("columnMoveLeft"),
      right: create("columnMoveRight"),
      group: create("columnMoveGroup"),
      aggregate: create("columnMoveValue"),
      pivot: create("columnMovePivot"),
      notAllowed: create("dropNotAllowed")
    };
  }
  init(params) {
    this.dragSource = params.dragSource;
    this.setTemplate(DragAndDropElement);
    this.beans.environment.applyThemeClasses(this.eGhost);
  }
  destroy() {
    this.dragSource = null;
    super.destroy();
  }
  setIcon(iconName, shake) {
    const { eGhost, eIcon, dragSource, dropIconMap, gos } = this;
    _clearElement(eIcon);
    let eIconChild = null;
    if (!iconName) {
      iconName = (dragSource == null ? void 0 : dragSource.getDefaultIconName) ? dragSource.getDefaultIconName() : "notAllowed";
    }
    eIconChild = dropIconMap[iconName];
    eGhost.classList.toggle("ag-dnd-ghost-not-allowed", iconName === "notAllowed");
    eIcon.classList.toggle("ag-shake-left-to-right", shake);
    if (eIconChild === dropIconMap["hide"] && gos.get("suppressDragLeaveHidesColumns")) {
      return;
    }
    if (eIconChild) {
      eIcon.appendChild(eIconChild);
    }
  }
  setLabel(label) {
    this.eLabel.textContent = label;
  }
};
var checkboxCellRendererCSS = (
  /*css*/
  `.ag-checkbox-cell{height:100%}`
);
var CheckboxCellRendererElement = {
  tag: "div",
  cls: "ag-cell-wrapper ag-checkbox-cell",
  role: "presentation",
  children: [
    {
      tag: "ag-checkbox",
      ref: "eCheckbox",
      role: "presentation"
    }
  ]
};
var CheckboxCellRenderer = class extends Component {
  constructor() {
    super(CheckboxCellRendererElement, [AgCheckboxSelector]);
    this.eCheckbox = RefPlaceholder;
    this.registerCSS(checkboxCellRendererCSS);
  }
  init(params) {
    this.refresh(params);
    const { eCheckbox, beans } = this;
    const inputEl = eCheckbox.getInputElement();
    inputEl.setAttribute("tabindex", "-1");
    _setAriaLive(inputEl, "polite");
    this.addManagedListeners(inputEl, {
      click: (event) => {
        _stopPropagationForAgGrid(event);
        if (eCheckbox.isDisabled()) {
          return;
        }
        const isSelected = eCheckbox.getValue();
        this.onCheckboxChanged(isSelected);
      },
      dblclick: (event) => {
        _stopPropagationForAgGrid(event);
      }
    });
    this.addManagedElementListeners(params.eGridCell, {
      keydown: (event) => {
        if (event.key === KeyCode.SPACE && !eCheckbox.isDisabled()) {
          if (params.eGridCell === _getActiveDomElement(beans)) {
            eCheckbox.toggle();
          }
          const isSelected = eCheckbox.getValue();
          this.onCheckboxChanged(isSelected);
          event.preventDefault();
        }
      }
    });
  }
  refresh(params) {
    this.params = params;
    this.updateCheckbox(params);
    return true;
  }
  updateCheckbox(params) {
    var _a4;
    let isSelected;
    let displayed = true;
    const { value, column, node } = params;
    if (node.group && column) {
      if (typeof value === "boolean") {
        isSelected = value;
      } else {
        const colId = column.getColId();
        if (colId.startsWith(GROUP_AUTO_COLUMN_ID)) {
          isSelected = value == null || value === "" ? void 0 : value === "true";
        } else if (node.aggData && node.aggData[colId] !== void 0) {
          isSelected = value != null ? value : void 0;
        } else if (node.sourceRowIndex >= 0) {
          isSelected = value != null ? value : void 0;
        } else {
          displayed = false;
        }
      }
    } else {
      isSelected = value != null ? value : void 0;
    }
    const { eCheckbox } = this;
    if (!displayed) {
      eCheckbox.setDisplayed(false);
      return;
    }
    eCheckbox.setValue(isSelected);
    const disabled = (_a4 = params.disabled) != null ? _a4 : !(column == null ? void 0 : column.isCellEditable(node));
    eCheckbox.setDisabled(disabled);
    const translate = this.getLocaleTextFunc();
    const stateName = _getAriaCheckboxStateName(translate, isSelected);
    const ariaLabel = disabled ? stateName : `${translate("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${stateName})`;
    eCheckbox.setInputAriaLabel(ariaLabel);
  }
  onCheckboxChanged(isSelected) {
    var _a4, _b2, _c, _d;
    const { params } = this;
    const { column, node, value } = params;
    (_b2 = (_a4 = this.beans) == null ? void 0 : _a4.editSvc) == null ? void 0 : _b2.setEditingCells(
      [
        {
          column,
          colId: column.getColId(),
          rowIndex: node.rowIndex,
          rowPinned: node.rowPinned,
          state: "changed",
          oldValue: value,
          newValue: value
        }
      ],
      { update: true, forceRefreshOfEditCellsOnly: true }
    );
    const valueChanged = node.setDataValue(column, isSelected, "renderer");
    (_d = this.beans.editSvc) == null ? void 0 : _d.stopEditing(
      {
        rowNode: node,
        column
      },
      { source: ((_c = this.beans.editSvc) == null ? void 0 : _c.isBatchEditing()) ? "ui" : "api" }
    );
    if (!valueChanged) {
      this.updateCheckbox(params);
    }
  }
};
function _isManualPinnedRow(rowNode) {
  return !!(rowNode.rowPinned && rowNode.pinnedSibling);
}
var TabGuardClassNames = {
  TAB_GUARD: "ag-tab-guard",
  TAB_GUARD_TOP: "ag-tab-guard-top",
  TAB_GUARD_BOTTOM: "ag-tab-guard-bottom"
};
var TabGuardCtrl = class extends BeanStub {
  constructor(params) {
    super();
    this.skipTabGuardFocus = false;
    this.forcingFocusOut = false;
    this.allowFocus = false;
    const {
      comp,
      eTopGuard,
      eBottomGuard,
      focusTrapActive,
      forceFocusOutWhenTabGuardsAreEmpty,
      isFocusableContainer,
      focusInnerElement,
      onFocusIn,
      onFocusOut,
      shouldStopEventPropagation,
      onTabKeyDown,
      handleKeyDown,
      isEmpty,
      eFocusableElement
    } = params;
    this.comp = comp;
    this.eTopGuard = eTopGuard;
    this.eBottomGuard = eBottomGuard;
    this.providedFocusInnerElement = focusInnerElement;
    this.eFocusableElement = eFocusableElement;
    this.focusTrapActive = !!focusTrapActive;
    this.forceFocusOutWhenTabGuardsAreEmpty = !!forceFocusOutWhenTabGuardsAreEmpty;
    this.isFocusableContainer = !!isFocusableContainer;
    this.providedFocusIn = onFocusIn;
    this.providedFocusOut = onFocusOut;
    this.providedShouldStopEventPropagation = shouldStopEventPropagation;
    this.providedOnTabKeyDown = onTabKeyDown;
    this.providedHandleKeyDown = handleKeyDown;
    this.providedIsEmpty = isEmpty;
  }
  postConstruct() {
    this.createManagedBean(
      new ManagedFocusFeature(this.eFocusableElement, {
        shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e)
      })
    );
    this.activateTabGuards();
    [this.eTopGuard, this.eBottomGuard].forEach(
      (guard) => this.addManagedElementListeners(guard, { focus: this.onFocus.bind(this) })
    );
  }
  handleKeyDown(e) {
    if (this.providedHandleKeyDown) {
      this.providedHandleKeyDown(e);
    }
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    if (this.providedShouldStopEventPropagation) {
      return this.providedShouldStopEventPropagation();
    }
    return false;
  }
  activateTabGuards() {
    if (this.forcingFocusOut) {
      return;
    }
    const tabIndex = this.gos.get("tabIndex");
    this.comp.setTabIndex(tabIndex.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget)) {
      if (!this.allowFocus) {
        this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
        return;
      }
    }
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = false;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty) {
      const isEmpty = this.providedIsEmpty ? this.providedIsEmpty() : _findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0;
      if (isEmpty) {
        this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
        return;
      }
    }
    if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget)) {
      return;
    }
    const fromBottom = e.target === this.eBottomGuard;
    const hasFocusedInnerElement = this.providedFocusInnerElement ? this.providedFocusInnerElement(fromBottom) : this.focusInnerElement(fromBottom);
    if (!hasFocusedInnerElement && this.forceFocusOutWhenTabGuardsAreEmpty) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
    }
  }
  findNextElementOutsideAndFocus(up) {
    var _a4;
    const eDocument = _getDocument(this.beans);
    const focusableEls = _findFocusableElements(eDocument.body, null, true);
    const index = focusableEls.indexOf(up ? this.eTopGuard : this.eBottomGuard);
    if (index === -1) {
      return;
    }
    let start;
    let end;
    if (up) {
      start = 0;
      end = index;
    } else {
      start = index + 1;
      end = focusableEls.length;
    }
    const focusableRange = focusableEls.slice(start, end);
    const targetTabIndex = this.gos.get("tabIndex");
    focusableRange.sort((a, b) => {
      const indexA = parseInt(a.getAttribute("tabindex") || "0");
      const indexB = parseInt(b.getAttribute("tabindex") || "0");
      if (indexB === targetTabIndex) {
        return 1;
      }
      if (indexA === targetTabIndex) {
        return -1;
      }
      if (indexA === 0) {
        return 1;
      }
      if (indexB === 0) {
        return -1;
      }
      return indexA - indexB;
    });
    (_a4 = focusableRange[up ? focusableRange.length - 1 : 0]) == null ? void 0 : _a4.focus();
  }
  onFocusIn(e) {
    if (this.focusTrapActive || this.forcingFocusOut) {
      return;
    }
    if (this.providedFocusIn) {
      this.providedFocusIn(e);
    }
    if (!this.isFocusableContainer) {
      this.deactivateTabGuards();
    }
  }
  onFocusOut(e) {
    if (this.focusTrapActive) {
      return;
    }
    if (this.providedFocusOut) {
      this.providedFocusOut(e);
    }
    if (!this.eFocusableElement.contains(e.relatedTarget)) {
      this.activateTabGuards();
    }
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive) {
      return;
    }
    if (e.defaultPrevented) {
      return;
    }
    const tabGuardsAreActive = this.tabGuardsAreActive();
    if (tabGuardsAreActive) {
      this.deactivateTabGuards();
    }
    const nextRoot = this.getNextFocusableElement(e.shiftKey);
    if (tabGuardsAreActive) {
      setTimeout(() => this.activateTabGuards(), 0);
    }
    if (!nextRoot) {
      return;
    }
    nextRoot.focus();
    e.preventDefault();
  }
  focusInnerElement(fromBottom = false) {
    const focusable = _findFocusableElements(this.eFocusableElement);
    if (this.tabGuardsAreActive()) {
      focusable.splice(0, 1);
      focusable.splice(focusable.length - 1, 1);
    }
    if (!focusable.length) {
      return false;
    }
    focusable[fromBottom ? focusable.length - 1 : 0].focus({ preventScroll: true });
    return true;
  }
  getNextFocusableElement(backwards) {
    return _findNextFocusableElement(this.beans, this.eFocusableElement, false, backwards);
  }
  forceFocusOutOfContainer(up = false) {
    if (this.forcingFocusOut) {
      return;
    }
    const tabGuardToFocus = up ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards();
    this.skipTabGuardFocus = true;
    this.forcingFocusOut = true;
    tabGuardToFocus.focus();
    window.setTimeout(() => {
      this.forcingFocusOut = false;
      this.activateTabGuards();
    });
  }
  isTabGuard(element, bottom) {
    return element === this.eTopGuard && !bottom || element === this.eBottomGuard && (bottom != null ? bottom : true);
  }
  setAllowFocus(allowFocus) {
    this.allowFocus = allowFocus;
  }
};
var TabGuardFeature = class extends BeanStub {
  constructor(comp) {
    super();
    this.comp = comp;
  }
  initialiseTabGuard(params) {
    this.eTopGuard = this.createTabGuard("top");
    this.eBottomGuard = this.createTabGuard("bottom");
    this.eFocusableElement = this.comp.getFocusableElement();
    const { eTopGuard, eBottomGuard, eFocusableElement } = this;
    const tabGuards = [eTopGuard, eBottomGuard];
    const compProxy = {
      setTabIndex: (tabIndex) => {
        tabGuards.forEach(
          (tabGuard) => tabIndex != null ? tabGuard.setAttribute("tabindex", tabIndex) : tabGuard.removeAttribute("tabindex")
        );
      }
    };
    this.addTabGuards(eTopGuard, eBottomGuard);
    const {
      focusTrapActive = false,
      onFocusIn,
      onFocusOut,
      focusInnerElement,
      handleKeyDown,
      onTabKeyDown,
      shouldStopEventPropagation,
      isEmpty,
      forceFocusOutWhenTabGuardsAreEmpty,
      isFocusableContainer
    } = params;
    this.tabGuardCtrl = this.createManagedBean(
      new TabGuardCtrl({
        comp: compProxy,
        focusTrapActive,
        eTopGuard,
        eBottomGuard,
        eFocusableElement,
        onFocusIn,
        onFocusOut,
        focusInnerElement,
        handleKeyDown,
        onTabKeyDown,
        shouldStopEventPropagation,
        isEmpty,
        forceFocusOutWhenTabGuardsAreEmpty,
        isFocusableContainer
      })
    );
  }
  getTabGuardCtrl() {
    return this.tabGuardCtrl;
  }
  createTabGuard(side) {
    const tabGuard = _getDocument(this.beans).createElement("div");
    const cls = side === "top" ? TabGuardClassNames.TAB_GUARD_TOP : TabGuardClassNames.TAB_GUARD_BOTTOM;
    tabGuard.classList.add(TabGuardClassNames.TAB_GUARD, cls);
    _setAriaRole(tabGuard, "presentation");
    return tabGuard;
  }
  addTabGuards(topTabGuard, bottomTabGuard) {
    const eFocusableElement = this.eFocusableElement;
    eFocusableElement.insertAdjacentElement("afterbegin", topTabGuard);
    eFocusableElement.insertAdjacentElement("beforeend", bottomTabGuard);
  }
  removeAllChildrenExceptTabGuards() {
    const tabGuards = [this.eTopGuard, this.eBottomGuard];
    _clearElement(this.comp.getFocusableElement());
    this.addTabGuards(...tabGuards);
  }
  forceFocusOutOfContainer(up = false) {
    this.tabGuardCtrl.forceFocusOutOfContainer(up);
  }
  appendChild(appendChild, newChild, container) {
    if (!_isNodeOrElement(newChild)) {
      newChild = newChild.getGui();
    }
    const { eBottomGuard: bottomTabGuard } = this;
    if (bottomTabGuard) {
      bottomTabGuard.insertAdjacentElement("beforebegin", newChild);
    } else {
      appendChild(newChild, container);
    }
  }
  destroy() {
    const { eTopGuard, eBottomGuard } = this;
    _removeFromParent(eTopGuard);
    _removeFromParent(eBottomGuard);
    super.destroy();
  }
};
var TabGuardComp = class extends Component {
  initialiseTabGuard(params) {
    this.tabGuardFeature = this.createManagedBean(new TabGuardFeature(this));
    this.tabGuardFeature.initialiseTabGuard(params);
  }
  forceFocusOutOfContainer(up = false) {
    this.tabGuardFeature.forceFocusOutOfContainer(up);
  }
  appendChild(newChild, container) {
    this.tabGuardFeature.appendChild(super.appendChild.bind(this), newChild, container);
  }
};
var TouchListener = class {
  constructor(eElement, preventMouseClick = false) {
    this.DOUBLE_TAP_MILLIS = 500;
    this.destroyFuncs = [];
    this.touching = false;
    this.localEventService = new LocalEventService();
    this.preventMouseClick = preventMouseClick;
    const startListener = this.onTouchStart.bind(this);
    const moveListener = this.onTouchMove.bind(this);
    const endListener = this.onTouchEnd.bind(this);
    eElement.addEventListener("touchstart", startListener, { passive: true });
    eElement.addEventListener("touchmove", moveListener, { passive: true });
    eElement.addEventListener("touchend", endListener, { passive: false });
    this.destroyFuncs.push(() => {
      eElement.removeEventListener("touchstart", startListener, { passive: true });
      eElement.removeEventListener("touchmove", moveListener, { passive: true });
      eElement.removeEventListener("touchend", endListener, { passive: false });
    });
  }
  getActiveTouch(touchList) {
    for (let i = 0; i < touchList.length; i++) {
      const matches = touchList[i].identifier === this.touchStart.identifier;
      if (matches) {
        return touchList[i];
      }
    }
    return null;
  }
  addEventListener(eventType, listener) {
    this.localEventService.addEventListener(eventType, listener);
  }
  removeEventListener(eventType, listener) {
    this.localEventService.removeEventListener(eventType, listener);
  }
  onTouchStart(touchEvent) {
    if (this.touching) {
      return;
    }
    this.touchStart = touchEvent.touches[0];
    this.touching = true;
    this.moved = false;
    const touchStartCopy = this.touchStart;
    window.setTimeout(() => {
      const touchesMatch = this.touchStart === touchStartCopy;
      if (this.touching && touchesMatch && !this.moved) {
        this.moved = true;
        const event = {
          type: "longTap",
          touchStart: this.touchStart,
          touchEvent
        };
        this.localEventService.dispatchEvent(event);
      }
    }, 500);
  }
  onTouchMove(touchEvent) {
    if (!this.touching) {
      return;
    }
    const touch = this.getActiveTouch(touchEvent.touches);
    if (!touch) {
      return;
    }
    const eventIsFarAway = !_areEventsNear(touch, this.touchStart, 4);
    if (eventIsFarAway) {
      this.moved = true;
    }
  }
  onTouchEnd(touchEvent) {
    if (!this.touching) {
      return;
    }
    if (!this.moved) {
      const event = {
        type: "tap",
        touchStart: this.touchStart
      };
      this.localEventService.dispatchEvent(event);
      this.checkForDoubleTap();
    }
    if (this.preventMouseClick && touchEvent.cancelable) {
      touchEvent.preventDefault();
    }
    this.touching = false;
  }
  checkForDoubleTap() {
    const now = Date.now();
    if (this.lastTapTime && this.lastTapTime > 0) {
      const interval = now - this.lastTapTime;
      if (interval > this.DOUBLE_TAP_MILLIS) {
        const event = {
          type: "doubleTap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(event);
        this.lastTapTime = null;
      } else {
        this.lastTapTime = now;
      }
    } else {
      this.lastTapTime = now;
    }
  }
  destroy() {
    this.destroyFuncs.forEach((func) => func());
  }
};
var VanillaFrameworkOverrides = class {
  constructor(frameworkName = "javascript") {
    this.frameworkName = frameworkName;
    this.renderingEngine = "vanilla";
    this.batchFrameworkComps = false;
    this.wrapIncoming = (callback) => callback();
    this.wrapOutgoing = (callback) => callback();
    this.baseDocLink = `${BASE_URL}/${this.frameworkName}-data-grid`;
    setValidationDocLink(this.baseDocLink);
  }
  frameworkComponent(_) {
    return null;
  }
  isFrameworkComponent(_) {
    return false;
  }
  getDocLink(path) {
    return `${this.baseDocLink}${path ? `/${path}` : ""}`;
  }
};
function createGridApi(context) {
  return {
    beanName: "gridApi",
    bean: context.getBean("apiFunctionSvc").api
  };
}
var orderedCoreBeans = [
  // Validate license first
  "licenseManager",
  // core beans only
  "environment",
  "eventSvc",
  "gos",
  "paginationAutoPageSizeSvc",
  "apiFunctionSvc",
  "gridApi",
  "registry",
  "agCompUtils",
  "userCompFactory",
  "rowContainerHeight",
  "horizontalResizeSvc",
  "localeSvc",
  "pinnedRowModel",
  "dragSvc",
  "colGroupSvc",
  "visibleCols",
  "popupSvc",
  "selectionSvc",
  "colFilter",
  "quickFilter",
  "filterManager",
  "colModel",
  "headerNavigation",
  "pageBounds",
  "pagination",
  "pageBoundsListener",
  "rowSpanSvc",
  "stickyRowSvc",
  "rowRenderer",
  "expressionSvc",
  "alignedGridsSvc",
  "navigation",
  "valueCache",
  "valueSvc",
  "autoWidthCalc",
  "filterMenuFactory",
  "dragAndDrop",
  "focusSvc",
  "cellNavigation",
  "cellStyles",
  "scrollVisibleSvc",
  "sortSvc",
  "colHover",
  "colAnimation",
  "autoColSvc",
  "selectionColSvc",
  "changeDetectionSvc",
  "animationFrameSvc",
  "undoRedo",
  "colDefFactory",
  "rowStyleSvc",
  "rowNodeBlockLoader",
  "rowNodeSorter",
  "ctrlsSvc",
  "pinnedCols",
  "dataTypeSvc",
  "syncSvc",
  "overlays",
  "stateSvc",
  "expansionSvc",
  "apiEventSvc",
  "ariaAnnounce",
  "menuSvc",
  "colMoves",
  "colAutosize",
  "colFlex",
  "colResize",
  "pivotColsSvc",
  "valueColsSvc",
  "rowGroupColsSvc",
  "colNames",
  "colViewport",
  "pivotResultCols",
  "showRowGroupCols",
  "validation"
  // Have validations run last
];
var beanNamePosition = Object.fromEntries(
  orderedCoreBeans.map((beanName, index) => [beanName, index])
);
function gridBeanInitComparator(bean1, bean2) {
  var _a4, _b2;
  const index1 = (_a4 = bean1.beanName ? beanNamePosition[bean1.beanName] : void 0) != null ? _a4 : Number.MAX_SAFE_INTEGER;
  const index2 = (_b2 = bean2.beanName ? beanNamePosition[bean2.beanName] : void 0) != null ? _b2 : Number.MAX_SAFE_INTEGER;
  return index1 - index2;
}
function gridBeanDestroyComparator(bean1, bean2) {
  if ((bean1 == null ? void 0 : bean1.beanName) === "gridDestroySvc") {
    return -1;
  }
  if ((bean2 == null ? void 0 : bean2.beanName) === "gridDestroySvc") {
    return 1;
  }
  return 0;
}
var PinnedLeftElement = { tag: "div", cls: "ag-pinned-left-header", role: "rowgroup" };
var PinnedRightElement = { tag: "div", cls: "ag-pinned-right-header", role: "rowgroup" };
var CenterElement = {
  tag: "div",
  cls: "ag-header-viewport",
  role: "rowgroup",
  attrs: { tabindex: "-1" },
  children: [{ tag: "div", ref: "eCenterContainer", cls: "ag-header-container", role: "presentation" }]
};
var HeaderRowContainerComp = class extends Component {
  constructor(pinned) {
    super();
    this.eCenterContainer = RefPlaceholder;
    this.headerRowComps = {};
    this.rowCompsList = [];
    this.pinned = pinned;
  }
  postConstruct() {
    this.selectAndSetTemplate();
    const compProxy = {
      setDisplayed: (displayed) => this.setDisplayed(displayed),
      setCtrls: (ctrls) => this.setCtrls(ctrls),
      // only gets called for center section
      setCenterWidth: (width) => this.eCenterContainer.style.width = width,
      setViewportScrollLeft: (left) => this.getGui().scrollLeft = left,
      // only gets called for pinned sections
      setPinnedContainerWidth: (width) => {
        const eGui = this.getGui();
        eGui.style.width = width;
        eGui.style.maxWidth = width;
        eGui.style.minWidth = width;
      }
    };
    const ctrl = this.createManagedBean(new HeaderRowContainerCtrl(this.pinned));
    ctrl.setComp(compProxy, this.getGui());
  }
  selectAndSetTemplate() {
    const pinnedLeft = this.pinned == "left";
    const pinnedRight = this.pinned == "right";
    const template = pinnedLeft ? PinnedLeftElement : pinnedRight ? PinnedRightElement : CenterElement;
    this.setTemplate(template);
    this.eRowContainer = this.eCenterContainer !== RefPlaceholder ? this.eCenterContainer : this.getGui();
  }
  destroy() {
    this.setCtrls([]);
    super.destroy();
  }
  destroyRowComp(rowComp) {
    this.destroyBean(rowComp);
    this.eRowContainer.removeChild(rowComp.getGui());
  }
  setCtrls(ctrls) {
    const oldRowComps = this.headerRowComps;
    this.headerRowComps = {};
    this.rowCompsList = [];
    let prevGui;
    const appendEnsuringDomOrder = (rowComp) => {
      const eGui = rowComp.getGui();
      const notAlreadyIn = eGui.parentElement != this.eRowContainer;
      if (notAlreadyIn) {
        this.eRowContainer.appendChild(eGui);
      }
      if (prevGui) {
        _ensureDomOrder(this.eRowContainer, eGui, prevGui);
      }
      prevGui = eGui;
    };
    ctrls.forEach((ctrl) => {
      const ctrlId = ctrl.instanceId;
      const existingComp = oldRowComps[ctrlId];
      delete oldRowComps[ctrlId];
      const rowComp = existingComp ? existingComp : this.createBean(new HeaderRowComp(ctrl));
      this.headerRowComps[ctrlId] = rowComp;
      this.rowCompsList.push(rowComp);
      appendEnsuringDomOrder(rowComp);
    });
    Object.values(oldRowComps).forEach((c) => this.destroyRowComp(c));
  }
};
var GridHeaderElement = { tag: "div", cls: "ag-header", role: "presentation" };
var GridHeaderComp = class extends Component {
  constructor() {
    super(GridHeaderElement);
  }
  postConstruct() {
    const compProxy = {
      toggleCss: (cssClassName, on) => this.toggleCss(cssClassName, on),
      setHeightAndMinHeight: (height) => {
        this.getGui().style.height = height;
        this.getGui().style.minHeight = height;
      }
    };
    const ctrl = this.createManagedBean(new GridHeaderCtrl());
    ctrl.setComp(compProxy, this.getGui(), this.getFocusableElement());
    const addContainer = (container) => {
      this.createManagedBean(container);
      this.appendChild(container);
    };
    addContainer(new HeaderRowContainerComp("left"));
    addContainer(new HeaderRowContainerComp(null));
    addContainer(new HeaderRowContainerComp("right"));
  }
};
var GridHeaderSelector = {
  selector: "AG-HEADER-ROOT",
  component: GridHeaderComp
};
var CellComp = class extends Component {
  constructor(beans, cellCtrl, printLayout, eRow, editingCell) {
    super();
    this.cellCtrl = cellCtrl;
    this.rendererVersion = 0;
    this.editorVersion = 0;
    this.beans = beans;
    this.gos = beans.gos;
    this.column = cellCtrl.column;
    this.rowNode = cellCtrl.rowNode;
    this.eRow = eRow;
    const cellDiv = _createElement({
      tag: "div",
      role: cellCtrl.getCellAriaRole(),
      attrs: {
        "comp-id": `${this.getCompId()}`,
        "col-id": cellCtrl.column.colIdSanitised
      }
    });
    this.eCell = cellDiv;
    let wrapperDiv;
    if (cellCtrl.isCellSpanning()) {
      wrapperDiv = _createElement({
        tag: "div",
        cls: "ag-spanned-cell-wrapper",
        role: "presentation"
      });
      wrapperDiv.appendChild(cellDiv);
      this.setTemplateFromElement(wrapperDiv);
    } else {
      this.setTemplateFromElement(cellDiv);
    }
    this.cellCssManager = new CssClassManager(() => cellDiv);
    this.forceWrapper = cellCtrl.isForceWrapper();
    this.refreshWrapper(false);
    const compProxy = {
      toggleCss: (cssClassName, on) => this.cellCssManager.toggleCss(cssClassName, on),
      setUserStyles: (styles) => _addStylesToElement(cellDiv, styles),
      getFocusableElement: () => cellDiv,
      setIncludeSelection: (include) => this.includeSelection = include,
      setIncludeRowDrag: (include) => this.includeRowDrag = include,
      setIncludeDndSource: (include) => this.includeDndSource = include,
      setRenderDetails: (compDetails, valueToDisplay, force) => this.setRenderDetails(compDetails, valueToDisplay, force),
      setEditDetails: (compDetails, popup, position) => this.setEditDetails(compDetails, popup, position),
      getCellEditor: () => this.cellEditor || null,
      getCellRenderer: () => this.cellRenderer || null,
      getParentOfValue: () => this.getParentOfValue(),
      refreshEditStyles: (editing, isPopup) => this.refreshEditStyles(editing, isPopup)
    };
    cellCtrl.setComp(compProxy, cellDiv, wrapperDiv, this.eCellWrapper, printLayout, editingCell, void 0);
  }
  getParentOfValue() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.eCellValue) != null ? _a4 : this.eCellWrapper) != null ? _b2 : this.eCell;
  }
  setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance) {
    var _a4;
    const isInlineEditing = this.cellEditor && !this.cellEditorPopupWrapper;
    if (isInlineEditing) {
      return;
    }
    this.firstRender = this.firstRender == null;
    const controlWrapperChanged = this.refreshWrapper(false);
    this.refreshEditStyles(false);
    if (compDetails) {
      const neverRefresh = forceNewCellRendererInstance || controlWrapperChanged;
      const cellRendererRefreshSuccessful = neverRefresh ? false : this.refreshCellRenderer(compDetails);
      if (!cellRendererRefreshSuccessful) {
        this.destroyRenderer();
        this.createCellRendererInstance(compDetails);
      }
    } else {
      this.destroyRenderer();
      this.insertValueWithoutCellRenderer(valueToDisplay);
    }
    (_a4 = this.rowDraggingComp) == null ? void 0 : _a4.refreshVisibility();
  }
  setEditDetails(compDetails, popup, position) {
    if (compDetails) {
      this.createCellEditorInstance(compDetails, popup, position);
    } else {
      this.destroyEditor();
    }
  }
  removeControls() {
    const context = this.beans.context;
    this.checkboxSelectionComp = context.destroyBean(this.checkboxSelectionComp);
    this.dndSourceComp = context.destroyBean(this.dndSourceComp);
    this.rowDraggingComp = context.destroyBean(this.rowDraggingComp);
  }
  // returns true if wrapper was changed
  refreshWrapper(editing) {
    const providingControls = this.includeRowDrag || this.includeDndSource || this.includeSelection;
    const usingWrapper = providingControls || this.forceWrapper;
    const putWrapperIn = usingWrapper && this.eCellWrapper == null;
    if (putWrapperIn) {
      this.eCellWrapper = _createElement({ tag: "div", cls: "ag-cell-wrapper", role: "presentation" });
      this.eCell.appendChild(this.eCellWrapper);
    }
    const takeWrapperOut = !usingWrapper && this.eCellWrapper != null;
    if (takeWrapperOut) {
      _removeFromParent(this.eCellWrapper);
      this.eCellWrapper = void 0;
    }
    this.cellCssManager.toggleCss("ag-cell-value", !usingWrapper);
    const usingCellValue = !editing && usingWrapper;
    const putCellValueIn = usingCellValue && this.eCellValue == null;
    if (putCellValueIn) {
      this.eCellValue = _createElement({ tag: "span", cls: "ag-cell-value", role: "presentation" });
      this.eCellWrapper.appendChild(this.eCellValue);
    }
    const takeCellValueOut = !usingCellValue && this.eCellValue != null;
    if (takeCellValueOut) {
      _removeFromParent(this.eCellValue);
      this.eCellValue = void 0;
    }
    const templateChanged = putWrapperIn || takeWrapperOut || putCellValueIn || takeCellValueOut;
    if (templateChanged) {
      this.removeControls();
    }
    if (!editing && providingControls) {
      this.addControls();
    }
    return templateChanged;
  }
  addControls() {
    const { cellCtrl, eCellWrapper, eCellValue, includeRowDrag, includeDndSource, includeSelection } = this;
    const insertBefore = (comp) => {
      if (comp) {
        eCellWrapper.insertBefore(comp.getGui(), eCellValue);
      }
    };
    if (includeRowDrag && this.rowDraggingComp == null) {
      this.rowDraggingComp = cellCtrl.createRowDragComp();
      insertBefore(this.rowDraggingComp);
    }
    if (includeDndSource && this.dndSourceComp == null) {
      this.dndSourceComp = cellCtrl.createDndSource();
      insertBefore(this.dndSourceComp);
    }
    if (includeSelection && this.checkboxSelectionComp == null) {
      this.checkboxSelectionComp = cellCtrl.createSelectionCheckbox();
      insertBefore(this.checkboxSelectionComp);
    }
  }
  createCellEditorInstance(compDetails, popup, position) {
    const versionCopy = this.editorVersion;
    const cellEditorPromise = compDetails.newAgStackInstance();
    const { params } = compDetails;
    cellEditorPromise.then((c) => this.afterCellEditorCreated(versionCopy, c, params, popup, position));
    const cellEditorAsync = _missing(this.cellEditor);
    if (cellEditorAsync && params.cellStartedEdit) {
      this.cellCtrl.focusCell(true);
    }
  }
  insertValueWithoutCellRenderer(valueToDisplay) {
    const eParent = this.getParentOfValue();
    _clearElement(eParent);
    const escapedValue = _toString(valueToDisplay);
    if (escapedValue != null) {
      eParent.textContent = escapedValue;
    }
  }
  destroyRenderer() {
    const { context } = this.beans;
    this.cellRenderer = context.destroyBean(this.cellRenderer);
    _removeFromParent(this.cellRendererGui);
    this.cellRendererGui = null;
    this.rendererVersion++;
  }
  destroyEditor() {
    var _a4, _b2;
    const { context } = this.beans;
    const recoverFocus = ((_a4 = this.cellEditorPopupWrapper) == null ? void 0 : _a4.getGui().contains(_getActiveDomElement(this.beans))) || this.cellCtrl.hasBrowserFocus();
    if (recoverFocus) {
      this.eCell.focus({ preventScroll: true });
    }
    (_b2 = this.hideEditorPopup) == null ? void 0 : _b2.call(this);
    this.hideEditorPopup = void 0;
    this.cellEditor = context.destroyBean(this.cellEditor);
    this.cellEditorPopupWrapper = context.destroyBean(this.cellEditorPopupWrapper);
    _removeFromParent(this.cellEditorGui);
    this.cellCtrl.disableEditorTooltipFeature();
    this.cellEditorGui = null;
    this.editorVersion++;
  }
  refreshCellRenderer(compClassAndParams) {
    var _a4;
    if (((_a4 = this.cellRenderer) == null ? void 0 : _a4.refresh) == null) {
      return false;
    }
    if (this.cellRendererClass !== compClassAndParams.componentClass) {
      return false;
    }
    const result = this.cellRenderer.refresh(compClassAndParams.params);
    return result === true || result === void 0;
  }
  createCellRendererInstance(compDetails) {
    var _a4;
    const displayComponentVersionCopy = this.rendererVersion;
    const createCellRendererFunc = (details) => (_) => {
      const staleTask = this.rendererVersion !== displayComponentVersionCopy || !this.isAlive();
      if (staleTask) {
        return;
      }
      const componentPromise = details.newAgStackInstance();
      const callback = this.afterCellRendererCreated.bind(
        this,
        displayComponentVersionCopy,
        details.componentClass
      );
      componentPromise == null ? void 0 : componentPromise.then(callback);
    };
    const { animationFrameSvc } = this.beans;
    let createTask;
    if ((animationFrameSvc == null ? void 0 : animationFrameSvc.active) && this.firstRender) {
      createTask = (details, isDeferred = false) => {
        animationFrameSvc.createTask(
          createCellRendererFunc(details),
          this.rowNode.rowIndex,
          "p2",
          details.componentFromFramework,
          isDeferred
        );
      };
    } else {
      createTask = (details) => createCellRendererFunc(details)();
    }
    if (((_a4 = compDetails.params) == null ? void 0 : _a4.deferRender) && !this.cellCtrl.rowNode.group) {
      const { loadingComp, onReady } = this.cellCtrl.getDeferLoadingCellRenderer();
      if (loadingComp) {
        createTask(loadingComp);
        onReady.then(() => createTask(compDetails, true));
      }
    } else {
      createTask(compDetails);
    }
  }
  afterCellRendererCreated(cellRendererVersion, cellRendererClass, cellRenderer) {
    const staleTask = !this.isAlive() || cellRendererVersion !== this.rendererVersion;
    if (staleTask) {
      this.beans.context.destroyBean(cellRenderer);
      return;
    }
    this.cellRenderer = cellRenderer;
    this.cellRendererClass = cellRendererClass;
    const cellGui = cellRenderer.getGui();
    this.cellRendererGui = cellGui;
    if (cellGui != null) {
      const eParent = this.getParentOfValue();
      _clearElement(eParent);
      eParent.appendChild(cellGui);
    }
  }
  afterCellEditorCreated(requestVersion, cellEditor, params, popup, position) {
    var _a4;
    const staleComp = requestVersion !== this.editorVersion;
    const { context } = this.beans;
    if (staleComp) {
      context.destroyBean(cellEditor);
      return;
    }
    const editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();
    if (editingCancelledByUserComp) {
      context.destroyBean(cellEditor);
      this.cellCtrl.stopEditing(true);
      return;
    }
    if (!cellEditor.getGui) {
      _warn(97, { colId: this.column.getId() });
      context.destroyBean(cellEditor);
      return;
    }
    this.cellEditor = cellEditor;
    this.cellEditorGui = cellEditor.getGui();
    const cellEditorInPopup = popup || cellEditor.isPopup !== void 0 && cellEditor.isPopup();
    if (cellEditorInPopup) {
      this.addPopupCellEditor(params, position);
    } else {
      this.addInCellEditor();
    }
    this.refreshEditStyles(true, cellEditorInPopup);
    (_a4 = cellEditor.afterGuiAttached) == null ? void 0 : _a4.call(cellEditor);
    this.cellCtrl.enableEditorTooltipFeature(cellEditor);
    this.cellCtrl.cellEditorAttached();
  }
  refreshEditStyles(editing, isPopup) {
    const { cellCssManager } = this;
    cellCssManager.toggleCss("ag-cell-inline-editing", editing && !isPopup);
    cellCssManager.toggleCss("ag-cell-popup-editing", editing && !!isPopup);
    cellCssManager.toggleCss("ag-cell-not-inline-editing", !editing || !!isPopup);
  }
  addInCellEditor() {
    const { eCell } = this;
    if (eCell.contains(_getActiveDomElement(this.beans))) {
      eCell.focus();
    }
    this.destroyRenderer();
    this.refreshWrapper(true);
    _clearElement(this.getParentOfValue());
    if (this.cellEditorGui) {
      const eParent = this.getParentOfValue();
      eParent.appendChild(this.cellEditorGui);
    }
  }
  addPopupCellEditor(params, position) {
    var _a4, _b2;
    const { gos, context, popupSvc, editSvc } = this.beans;
    if (gos.get("editType") === "fullRow") {
      _warn(98);
    }
    const cellEditorPopupWrapper = this.cellEditorPopupWrapper = context.createBean(
      editSvc.createPopupEditorWrapper(params)
    );
    const { cellEditor, cellEditorGui, eCell, rowNode, column, cellCtrl } = this;
    const ePopupGui = cellEditorPopupWrapper.getGui();
    if (cellEditorGui) {
      ePopupGui.appendChild(cellEditorGui);
    }
    const useModelPopup = gos.get("stopEditingWhenCellsLoseFocus");
    const positionToUse = position != null ? position : (_b2 = (_a4 = cellEditor.getPopupPosition) == null ? void 0 : _a4.call(cellEditor)) != null ? _b2 : "over";
    const isRtl = gos.get("enableRtl");
    const positionParams = {
      ePopup: ePopupGui,
      column,
      rowNode,
      type: "popupCellEditor",
      eventSource: eCell,
      position: positionToUse,
      alignSide: isRtl ? "right" : "left",
      keepWithinBounds: true
    };
    const positionCallback = popupSvc.positionPopupByComponent.bind(popupSvc, positionParams);
    const addPopupRes = popupSvc.addPopup({
      modal: useModelPopup,
      eChild: ePopupGui,
      closeOnEsc: true,
      closedCallback: () => {
        cellCtrl.onPopupEditorClosed();
      },
      anchorToElement: eCell,
      positionCallback,
      ariaOwns: eCell
    });
    if (addPopupRes) {
      this.hideEditorPopup = addPopupRes.hideFunc;
    }
  }
  detach() {
    this.eRow.removeChild(this.getGui());
  }
  // if the row is also getting destroyed, then we don't need to remove from dom,
  // as the row will also get removed, so no need to take out the cells from the row
  // if the row is going (removing is an expensive operation, so only need to remove
  // the top part)
  //
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroy() {
    this.destroyRenderer();
    this.destroyEditor();
    this.removeControls();
    super.destroy();
  }
};
var RowComp = class extends Component {
  constructor(ctrl, beans, containerType) {
    super();
    this.cellComps = /* @__PURE__ */ new Map();
    this.beans = beans;
    this.rowCtrl = ctrl;
    const rowDiv = _createElement({ tag: "div", role: "row", attrs: { "comp-id": `${this.getCompId()}` } });
    this.setInitialStyle(rowDiv, containerType);
    this.setTemplateFromElement(rowDiv);
    const style = rowDiv.style;
    this.domOrder = this.rowCtrl.getDomOrder();
    const compProxy = {
      setDomOrder: (domOrder) => this.domOrder = domOrder,
      setCellCtrls: (cellCtrls) => this.setCellCtrls(cellCtrls),
      showFullWidth: (compDetails) => this.showFullWidth(compDetails),
      getFullWidthCellRenderer: () => this.fullWidthCellRenderer,
      getFullWidthCellRendererParams: () => this.fullWidthCellRendererParams,
      toggleCss: (name, on) => this.toggleCss(name, on),
      setUserStyles: (styles) => _addStylesToElement(rowDiv, styles),
      setTop: (top) => style.top = top,
      setTransform: (transform) => style.transform = transform,
      setRowIndex: (rowIndex) => rowDiv.setAttribute("row-index", rowIndex),
      setRowId: (rowId) => rowDiv.setAttribute("row-id", rowId),
      setRowBusinessKey: (businessKey) => rowDiv.setAttribute("row-business-key", businessKey),
      refreshFullWidth: (getUpdatedParams) => {
        var _a4, _b2, _c;
        const params = getUpdatedParams();
        this.fullWidthCellRendererParams = params;
        return (_c = (_b2 = (_a4 = this.fullWidthCellRenderer) == null ? void 0 : _a4.refresh) == null ? void 0 : _b2.call(_a4, params)) != null ? _c : false;
      }
    };
    ctrl.setComp(compProxy, this.getGui(), containerType, void 0);
    this.addDestroyFunc(() => {
      ctrl.unsetComp(containerType);
    });
  }
  setInitialStyle(container, containerType) {
    const transform = this.rowCtrl.getInitialTransform(containerType);
    if (transform) {
      container.style.setProperty("transform", transform);
    } else {
      const top = this.rowCtrl.getInitialRowTop(containerType);
      if (top) {
        container.style.setProperty("top", top);
      }
    }
  }
  showFullWidth(compDetails) {
    const callback = (cellRenderer) => {
      if (this.isAlive()) {
        const eGui = cellRenderer.getGui();
        this.getGui().appendChild(eGui);
        this.rowCtrl.setupDetailRowAutoHeight(eGui);
        this.setFullWidthRowComp(cellRenderer, compDetails.params);
      } else {
        this.beans.context.destroyBean(cellRenderer);
      }
    };
    const res = compDetails.newAgStackInstance();
    res.then(callback);
  }
  setCellCtrls(cellCtrls) {
    const cellsToRemove = new Map(this.cellComps);
    for (const cellCtrl of cellCtrls) {
      const key = cellCtrl.instanceId;
      if (!this.cellComps.has(key)) {
        this.newCellComp(cellCtrl);
      } else {
        cellsToRemove.delete(key);
      }
    }
    this.destroyCells(cellsToRemove);
    this.ensureDomOrder(cellCtrls);
  }
  ensureDomOrder(cellCtrls) {
    if (!this.domOrder) {
      return;
    }
    const elementsInOrder = [];
    for (const cellCtrl of cellCtrls) {
      const cellComp = this.cellComps.get(cellCtrl.instanceId);
      if (cellComp) {
        elementsInOrder.push(cellComp.getGui());
      }
    }
    _setDomChildOrder(this.getGui(), elementsInOrder);
  }
  newCellComp(cellCtrl) {
    var _a4, _b2;
    const editing = (_b2 = (_a4 = this.beans.editSvc) == null ? void 0 : _a4.isEditing(cellCtrl, { withOpenEditor: true })) != null ? _b2 : false;
    const cellComp = new CellComp(this.beans, cellCtrl, this.rowCtrl.printLayout, this.getGui(), editing);
    this.cellComps.set(cellCtrl.instanceId, cellComp);
    this.getGui().appendChild(cellComp.getGui());
  }
  destroy() {
    super.destroy();
    this.destroyCells(this.cellComps);
  }
  setFullWidthRowComp(fullWidthRowComponent, params) {
    this.fullWidthCellRenderer = fullWidthRowComponent;
    this.fullWidthCellRendererParams = params;
    this.addDestroyFunc(() => {
      this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
      this.fullWidthCellRendererParams = void 0;
    });
  }
  destroyCells(cellComps) {
    for (const cellComp of cellComps.values()) {
      if (!cellComp) {
        return;
      }
      const instanceId = cellComp.cellCtrl.instanceId;
      if (this.cellComps.get(instanceId) !== cellComp) {
        return;
      }
      cellComp.detach();
      cellComp.destroy();
      this.cellComps.delete(instanceId);
    }
  }
};
function getElementParams(name, options, beans) {
  const isCellSpanning = !!beans.gos.get("enableCellSpan") && !!options.getSpannedRowCtrls;
  const eContainerElement = {
    tag: "div",
    ref: "eContainer",
    cls: _getRowContainerClass(name),
    role: "rowgroup"
  };
  if (options.type === "center" || isCellSpanning) {
    const eSpannedContainerElement = {
      tag: "div",
      ref: "eSpannedContainer",
      cls: `ag-spanning-container ${_getRowSpanContainerClass(name)}`,
      role: "presentation"
    };
    eContainerElement.role = "presentation";
    return {
      tag: "div",
      ref: "eViewport",
      cls: `ag-viewport ${_getRowViewportClass(name)}`,
      role: "rowgroup",
      children: [eContainerElement, isCellSpanning ? eSpannedContainerElement : null]
    };
  }
  return eContainerElement;
}
var RowContainerComp = class extends Component {
  constructor(params) {
    super();
    this.eViewport = RefPlaceholder;
    this.eContainer = RefPlaceholder;
    this.eSpannedContainer = RefPlaceholder;
    this.rowCompsNoSpan = {};
    this.rowCompsWithSpan = {};
    this.name = params == null ? void 0 : params.name;
    this.options = _getRowContainerOptions(this.name);
  }
  postConstruct() {
    this.setTemplate(getElementParams(this.name, this.options, this.beans));
    const compProxy = {
      setHorizontalScroll: (offset) => this.eViewport.scrollLeft = offset,
      setViewportHeight: (height) => this.eViewport.style.height = height,
      setRowCtrls: ({ rowCtrls }) => this.setRowCtrls(rowCtrls),
      setSpannedRowCtrls: (rowCtrls) => this.setRowCtrls(rowCtrls, true),
      setDomOrder: (domOrder) => {
        this.domOrder = domOrder;
      },
      setContainerWidth: (width) => {
        this.eContainer.style.width = width;
        if (this.eSpannedContainer) {
          this.eSpannedContainer.style.width = width;
        }
      },
      setOffsetTop: (offset) => {
        const top = `translateY(${offset})`;
        this.eContainer.style.transform = top;
        if (this.eSpannedContainer) {
          this.eSpannedContainer.style.transform = top;
        }
      }
    };
    const ctrl = this.createManagedBean(new RowContainerCtrl(this.name));
    ctrl.setComp(compProxy, this.eContainer, this.eSpannedContainer, this.eViewport);
  }
  destroy() {
    this.setRowCtrls([]);
    this.setRowCtrls([], true);
    super.destroy();
    this.lastPlacedElement = null;
  }
  setRowCtrls(rowCtrls, spanContainer) {
    const { beans, options } = this;
    const container = spanContainer ? this.eSpannedContainer : this.eContainer;
    const oldRows = spanContainer ? { ...this.rowCompsWithSpan } : { ...this.rowCompsNoSpan };
    const newComps = {};
    if (spanContainer) {
      this.rowCompsWithSpan = newComps;
    } else {
      this.rowCompsNoSpan = newComps;
    }
    this.lastPlacedElement = null;
    const orderedRows = [];
    for (const rowCtrl of rowCtrls) {
      const instanceId = rowCtrl.instanceId;
      const existingRowComp = oldRows[instanceId];
      let rowComp;
      if (existingRowComp) {
        rowComp = existingRowComp;
        delete oldRows[instanceId];
      } else {
        if (!rowCtrl.rowNode.displayed) {
          continue;
        }
        rowComp = new RowComp(rowCtrl, beans, options.type);
      }
      newComps[instanceId] = rowComp;
      orderedRows.push([rowComp, !existingRowComp]);
    }
    this.removeOldRows(Object.values(oldRows), container);
    this.addRowNodes(orderedRows, container);
  }
  addRowNodes(rows, container) {
    const { domOrder } = this;
    for (const [rowComp, isNew] of rows) {
      const eGui = rowComp.getGui();
      if (!domOrder) {
        if (isNew) {
          container.appendChild(eGui);
        }
      } else {
        this.ensureDomOrder(eGui, container);
      }
    }
  }
  removeOldRows(rowComps, container) {
    for (const oldRowComp of rowComps) {
      container.removeChild(oldRowComp.getGui());
      oldRowComp.destroy();
    }
  }
  ensureDomOrder(eRow, container) {
    _ensureDomOrder(container, eRow, this.lastPlacedElement);
    this.lastPlacedElement = eRow;
  }
};
var RowContainerSelector = {
  selector: "AG-ROW-CONTAINER",
  component: RowContainerComp
};
function makeRowContainers(paramsMap, names) {
  return names.map((name) => {
    const refName = `e${name[0].toUpperCase() + name.substring(1)}RowContainer`;
    paramsMap[refName] = { name };
    return {
      tag: "ag-row-container",
      ref: refName,
      attrs: { name }
    };
  });
}
function getGridBodyTemplate(includeOverlay) {
  const paramsMap = {};
  const elementParams = {
    tag: "div",
    ref: "eGridRoot",
    cls: "ag-root ag-unselectable",
    children: [
      { tag: "ag-header-root" },
      {
        tag: "div",
        ref: "eTop",
        cls: "ag-floating-top",
        role: "presentation",
        children: makeRowContainers(paramsMap, ["topLeft", "topCenter", "topRight", "topFullWidth"])
      },
      {
        tag: "div",
        ref: "eBody",
        cls: "ag-body",
        role: "presentation",
        children: [
          {
            tag: "div",
            ref: "eBodyViewport",
            cls: "ag-body-viewport",
            role: "presentation",
            children: makeRowContainers(paramsMap, ["left", "center", "right", "fullWidth"])
          },
          { tag: "ag-fake-vertical-scroll" }
        ]
      },
      {
        tag: "div",
        ref: "eStickyTop",
        cls: "ag-sticky-top",
        role: "presentation",
        children: makeRowContainers(paramsMap, [
          "stickyTopLeft",
          "stickyTopCenter",
          "stickyTopRight",
          "stickyTopFullWidth"
        ])
      },
      {
        tag: "div",
        ref: "eStickyBottom",
        cls: "ag-sticky-bottom",
        role: "presentation",
        children: makeRowContainers(paramsMap, [
          "stickyBottomLeft",
          "stickyBottomCenter",
          "stickyBottomRight",
          "stickyBottomFullWidth"
        ])
      },
      {
        tag: "div",
        ref: "eBottom",
        cls: "ag-floating-bottom",
        role: "presentation",
        children: makeRowContainers(paramsMap, [
          "bottomLeft",
          "bottomCenter",
          "bottomRight",
          "bottomFullWidth"
        ])
      },
      { tag: "ag-fake-horizontal-scroll" },
      includeOverlay ? { tag: "ag-overlay-wrapper" } : null
    ]
  };
  return { paramsMap, elementParams };
}
var GridBodyComp = class extends Component {
  constructor() {
    super(...arguments);
    this.eGridRoot = RefPlaceholder;
    this.eBodyViewport = RefPlaceholder;
    this.eStickyTop = RefPlaceholder;
    this.eStickyBottom = RefPlaceholder;
    this.eTop = RefPlaceholder;
    this.eBottom = RefPlaceholder;
    this.eBody = RefPlaceholder;
  }
  postConstruct() {
    const { overlays, rangeSvc } = this.beans;
    const overlaySelector = overlays == null ? void 0 : overlays.getOverlayWrapperSelector();
    const { paramsMap, elementParams } = getGridBodyTemplate(!!overlaySelector);
    this.setTemplate(
      elementParams,
      [
        ...overlaySelector ? [overlaySelector] : [],
        FakeHScrollSelector,
        FakeVScrollSelector,
        GridHeaderSelector,
        RowContainerSelector
      ],
      paramsMap
    );
    const setHeight = (height, element) => {
      const heightString = `${height}px`;
      element.style.minHeight = heightString;
      element.style.height = heightString;
    };
    const compProxy = {
      setRowAnimationCssOnBodyViewport: (cssClass, animate) => this.setRowAnimationCssOnBodyViewport(cssClass, animate),
      setColumnCount: (count) => _setAriaColCount(this.getGui(), count),
      setRowCount: (count) => _setAriaRowCount(this.getGui(), count),
      setTopHeight: (height) => setHeight(height, this.eTop),
      setBottomHeight: (height) => setHeight(height, this.eBottom),
      setTopInvisible: (invisible) => this.eTop.classList.toggle("ag-invisible", invisible),
      setBottomInvisible: (invisible) => this.eBottom.classList.toggle("ag-invisible", invisible),
      setStickyTopHeight: (height) => this.eStickyTop.style.height = height,
      setStickyTopTop: (top) => this.eStickyTop.style.top = top,
      setStickyTopWidth: (width) => this.eStickyTop.style.width = width,
      setStickyBottomHeight: (height) => {
        this.eStickyBottom.style.height = height;
        this.eStickyBottom.classList.toggle("ag-invisible", height === "0px");
      },
      setStickyBottomBottom: (bottom) => this.eStickyBottom.style.bottom = bottom,
      setStickyBottomWidth: (width) => this.eStickyBottom.style.width = width,
      setColumnMovingCss: (cssClass, flag) => this.toggleCss(cssClass, flag),
      updateLayoutClasses: (cssClass, params) => {
        const classLists = [this.eBodyViewport.classList, this.eBody.classList];
        for (const classList of classLists) {
          classList.toggle(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
          classList.toggle(LayoutCssClasses.NORMAL, params.normal);
          classList.toggle(LayoutCssClasses.PRINT, params.print);
        }
        this.toggleCss(LayoutCssClasses.AUTO_HEIGHT, params.autoHeight);
        this.toggleCss(LayoutCssClasses.NORMAL, params.normal);
        this.toggleCss(LayoutCssClasses.PRINT, params.print);
      },
      setAlwaysVerticalScrollClass: (cssClass, on) => this.eBodyViewport.classList.toggle(CSS_CLASS_FORCE_VERTICAL_SCROLL, on),
      registerBodyViewportResizeListener: (listener) => {
        const unsubscribeFromResize = _observeResize(this.beans, this.eBodyViewport, listener);
        this.addDestroyFunc(() => unsubscribeFromResize());
      },
      setPinnedTopBottomOverflowY: (overflow) => this.eTop.style.overflowY = this.eBottom.style.overflowY = overflow,
      setCellSelectableCss: (cssClass, selectable) => {
        [this.eTop, this.eBodyViewport, this.eBottom].forEach(
          (ct) => ct.classList.toggle(cssClass, selectable)
        );
      },
      setBodyViewportWidth: (width) => this.eBodyViewport.style.width = width,
      setGridRootRole: (role) => _setAriaRole(this.eGridRoot, role)
    };
    this.ctrl = this.createManagedBean(new GridBodyCtrl());
    this.ctrl.setComp(
      compProxy,
      this.getGui(),
      this.eBodyViewport,
      this.eTop,
      this.eBottom,
      this.eStickyTop,
      this.eStickyBottom
    );
    if (rangeSvc && _isCellSelectionEnabled(this.gos) || _isMultiRowSelection(this.gos)) {
      _setAriaMultiSelectable(this.getGui(), true);
    }
  }
  setRowAnimationCssOnBodyViewport(cssClass, animateRows) {
    const bodyViewportClassList = this.eBodyViewport.classList;
    bodyViewportClassList.toggle("ag-row-animation", animateRows);
    bodyViewportClassList.toggle("ag-row-no-animation", !animateRows);
  }
};
var GridBodySelector = {
  selector: "AG-GRID-BODY",
  component: GridBodyComp
};
var GridCtrl = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.additionalFocusableContainers = /* @__PURE__ */ new Set();
  }
  setComp(view, eGridDiv, eGui) {
    this.view = view;
    this.eGridHostDiv = eGridDiv;
    this.eGui = eGui;
    this.eGui.setAttribute("grid-id", this.beans.context.getId());
    const { dragAndDrop, ctrlsSvc } = this.beans;
    dragAndDrop == null ? void 0 : dragAndDrop.registerGridDropTarget(() => this.eGui, this);
    this.createManagedBean(new LayoutFeature(this.view));
    this.view.setRtlClass(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr");
    const unsubscribeFromResize = _observeResize(this.beans, this.eGridHostDiv, this.onGridSizeChanged.bind(this));
    this.addDestroyFunc(() => unsubscribeFromResize());
    ctrlsSvc.register("gridCtrl", this);
  }
  isDetailGrid() {
    var _a4;
    const el = _findTabbableParent(this.getGui());
    return ((_a4 = el == null ? void 0 : el.getAttribute("row-id")) == null ? void 0 : _a4.startsWith("detail")) || false;
  }
  getOptionalSelectors() {
    var _a4, _b2, _c, _d, _e;
    const beans = this.beans;
    return {
      paginationSelector: (_a4 = beans.pagination) == null ? void 0 : _a4.getPaginationSelector(),
      gridHeaderDropZonesSelector: (_b2 = beans.registry) == null ? void 0 : _b2.getSelector("AG-GRID-HEADER-DROP-ZONES"),
      sideBarSelector: (_c = beans.sideBar) == null ? void 0 : _c.getSelector(),
      statusBarSelector: (_d = beans.registry) == null ? void 0 : _d.getSelector("AG-STATUS-BAR"),
      watermarkSelector: (_e = beans.licenseManager) == null ? void 0 : _e.getWatermarkSelector()
    };
  }
  onGridSizeChanged() {
    this.eventSvc.dispatchEvent({
      type: "gridSizeChanged",
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    });
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(direction) {
    const { view } = this;
    if (direction === false) {
      view.setCursor(null);
    } else {
      const cursor = direction === 1 ? "ew-resize" : "ns-resize";
      view.setCursor(cursor);
    }
  }
  disableUserSelect(on) {
    this.view.setUserSelect(on ? "none" : null);
  }
  focusNextInnerContainer(backwards) {
    const focusableContainers = this.getFocusableContainers();
    const { indexWithFocus, nextIndex } = this.getNextFocusableIndex(focusableContainers, backwards);
    if (nextIndex < 0 || nextIndex >= focusableContainers.length) {
      return false;
    }
    if (nextIndex === 0) {
      if (indexWithFocus > 0) {
        const { visibleCols, focusSvc } = this.beans;
        const allColumns = visibleCols.allCols;
        const lastColumn = _last(allColumns);
        if (focusSvc.focusGridView({ column: lastColumn, backwards: true })) {
          return true;
        }
      }
      return false;
    }
    return this.focusContainer(focusableContainers[nextIndex], backwards);
  }
  focusInnerElement(fromBottom) {
    const userCallbackFunction = this.gos.getCallback("focusGridInnerElement");
    if (userCallbackFunction && userCallbackFunction({ fromBottom: !!fromBottom })) {
      return true;
    }
    const focusableContainers = this.getFocusableContainers();
    const { focusSvc, visibleCols } = this.beans;
    const allColumns = visibleCols.allCols;
    if (fromBottom) {
      if (focusableContainers.length > 1) {
        return this.focusContainer(_last(focusableContainers), fromBottom);
      }
      const lastColumn = _last(allColumns);
      if (focusSvc.focusGridView({ column: lastColumn, backwards: fromBottom })) {
        return true;
      }
    }
    if (this.gos.get("headerHeight") === 0 || _isHeaderFocusSuppressed(this.beans)) {
      if (focusSvc.focusGridView({ column: allColumns[0], backwards: fromBottom })) {
        return true;
      }
      for (let i = 1; i < focusableContainers.length; i++) {
        if (_focusInto(focusableContainers[i].getGui(), fromBottom)) {
          return true;
        }
      }
      return false;
    }
    return focusSvc.focusFirstHeader();
  }
  forceFocusOutOfContainer(up = false) {
    this.view.forceFocusOutOfContainer(up);
  }
  addFocusableContainer(container) {
    this.additionalFocusableContainers.add(container);
  }
  removeFocusableContainer(container) {
    this.additionalFocusableContainers.delete(container);
  }
  allowFocusForNextCoreContainer(up) {
    var _a4;
    const coreContainers = this.view.getFocusableContainers();
    const { nextIndex, indexWithFocus } = this.getNextFocusableIndex(coreContainers, up);
    if (indexWithFocus === -1 || nextIndex < 0 || nextIndex >= coreContainers.length) {
      return;
    }
    const comp = coreContainers[nextIndex];
    (_a4 = comp.setAllowFocus) == null ? void 0 : _a4.call(comp, true);
    setTimeout(() => {
      var _a5;
      (_a5 = comp.setAllowFocus) == null ? void 0 : _a5.call(comp, false);
    });
  }
  isFocusable() {
    var _a4, _b2;
    const beans = this.beans;
    return !_isCellFocusSuppressed(beans) || !_isHeaderFocusSuppressed(beans) || !!((_b2 = (_a4 = beans.sideBar) == null ? void 0 : _a4.comp) == null ? void 0 : _b2.isDisplayed());
  }
  getNextFocusableIndex(focusableContainers, backwards) {
    const activeEl = _getActiveDomElement(this.beans);
    const indexWithFocus = focusableContainers.findIndex((container) => container.getGui().contains(activeEl));
    const nextIndex = indexWithFocus + (backwards ? -1 : 1);
    return {
      indexWithFocus,
      nextIndex
    };
  }
  focusContainer(comp, up) {
    var _a4, _b2;
    (_a4 = comp.setAllowFocus) == null ? void 0 : _a4.call(comp, true);
    const result = _focusInto(comp.getGui(), up, false, true);
    (_b2 = comp.setAllowFocus) == null ? void 0 : _b2.call(comp, false);
    return result;
  }
  getFocusableContainers() {
    return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers];
  }
  destroy() {
    this.additionalFocusableContainers.clear();
    super.destroy();
  }
};
var GridComp = class extends TabGuardComp {
  constructor(eGridDiv) {
    super();
    this.gridBody = RefPlaceholder;
    this.sideBar = RefPlaceholder;
    this.pagination = RefPlaceholder;
    this.rootWrapperBody = RefPlaceholder;
    this.eGridDiv = eGridDiv;
  }
  postConstruct() {
    const compProxy = {
      destroyGridUi: () => this.destroyBean(this),
      setRtlClass: (cssClass) => this.addCss(cssClass),
      forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
      updateLayoutClasses: this.updateLayoutClasses.bind(this),
      getFocusableContainers: this.getFocusableContainers.bind(this),
      setUserSelect: (value) => {
        this.getGui().style.userSelect = value != null ? value : "";
        this.getGui().style.webkitUserSelect = value != null ? value : "";
      },
      setCursor: (value) => {
        this.getGui().style.cursor = value != null ? value : "";
      }
    };
    const ctrl = this.createManagedBean(new GridCtrl());
    const comps = ctrl.getOptionalSelectors();
    const template = this.createTemplate(comps);
    const requiredComps = [GridBodySelector, ...Object.values(comps).filter((c) => !!c)];
    this.setTemplate(template, requiredComps);
    ctrl.setComp(compProxy, this.eGridDiv, this.getGui());
    this.insertGridIntoDom();
    this.initialiseTabGuard({
      // we want to override the default behaviour to do nothing for onTabKeyDown
      onTabKeyDown: () => void 0,
      focusInnerElement: (fromBottom) => ctrl.focusInnerElement(fromBottom),
      forceFocusOutWhenTabGuardsAreEmpty: true,
      isEmpty: () => !ctrl.isFocusable()
    });
  }
  insertGridIntoDom() {
    const eGui = this.getGui();
    this.eGridDiv.appendChild(eGui);
    this.addDestroyFunc(() => {
      this.eGridDiv.removeChild(eGui);
      _logIfDebug(this.gos, "Grid removed from DOM");
    });
  }
  updateLayoutClasses(cssClass, params) {
    const eRootWrapperBodyClassList = this.rootWrapperBody.classList;
    const { AUTO_HEIGHT, NORMAL, PRINT } = LayoutCssClasses;
    const { autoHeight, normal, print } = params;
    eRootWrapperBodyClassList.toggle(AUTO_HEIGHT, autoHeight);
    eRootWrapperBodyClassList.toggle(NORMAL, normal);
    eRootWrapperBodyClassList.toggle(PRINT, print);
    this.toggleCss(AUTO_HEIGHT, autoHeight);
    this.toggleCss(NORMAL, normal);
    this.toggleCss(PRINT, print);
  }
  createTemplate(params) {
    const dropZones = params.gridHeaderDropZonesSelector ? { tag: "ag-grid-header-drop-zones" } : null;
    const sideBar = params.sideBarSelector ? {
      tag: "ag-side-bar",
      ref: "sideBar"
    } : null;
    const statusBar = params.statusBarSelector ? { tag: "ag-status-bar" } : null;
    const watermark = params.watermarkSelector ? { tag: "ag-watermark" } : null;
    const pagination = params.paginationSelector ? { tag: "ag-pagination", ref: "pagination" } : null;
    return {
      tag: "div",
      cls: "ag-root-wrapper",
      role: "presentation",
      children: [
        dropZones,
        {
          tag: "div",
          ref: "rootWrapperBody",
          cls: "ag-root-wrapper-body",
          role: "presentation",
          children: [{ tag: "ag-grid-body", ref: "gridBody" }, sideBar]
        },
        statusBar,
        pagination,
        watermark
      ]
    };
  }
  getFocusableElement() {
    return this.rootWrapperBody;
  }
  forceFocusOutOfContainer(up = false) {
    var _a4;
    if (!up && ((_a4 = this.pagination) == null ? void 0 : _a4.isDisplayed())) {
      this.pagination.forceFocusOutOfContainer(up);
      return;
    }
    super.forceFocusOutOfContainer(up);
  }
  getFocusableContainers() {
    const focusableContainers = [this.gridBody];
    [this.sideBar, this.pagination].forEach((comp) => {
      if (comp) {
        focusableContainers.push(comp);
      }
    });
    return focusableContainers.filter((el) => _isVisible(el.getGui()));
  }
};
var mod = (moduleName, input) => {
  for (const key of Object.keys(input)) {
    input[key] = moduleName;
  }
  return input;
};
var gridApiFunctionsMap = {
  dispatchEvent: "CommunityCore",
  // this is always registered
  ...mod("CommunityCore", {
    destroy: 0,
    getGridId: 0,
    getGridOption: 0,
    isDestroyed: 0,
    setGridOption: 0,
    updateGridOptions: 0,
    isModuleRegistered: 0
  }),
  ...mod("GridState", {
    getState: 0,
    setState: 0
  }),
  ...mod("SharedRowSelection", {
    setNodesSelected: 0,
    selectAll: 0,
    deselectAll: 0,
    selectAllFiltered: 0,
    deselectAllFiltered: 0,
    selectAllOnCurrentPage: 0,
    deselectAllOnCurrentPage: 0,
    getSelectedNodes: 0,
    getSelectedRows: 0
  }),
  ...mod("RowApi", {
    redrawRows: 0,
    setRowNodeExpanded: 0,
    getRowNode: 0,
    addRenderedRowListener: 0,
    getRenderedNodes: 0,
    forEachNode: 0,
    getFirstDisplayedRowIndex: 0,
    getLastDisplayedRowIndex: 0,
    getDisplayedRowAtIndex: 0,
    getDisplayedRowCount: 0
  }),
  ...mod("ScrollApi", {
    getVerticalPixelRange: 0,
    getHorizontalPixelRange: 0,
    ensureColumnVisible: 0,
    ensureIndexVisible: 0,
    ensureNodeVisible: 0
  }),
  ...mod("KeyboardNavigation", {
    getFocusedCell: 0,
    clearFocusedCell: 0,
    setFocusedCell: 0,
    tabToNextCell: 0,
    tabToPreviousCell: 0,
    setFocusedHeader: 0
  }),
  ...mod("EventApi", {
    addEventListener: 0,
    addGlobalListener: 0,
    removeEventListener: 0,
    removeGlobalListener: 0
  }),
  ...mod("ValueCache", {
    expireValueCache: 0
  }),
  ...mod("CellApi", {
    getCellValue: 0
  }),
  ...mod("SharedMenu", {
    showColumnMenu: 0,
    hidePopupMenu: 0
  }),
  ...mod("Sort", {
    onSortChanged: 0
  }),
  ...mod("PinnedRow", {
    getPinnedTopRowCount: 0,
    getPinnedBottomRowCount: 0,
    getPinnedTopRow: 0,
    getPinnedBottomRow: 0,
    forEachPinnedRow: 0
  }),
  ...mod("Overlay", {
    showLoadingOverlay: 0,
    showNoRowsOverlay: 0,
    hideOverlay: 0
  }),
  ...mod("RenderApi", {
    setGridAriaProperty: 0,
    refreshCells: 0,
    refreshHeader: 0,
    isAnimationFrameQueueEmpty: 0,
    flushAllAnimationFrames: 0,
    getSizesForCurrentTheme: 0,
    getCellRendererInstances: 0
  }),
  ...mod("HighlightChanges", {
    flashCells: 0
  }),
  ...mod("RowDrag", {
    addRowDropZone: 0,
    removeRowDropZone: 0,
    getRowDropZoneParams: 0,
    getRowDropPositionIndicator: 0,
    setRowDropPositionIndicator: 0
  }),
  ...mod("ColumnApi", {
    getColumnDefs: 0,
    getColumnDef: 0,
    getDisplayNameForColumn: 0,
    getColumn: 0,
    getColumns: 0,
    applyColumnState: 0,
    getColumnState: 0,
    resetColumnState: 0,
    isPinning: 0,
    isPinningLeft: 0,
    isPinningRight: 0,
    getDisplayedColAfter: 0,
    getDisplayedColBefore: 0,
    setColumnsVisible: 0,
    setColumnsPinned: 0,
    getAllGridColumns: 0,
    getDisplayedLeftColumns: 0,
    getDisplayedCenterColumns: 0,
    getDisplayedRightColumns: 0,
    getAllDisplayedColumns: 0,
    getAllDisplayedVirtualColumns: 0
  }),
  ...mod("ColumnAutoSize", {
    sizeColumnsToFit: 0,
    autoSizeColumns: 0,
    autoSizeAllColumns: 0
  }),
  ...mod("ColumnGroup", {
    setColumnGroupOpened: 0,
    getColumnGroup: 0,
    getProvidedColumnGroup: 0,
    getDisplayNameForColumnGroup: 0,
    getColumnGroupState: 0,
    setColumnGroupState: 0,
    resetColumnGroupState: 0,
    getLeftDisplayedColumnGroups: 0,
    getCenterDisplayedColumnGroups: 0,
    getRightDisplayedColumnGroups: 0,
    getAllDisplayedColumnGroups: 0
  }),
  ...mod("ColumnMove", {
    moveColumnByIndex: 0,
    moveColumns: 0
  }),
  ...mod("ColumnResize", {
    setColumnWidths: 0
  }),
  ...mod("ColumnHover", {
    isColumnHovered: 0
  }),
  ...mod("EditCore", {
    getCellEditorInstances: 0,
    getEditingCells: 0,
    getEditRowValues: 0,
    stopEditing: 0,
    startEditingCell: 0,
    isEditing: 0,
    validateEdit: 0
  }),
  ...mod("BatchEdit", {
    startBatchEdit: 0,
    cancelBatchEdit: 0,
    commitBatchEdit: 0,
    isBatchEditing: 0
  }),
  ...mod("UndoRedoEdit", {
    undoCellEditing: 0,
    redoCellEditing: 0,
    getCurrentUndoSize: 0,
    getCurrentRedoSize: 0
  }),
  ...mod("FilterCore", {
    isAnyFilterPresent: 0,
    onFilterChanged: 0
  }),
  ...mod("ColumnFilter", {
    isColumnFilterPresent: 0,
    getColumnFilterInstance: 0,
    destroyFilter: 0,
    setFilterModel: 0,
    getFilterModel: 0,
    getColumnFilterModel: 0,
    setColumnFilterModel: 0,
    showColumnFilter: 0,
    hideColumnFilter: 0,
    getColumnFilterHandler: 0,
    doFilterAction: 0
  }),
  ...mod("QuickFilter", {
    isQuickFilterPresent: 0,
    getQuickFilter: 0,
    resetQuickFilter: 0
  }),
  ...mod("Find", {
    findGetActiveMatch: 0,
    findGetTotalMatches: 0,
    findGoTo: 0,
    findNext: 0,
    findPrevious: 0,
    findGetNumMatches: 0,
    findGetParts: 0,
    findClearActive: 0,
    findRefresh: 0
  }),
  ...mod("Pagination", {
    paginationIsLastPageFound: 0,
    paginationGetPageSize: 0,
    paginationGetCurrentPage: 0,
    paginationGetTotalPages: 0,
    paginationGetRowCount: 0,
    paginationGoToNextPage: 0,
    paginationGoToPreviousPage: 0,
    paginationGoToFirstPage: 0,
    paginationGoToLastPage: 0,
    paginationGoToPage: 0
  }),
  ...mod("CsrmSsrmSharedApi", {
    expandAll: 0,
    collapseAll: 0
  }),
  ...mod("SsrmInfiniteSharedApi", {
    setRowCount: 0,
    getCacheBlockState: 0,
    isLastRowIndexKnown: 0
  }),
  ...mod("ClientSideRowModelApi", {
    onGroupExpandedOrCollapsed: 0,
    refreshClientSideRowModel: 0,
    isRowDataEmpty: 0,
    forEachLeafNode: 0,
    forEachNodeAfterFilter: 0,
    forEachNodeAfterFilterAndSort: 0,
    applyTransaction: 0,
    applyTransactionAsync: 0,
    flushAsyncTransactions: 0,
    getBestCostNodeSelection: 0,
    onRowHeightChanged: 0,
    resetRowHeights: 0
  }),
  ...mod("CsvExport", {
    getDataAsCsv: 0,
    exportDataAsCsv: 0
  }),
  ...mod("InfiniteRowModel", {
    refreshInfiniteCache: 0,
    purgeInfiniteCache: 0,
    getInfiniteRowCount: 0
  }),
  ...mod("AdvancedFilter", {
    getAdvancedFilterModel: 0,
    setAdvancedFilterModel: 0,
    showAdvancedFilterBuilder: 0,
    hideAdvancedFilterBuilder: 0
  }),
  ...mod("IntegratedCharts", {
    getChartModels: 0,
    getChartRef: 0,
    getChartImageDataURL: 0,
    downloadChart: 0,
    openChartToolPanel: 0,
    closeChartToolPanel: 0,
    createRangeChart: 0,
    createPivotChart: 0,
    createCrossFilterChart: 0,
    updateChart: 0,
    restoreChart: 0
  }),
  ...mod("Clipboard", {
    copyToClipboard: 0,
    cutToClipboard: 0,
    copySelectedRowsToClipboard: 0,
    copySelectedRangeToClipboard: 0,
    copySelectedRangeDown: 0,
    pasteFromClipboard: 0
  }),
  ...mod("ExcelExport", {
    getDataAsExcel: 0,
    exportDataAsExcel: 0,
    getSheetDataForExcel: 0,
    getMultipleSheetsAsExcel: 0,
    exportMultipleSheetsAsExcel: 0
  }),
  ...mod("SharedMasterDetail", {
    addDetailGridInfo: 0,
    removeDetailGridInfo: 0,
    getDetailGridInfo: 0,
    forEachDetailGridInfo: 0
  }),
  ...mod("ContextMenu", {
    showContextMenu: 0
  }),
  ...mod("ColumnMenu", {
    showColumnChooser: 0,
    hideColumnChooser: 0
  }),
  ...mod("CellSelection", {
    getCellRanges: 0,
    addCellRange: 0,
    clearRangeSelection: 0,
    clearCellSelection: 0
  }),
  ...mod("SharedRowGrouping", {
    setRowGroupColumns: 0,
    removeRowGroupColumns: 0,
    addRowGroupColumns: 0,
    getRowGroupColumns: 0,
    moveRowGroupColumn: 0
  }),
  ...mod("SharedAggregation", {
    addAggFuncs: 0,
    clearAggFuncs: 0,
    setColumnAggFunc: 0
  }),
  ...mod("SharedPivot", {
    isPivotMode: 0,
    getPivotResultColumn: 0,
    setValueColumns: 0,
    getValueColumns: 0,
    removeValueColumns: 0,
    addValueColumns: 0,
    setPivotColumns: 0,
    removePivotColumns: 0,
    addPivotColumns: 0,
    getPivotColumns: 0,
    setPivotResultColumns: 0,
    getPivotResultColumns: 0
  }),
  ...mod("ServerSideRowModelApi", {
    getServerSideSelectionState: 0,
    setServerSideSelectionState: 0,
    applyServerSideTransaction: 0,
    applyServerSideTransactionAsync: 0,
    applyServerSideRowData: 0,
    retryServerSideLoads: 0,
    flushServerSideAsyncTransactions: 0,
    refreshServerSide: 0,
    getServerSideGroupLevelState: 0,
    onRowHeightChanged: 0,
    resetRowHeights: 0
  }),
  ...mod("SideBar", {
    isSideBarVisible: 0,
    setSideBarVisible: 0,
    setSideBarPosition: 0,
    openToolPanel: 0,
    closeToolPanel: 0,
    getOpenedToolPanel: 0,
    refreshToolPanel: 0,
    isToolPanelShowing: 0,
    getToolPanelInstance: 0,
    getSideBar: 0
  }),
  ...mod("StatusBar", {
    getStatusPanel: 0
  })
};
var defaultFns = {
  isDestroyed: () => true,
  destroy() {
  },
  preConstruct() {
  },
  postConstruct() {
  },
  preWireBeans() {
  },
  wireBeans() {
  }
};
var dispatchEvent = (beans, event) => beans.eventSvc.dispatchEvent(event);
var GridApiClass = class {
};
Reflect.defineProperty(GridApiClass, "name", { value: "GridApi" });
var ApiFunctionService = class extends BeanStub {
  constructor() {
    super();
    this.beanName = "apiFunctionSvc";
    this.api = new GridApiClass();
    this.fns = {
      ...defaultFns,
      // dispatchEvent is used by frameworks, also used by aligned grids to identify a grid api instance
      dispatchEvent
    };
    this.preDestroyLink = "";
    const { api } = this;
    for (const key of Object.keys(gridApiFunctionsMap)) {
      api[key] = this.makeApi(key)[key];
    }
  }
  postConstruct() {
    this.preDestroyLink = this.beans.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
  }
  addFunction(functionName, func) {
    var _a4, _b2;
    const { fns, beans } = this;
    if (fns !== defaultFns) {
      fns[functionName] = (_b2 = (_a4 = beans == null ? void 0 : beans.validation) == null ? void 0 : _a4.validateApiFunction(functionName, func)) != null ? _b2 : func;
    }
  }
  makeApi(apiName) {
    return {
      [apiName]: (...args) => {
        const {
          beans,
          fns: { [apiName]: fn }
        } = this;
        return fn ? fn(beans, ...args) : this.apiNotFound(apiName);
      }
    };
  }
  apiNotFound(fnName) {
    const { beans, gos, preDestroyLink } = this;
    if (!beans) {
      _warn(26, { fnName, preDestroyLink });
    } else {
      const module2 = gridApiFunctionsMap[fnName];
      if (gos.assertModuleRegistered(module2, `api.${fnName}`)) {
        _warn(27, { fnName, module: module2 });
      }
    }
  }
  destroy() {
    super.destroy();
    this.fns = defaultFns;
    this.beans = null;
  }
};
function getGridId(beans) {
  return beans.context.getId();
}
function destroy(beans) {
  beans.gridDestroySvc.destroy();
}
function isDestroyed(beans) {
  return beans.gridDestroySvc.destroyCalled;
}
function getGridOption(beans, key) {
  return beans.gos.get(key);
}
function setGridOption(beans, key, value) {
  updateGridOptions(beans, { [key]: value });
}
function updateGridOptions(beans, options) {
  beans.gos.updateGridOptions({ options });
}
function isModuleRegistered(beans, moduleName) {
  const withoutSuffix = moduleName.replace(/Module$/, "");
  return beans.gos.isModuleRegistered(withoutSuffix);
}
var DragService = class extends BaseDragService {
  shouldPreventMouseEvent(mouseEvent) {
    const isEnableCellTextSelect = this.gos.get("enableCellTextSelection");
    return isEnableCellTextSelect && super.shouldPreventMouseEvent(mouseEvent);
  }
};
var HorizontalResizeService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "horizontalResizeSvc";
  }
  addResizeBar(params) {
    const dragSource = {
      dragStartPixels: params.dragStartPixels || 0,
      eElement: params.eResizeBar,
      onDragStart: this.onDragStart.bind(this, params),
      onDragStop: this.onDragStop.bind(this, params),
      onDragging: this.onDragging.bind(this, params),
      onDragCancel: this.onDragStop.bind(this, params),
      includeTouch: true,
      stopPropagationForTouch: true
    };
    const { dragSvc } = this.beans;
    dragSvc.addDragSource(dragSource);
    const finishedWithResizeFunc = () => dragSvc.removeDragSource(dragSource);
    return finishedWithResizeFunc;
  }
  onDragStart(params, mouseEvent) {
    this.dragStartX = mouseEvent.clientX;
    this.setResizeIcons();
    const shiftKey = mouseEvent instanceof MouseEvent && mouseEvent.shiftKey === true;
    params.onResizeStart(shiftKey);
  }
  setResizeIcons() {
    const ctrl = this.beans.ctrlsSvc.get("gridCtrl");
    ctrl.setResizeCursor(
      1
      /* Horizontal */
    );
    ctrl.disableUserSelect(true);
  }
  onDragStop(params) {
    params.onResizeEnd(this.resizeAmount);
    this.resetIcons();
  }
  resetIcons() {
    const ctrl = this.beans.ctrlsSvc.get("gridCtrl");
    ctrl.setResizeCursor(false);
    ctrl.disableUserSelect(false);
  }
  onDragging(params, mouseEvent) {
    this.resizeAmount = mouseEvent.clientX - this.dragStartX;
    params.onResizing(this.resizeAmount);
  }
};
function _areCellsEqual(cellA, cellB) {
  const colsMatch = cellA.column === cellB.column;
  const floatingMatch = cellA.rowPinned === cellB.rowPinned;
  const indexMatch = cellA.rowIndex === cellB.rowIndex;
  return colsMatch && floatingMatch && indexMatch;
}
function _isRowBefore(rowA, rowB) {
  switch (rowA.rowPinned) {
    case "top":
      if (rowB.rowPinned !== "top") {
        return true;
      }
      break;
    case "bottom":
      if (rowB.rowPinned !== "bottom") {
        return false;
      }
      break;
    default:
      if (_exists(rowB.rowPinned)) {
        return rowB.rowPinned !== "top";
      }
      break;
  }
  return rowA.rowIndex < rowB.rowIndex;
}
function _getFirstRow(beans) {
  let rowIndex = 0;
  let rowPinned;
  const { pinnedRowModel, rowModel, pageBounds } = beans;
  if (pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedTopRowCount()) {
    rowPinned = "top";
  } else if (rowModel.getRowCount()) {
    rowPinned = null;
    rowIndex = pageBounds.getFirstRow();
  } else if (pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedBottomRowCount()) {
    rowPinned = "bottom";
  }
  return rowPinned === void 0 ? null : { rowIndex, rowPinned };
}
function _getLastRow(beans) {
  let rowIndex;
  let rowPinned = null;
  const { pinnedRowModel, pageBounds } = beans;
  const pinnedBottomCount = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedBottomRowCount();
  const pinnedTopCount = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedTopRowCount();
  if (pinnedBottomCount) {
    rowPinned = "bottom";
    rowIndex = pinnedBottomCount - 1;
  } else if (beans.rowModel.getRowCount()) {
    rowPinned = null;
    rowIndex = pageBounds.getLastRow();
  } else if (pinnedTopCount) {
    rowPinned = "top";
    rowIndex = pinnedTopCount - 1;
  }
  return rowIndex === void 0 ? null : { rowIndex, rowPinned };
}
function _getRowNode(beans, gridRow) {
  var _a4, _b2;
  switch (gridRow.rowPinned) {
    case "top":
      return (_a4 = beans.pinnedRowModel) == null ? void 0 : _a4.getPinnedTopRow(gridRow.rowIndex);
    case "bottom":
      return (_b2 = beans.pinnedRowModel) == null ? void 0 : _b2.getPinnedBottomRow(gridRow.rowIndex);
    default:
      return beans.rowModel.getRow(gridRow.rowIndex);
  }
}
function _getCellByPosition(beans, cellPosition) {
  var _a4;
  const spannedCellCtrl = (_a4 = beans.spannedRowRenderer) == null ? void 0 : _a4.getCellByPosition(cellPosition);
  if (spannedCellCtrl) {
    return spannedCellCtrl;
  }
  const rowCtrl = beans.rowRenderer.getRowByPosition(cellPosition);
  if (!rowCtrl) {
    return null;
  }
  return rowCtrl.getCellCtrl(cellPosition.column);
}
function _getRowById(beans, rowId, rowPinned) {
  const { rowModel: rm, pinnedRowModel: prm } = beans;
  let node;
  node != null ? node : node = rm == null ? void 0 : rm.getRowNode(rowId);
  if (rowPinned) {
    node != null ? node : node = prm == null ? void 0 : prm.getPinnedRowById(rowId, rowPinned);
  } else {
    node != null ? node : node = prm == null ? void 0 : prm.getPinnedRowById(rowId, "top");
    node != null ? node : node = prm == null ? void 0 : prm.getPinnedRowById(rowId, "bottom");
  }
  return node;
}
function _getRowAbove(beans, rowPosition, checkSticky = false) {
  var _a4;
  const { rowIndex: index, rowPinned: pinned } = rowPosition;
  const { pageBounds, pinnedRowModel, rowModel } = beans;
  if (index === 0) {
    if (pinned === "top") {
      return null;
    }
    if (pinned === "bottom" && rowModel.isRowsToRender()) {
      return { rowIndex: pageBounds.getLastRow(), rowPinned: null };
    }
    return (pinnedRowModel == null ? void 0 : pinnedRowModel.isRowsToRender("top")) ? { rowIndex: pinnedRowModel.getPinnedTopRowCount() - 1, rowPinned: "top" } : null;
  }
  if (checkSticky) {
    const rowNode = pinned ? void 0 : rowModel.getRow(index);
    return (_a4 = getNextStickyPosition(beans, rowNode, true)) != null ? _a4 : { rowIndex: index - 1, rowPinned: pinned };
  }
  return { rowIndex: index - 1, rowPinned: pinned };
}
function _getRowBelow(beans, rowPosition, checkSticky = false) {
  var _a4;
  const { rowIndex: index, rowPinned: pinned } = rowPosition;
  const { pageBounds, pinnedRowModel, rowModel } = beans;
  if (isLastRowInContainer(beans, rowPosition)) {
    if (pinned === "bottom") {
      return null;
    }
    if (pinned === "top" && rowModel.isRowsToRender()) {
      return { rowIndex: pageBounds.getFirstRow(), rowPinned: null };
    }
    return (pinnedRowModel == null ? void 0 : pinnedRowModel.isRowsToRender("bottom")) ? { rowIndex: 0, rowPinned: "bottom" } : null;
  }
  if (checkSticky) {
    const rowNode = pinned ? void 0 : rowModel.getRow(index);
    return (_a4 = getNextStickyPosition(beans, rowNode)) != null ? _a4 : { rowIndex: index + 1, rowPinned: pinned };
  }
  return { rowIndex: index + 1, rowPinned: pinned };
}
function getNextStickyPosition(beans, rowNode, up = false) {
  const { gos, rowRenderer } = beans;
  if (!(rowNode == null ? void 0 : rowNode.sticky) || !_isGroupRowsSticky(gos)) {
    return;
  }
  const stickyTopCtrls = rowRenderer.getStickyTopRowCtrls();
  const stickyBottomCtrls = rowRenderer.getStickyBottomRowCtrls();
  const isStickyTop = !stickyBottomCtrls.some((ctrl) => ctrl.rowNode.rowIndex === rowNode.rowIndex);
  const stickyRowCtrls = isStickyTop ? stickyTopCtrls : stickyBottomCtrls;
  const increment = (up ? -1 : 1) * (isStickyTop ? -1 : 1);
  let nextCtrl;
  for (let i = 0; i < stickyRowCtrls.length; i++) {
    if (stickyRowCtrls[i].rowNode.rowIndex === rowNode.rowIndex) {
      nextCtrl = stickyRowCtrls[i + increment];
      break;
    }
  }
  return nextCtrl ? { rowIndex: nextCtrl.rowNode.rowIndex, rowPinned: null } : void 0;
}
function isLastRowInContainer(beans, rowPosition) {
  var _a4, _b2;
  const { rowPinned, rowIndex } = rowPosition;
  const { pinnedRowModel, pageBounds } = beans;
  if (rowPinned === "top") {
    const lastTopIndex = ((_a4 = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedTopRowCount()) != null ? _a4 : 0) - 1;
    return lastTopIndex <= rowIndex;
  }
  if (rowPinned === "bottom") {
    const lastBottomIndex = ((_b2 = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedBottomRowCount()) != null ? _b2 : 0) - 1;
    return lastBottomIndex <= rowIndex;
  }
  const lastBodyIndex = pageBounds.getLastRow();
  return lastBodyIndex <= rowIndex;
}
var ChangedPath = class {
  constructor(keepingColumns, rootNode) {
    this.active = true;
    this.nodeIdsToColumns = {};
    this.mapToItems = {};
    this.keepingColumns = keepingColumns;
    this.pathRoot = {
      rowNode: rootNode,
      children: null
    };
    this.mapToItems[rootNode.id] = this.pathRoot;
  }
  depthFirstSearchChangedPath(pathItem, callback) {
    const { rowNode, children } = pathItem;
    if (children) {
      for (let i = 0; i < children.length; ++i) {
        this.depthFirstSearchChangedPath(children[i], callback);
      }
    }
    callback(rowNode);
  }
  depthFirstSearchEverything(rowNode, callback, traverseEverything) {
    const childrenAfterGroup = rowNode.childrenAfterGroup;
    if (childrenAfterGroup) {
      for (let i = 0, len = childrenAfterGroup.length; i < len; ++i) {
        const childNode = childrenAfterGroup[i];
        if (childNode.childrenAfterGroup) {
          this.depthFirstSearchEverything(childNode, callback, traverseEverything);
        } else if (traverseEverything) {
          callback(childNode);
        }
      }
    }
    callback(rowNode);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(callback, traverseLeafNodes = false, includeUnchangedNodes = false) {
    if (this.active && !includeUnchangedNodes) {
      this.depthFirstSearchChangedPath(this.pathRoot, callback);
    } else {
      this.depthFirstSearchEverything(this.pathRoot.rowNode, callback, traverseLeafNodes);
    }
  }
  executeFromRootNode(callback) {
    callback(this.pathRoot.rowNode);
  }
  createPathItems(rowNode) {
    let pointer = rowNode;
    let newEntryCount = 0;
    while (!this.mapToItems[pointer.id]) {
      const newEntry = {
        rowNode: pointer,
        children: null
      };
      this.mapToItems[pointer.id] = newEntry;
      newEntryCount++;
      pointer = pointer.parent;
    }
    return newEntryCount;
  }
  populateColumnsMap(rowNode, columns) {
    if (!this.keepingColumns || !columns) {
      return;
    }
    let pointer = rowNode;
    while (pointer) {
      if (!this.nodeIdsToColumns[pointer.id]) {
        this.nodeIdsToColumns[pointer.id] = {};
      }
      columns.forEach((col) => this.nodeIdsToColumns[pointer.id][col.getId()] = true);
      pointer = pointer.parent;
    }
  }
  linkPathItems(rowNode, newEntryCount) {
    let pointer = rowNode;
    for (let i = 0; i < newEntryCount; i++) {
      const thisItem = this.mapToItems[pointer.id];
      const parentItem = this.mapToItems[pointer.parent.id];
      if (!parentItem.children) {
        parentItem.children = [];
      }
      parentItem.children.push(thisItem);
      pointer = pointer.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(rowNode, columns) {
    if (!rowNode || rowNode.isRowPinned()) {
      return;
    }
    const newEntryCount = this.createPathItems(rowNode);
    this.linkPathItems(rowNode, newEntryCount);
    this.populateColumnsMap(rowNode, columns);
  }
  canSkip(rowNode) {
    return this.active && !this.mapToItems[rowNode.id];
  }
  getValueColumnsForNode(rowNode, valueColumns) {
    if (!this.keepingColumns) {
      return valueColumns;
    }
    const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
    const result = valueColumns.filter((col) => colsForThisNode[col.getId()]);
    return result;
  }
  getNotValueColumnsForNode(rowNode, valueColumns) {
    if (!this.keepingColumns) {
      return null;
    }
    const colsForThisNode = this.nodeIdsToColumns[rowNode.id];
    const result = valueColumns.filter((col) => !colsForThisNode[col.getId()]);
    return result;
  }
};
var DragModule = {
  moduleName: "Drag",
  version: VERSION,
  beans: [DragService]
};
var SharedDragAndDropModule = {
  moduleName: "SharedDragAndDrop",
  version: VERSION,
  beans: [DragAndDropService],
  dependsOn: [DragModule],
  userComponents: {
    agDragAndDropImage: DragAndDropImageComponent2
  },
  icons: {
    // shown on drag and drop image component icon while dragging column to the side of the grid to pin
    columnMovePin: "pin",
    // shown on drag and drop image component icon while dragging over part of the page that is not a drop zone
    columnMoveHide: "eye-slash",
    // shown on drag and drop image component icon while dragging columns to reorder
    columnMoveMove: "arrows",
    // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
    columnMoveLeft: "left",
    // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
    columnMoveRight: "right",
    // shown on drag and drop image component icon while dragging over Row Groups drop zone
    columnMoveGroup: "group",
    // shown on drag and drop image component icon while dragging over Values drop zone
    columnMoveValue: "aggregation",
    // shown on drag and drop image component icon while dragging over pivot drop zone
    columnMovePivot: "pivot",
    // shown on drag and drop image component icon while dragging over drop zone that doesn't support it, e.g.
    // string column over aggregation drop zone
    dropNotAllowed: "not-allowed",
    // drag handle used to pick up draggable rows
    rowDrag: "grip"
  }
};
var HorizontalResizeModule = {
  moduleName: "HorizontalResize",
  version: VERSION,
  beans: [HorizontalResizeService],
  dependsOn: [DragModule]
};
var columnMovingCSS = (
  /*css*/
  `:where(.ag-ltr) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:left .2s}.ag-header-group-cell{transition:left .2s,width .2s}}:where(.ag-rtl) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:right .2s}.ag-header-group-cell{transition:right .2s,width .2s}}`
);
var ColumnAnimationService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colAnimation";
    this.executeNextFuncs = [];
    this.executeLaterFuncs = [];
    this.active = false;
    this.activeNext = false;
    this.suppressAnimation = false;
    this.animationThreadCount = 0;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => this.gridBodyCtrl = p.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(suppress) {
    this.suppressAnimation = suppress;
  }
  start() {
    if (this.active) {
      return;
    }
    const { gos } = this;
    if (gos.get("suppressColumnMoveAnimation")) {
      return;
    }
    if (gos.get("enableRtl")) {
      return;
    }
    this.ensureAnimationCssClassPresent();
    this.active = true;
    this.activeNext = true;
  }
  finish() {
    if (!this.active) {
      return;
    }
    this.flush(
      () => this.activeNext = false,
      () => this.active = false
    );
  }
  executeNextVMTurn(func) {
    if (this.activeNext) {
      this.executeNextFuncs.push(func);
    } else {
      func();
    }
  }
  executeLaterVMTurn(func) {
    if (this.active) {
      this.executeLaterFuncs.push(func);
    } else {
      func();
    }
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const animationThreadCountCopy = this.animationThreadCount;
    const { gridBodyCtrl } = this;
    gridBodyCtrl.setColumnMovingCss(true);
    this.executeLaterFuncs.push(() => {
      if (this.animationThreadCount === animationThreadCountCopy) {
        gridBodyCtrl.setColumnMovingCss(false);
      }
    });
  }
  flush(callbackNext, callbackLater) {
    const { executeNextFuncs, executeLaterFuncs } = this;
    if (executeNextFuncs.length === 0 && executeLaterFuncs.length === 0) {
      callbackNext();
      callbackLater();
      return;
    }
    const runFuncs = (queue) => {
      while (queue.length) {
        const func = queue.pop();
        if (func) {
          func();
        }
      }
    };
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        callbackNext();
        runFuncs(executeNextFuncs);
      }, 0);
      window.setTimeout(() => {
        callbackLater();
        runFuncs(executeLaterFuncs);
      }, 200);
    });
  }
};
function moveColumnByIndex(beans, fromIndex, toIndex) {
  var _a4;
  (_a4 = beans.colMoves) == null ? void 0 : _a4.moveColumnByIndex(fromIndex, toIndex, "api");
}
function moveColumns(beans, columnsToMoveKeys, toIndex) {
  var _a4;
  (_a4 = beans.colMoves) == null ? void 0 : _a4.moveColumns(columnsToMoveKeys, toIndex, "api");
}
var BodyDropPivotTarget = class extends BeanStub {
  constructor(pinned) {
    super();
    this.pinned = pinned;
    this.columnsToAggregate = [];
    this.columnsToGroup = [];
    this.columnsToPivot = [];
  }
  /** Callback for when drag enters */
  onDragEnter(draggingEvent) {
    this.clearColumnsList();
    if (this.gos.get("functionsReadOnly")) {
      return;
    }
    const dragColumns = draggingEvent.dragItem.columns;
    if (!dragColumns) {
      return;
    }
    dragColumns.forEach((column) => {
      if (!column.isPrimary()) {
        return;
      }
      if (column.isAnyFunctionActive()) {
        return;
      }
      if (column.isAllowValue()) {
        this.columnsToAggregate.push(column);
      } else if (column.isAllowRowGroup()) {
        this.columnsToGroup.push(column);
      } else if (column.isAllowPivot()) {
        this.columnsToPivot.push(column);
      }
    });
  }
  getIconName() {
    const totalColumns = this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length;
    if (totalColumns > 0) {
      return this.pinned ? "pinned" : "move";
    }
    return null;
  }
  /** Callback for when drag leaves */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragLeave(draggingEvent) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0;
    this.columnsToGroup.length = 0;
    this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragging(draggingEvent) {
  }
  /** Callback for when drag stops */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragStop(draggingEvent) {
    const { valueColsSvc, rowGroupColsSvc, pivotColsSvc } = this.beans;
    if (this.columnsToAggregate.length > 0) {
      valueColsSvc == null ? void 0 : valueColsSvc.addColumns(this.columnsToAggregate, "toolPanelDragAndDrop");
    }
    if (this.columnsToGroup.length > 0) {
      rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.addColumns(this.columnsToGroup, "toolPanelDragAndDrop");
    }
    if (this.columnsToPivot.length > 0) {
      pivotColsSvc == null ? void 0 : pivotColsSvc.addColumns(this.columnsToPivot, "toolPanelDragAndDrop");
    }
  }
  onDragCancel() {
    this.clearColumnsList();
  }
};
function sortColsLikeCols(colsList, cols) {
  if (!cols || cols.length <= 1) {
    return;
  }
  const notAllColsPresent = cols.filter((c) => colsList.indexOf(c) < 0).length > 0;
  if (notAllColsPresent) {
    return;
  }
  cols.sort((a, b) => {
    const indexA = colsList.indexOf(a);
    const indexB = colsList.indexOf(b);
    return indexA - indexB;
  });
}
function getColsToMove(allMovingColumns) {
  const newCols = [...allMovingColumns];
  allMovingColumns.forEach((col) => {
    var _a4;
    let movingGroup = null;
    let parent = col.getParent();
    while (parent != null && parent.getDisplayedLeafColumns().length === 1) {
      movingGroup = parent;
      parent = parent.getParent();
    }
    if (movingGroup != null) {
      const isMarryChildren = !!((_a4 = movingGroup.getColGroupDef()) == null ? void 0 : _a4.marryChildren);
      const columnsToMove = isMarryChildren ? (
        // when marry children is true, we also have to move hidden
        // columns within the group, so grab them from the `providedColumnGroup`
        movingGroup.getProvidedColumnGroup().getLeafColumns()
      ) : movingGroup.getLeafColumns();
      columnsToMove.forEach((newCol) => {
        if (!newCols.includes(newCol)) {
          newCols.push(newCol);
        }
      });
    }
  });
  return newCols;
}
function getLowestFragMove(validMoves, allMovingColumnsOrdered, colMoves, visibleCols) {
  const displayedCols = visibleCols.allCols;
  let lowestFragMove = null;
  let targetOrder = null;
  for (let i = 0; i < validMoves.length; i++) {
    const move = validMoves[i];
    const order = colMoves.getProposedColumnOrder(allMovingColumnsOrdered, move);
    if (!colMoves.doesOrderPassRules(order)) {
      continue;
    }
    const displayedOrder = order.filter((col) => displayedCols.includes(col));
    if (targetOrder === null) {
      targetOrder = displayedOrder;
    } else if (!_areEqual(displayedOrder, targetOrder)) {
      break;
    }
    const fragCount = groupFragCount(order);
    if (lowestFragMove === null || fragCount < lowestFragMove.fragCount) {
      lowestFragMove = { move, fragCount };
    }
  }
  return lowestFragMove;
}
function getBestColumnMoveIndexFromXPosition(params) {
  const { isFromHeader, fromLeft, xPosition, fromEnter, fakeEvent, pinned, gos, colModel, colMoves, visibleCols } = params;
  let { allMovingColumns } = params;
  if (isFromHeader) {
    allMovingColumns = getColsToMove(allMovingColumns);
  }
  const allMovingColumnsOrdered = allMovingColumns.slice();
  sortColsLikeCols(colModel.getCols(), allMovingColumnsOrdered);
  const validMoves = calculateValidMoves({
    movingCols: allMovingColumnsOrdered,
    draggingRight: fromLeft,
    xPosition,
    pinned,
    gos,
    colModel,
    visibleCols
  });
  const oldIndex = calculateOldIndex(allMovingColumnsOrdered, colModel);
  if (validMoves.length === 0) {
    return;
  }
  const firstValidMove = validMoves[0];
  const constrainDirection = oldIndex !== null && (isFromHeader || !fromEnter);
  if (constrainDirection && !fakeEvent) {
    if (!fromLeft && firstValidMove >= oldIndex) {
      return;
    }
    if (fromLeft && firstValidMove <= oldIndex) {
      return;
    }
  }
  const lowestFragMove = getLowestFragMove(validMoves, allMovingColumnsOrdered, colMoves, visibleCols);
  if (!lowestFragMove) {
    return;
  }
  const toIndex = lowestFragMove.move;
  if (toIndex > colModel.getCols().length - allMovingColumnsOrdered.length) {
    return;
  }
  return { columns: allMovingColumnsOrdered, toIndex };
}
function attemptMoveColumns(params) {
  const { columns, toIndex } = getBestColumnMoveIndexFromXPosition(params) || {};
  const { finished, colMoves } = params;
  if (!columns || toIndex == null) {
    return null;
  }
  colMoves.moveColumns(columns, toIndex, "uiColumnMoved", finished);
  return finished ? null : { columns, toIndex };
}
function calculateOldIndex(movingCols, colModel) {
  const gridCols = colModel.getCols();
  const indexes = movingCols.map((col) => gridCols.indexOf(col)).sort((a, b) => a - b);
  const firstIndex = indexes[0];
  const lastIndex = _last(indexes);
  const spread = lastIndex - firstIndex;
  const gapsExist = spread !== indexes.length - 1;
  return gapsExist ? null : firstIndex;
}
function groupFragCount(columns) {
  function parents(col) {
    const result = [];
    let parent = col.getOriginalParent();
    while (parent != null) {
      result.push(parent);
      parent = parent.getOriginalParent();
    }
    return result;
  }
  let count = 0;
  for (let i = 0; i < columns.length - 1; i++) {
    let a = parents(columns[i]);
    let b = parents(columns[i + 1]);
    [a, b] = a.length > b.length ? [a, b] : [b, a];
    a.forEach((parent) => {
      if (b.indexOf(parent) === -1) {
        count++;
      }
    });
  }
  return count;
}
function getDisplayedColumns(visibleCols, type) {
  switch (type) {
    case "left":
      return visibleCols.leftCols;
    case "right":
      return visibleCols.rightCols;
    default:
      return visibleCols.centerCols;
  }
}
function calculateValidMoves(params) {
  const { movingCols, draggingRight, xPosition, pinned, gos, colModel, visibleCols } = params;
  const isMoveBlocked = gos.get("suppressMovableColumns") || movingCols.some((col) => col.getColDef().suppressMovable);
  if (isMoveBlocked) {
    return [];
  }
  const allDisplayedCols = getDisplayedColumns(visibleCols, pinned);
  const allGridCols = colModel.getCols();
  const movingDisplayedCols = allDisplayedCols.filter((col) => movingCols.includes(col));
  const otherDisplayedCols = allDisplayedCols.filter((col) => !movingCols.includes(col));
  const otherGridCols = allGridCols.filter((col) => !movingCols.includes(col));
  let displayIndex = 0;
  let availableWidth = xPosition;
  if (draggingRight) {
    let widthOfMovingDisplayedCols = 0;
    movingDisplayedCols.forEach((col) => widthOfMovingDisplayedCols += col.getActualWidth());
    availableWidth -= widthOfMovingDisplayedCols;
  }
  if (availableWidth > 0) {
    for (let i = 0; i < otherDisplayedCols.length; i++) {
      const col = otherDisplayedCols[i];
      availableWidth -= col.getActualWidth();
      if (availableWidth < 0) {
        break;
      }
      displayIndex++;
    }
    if (draggingRight) {
      displayIndex++;
    }
  }
  let firstValidMove;
  if (displayIndex > 0) {
    const leftColumn = otherDisplayedCols[displayIndex - 1];
    firstValidMove = otherGridCols.indexOf(leftColumn) + 1;
  } else {
    firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);
    if (firstValidMove === -1) {
      firstValidMove = 0;
    }
  }
  const validMoves = [firstValidMove];
  const numberComparator = (a, b) => a - b;
  if (draggingRight) {
    let pointer = firstValidMove + 1;
    const lastIndex = allGridCols.length - 1;
    while (pointer <= lastIndex) {
      validMoves.push(pointer);
      pointer++;
    }
    validMoves.sort(numberComparator);
  } else {
    let pointer = firstValidMove;
    const lastIndex = allGridCols.length - 1;
    let displacedCol = allGridCols[pointer];
    while (pointer <= lastIndex && allDisplayedCols.indexOf(displacedCol) < 0) {
      pointer++;
      validMoves.push(pointer);
      displacedCol = allGridCols[pointer];
    }
    pointer = firstValidMove - 1;
    const firstDisplayIndex = 0;
    while (pointer >= firstDisplayIndex) {
      validMoves.push(pointer);
      pointer--;
    }
    validMoves.sort(numberComparator).reverse();
  }
  return validMoves;
}
function normaliseX(params) {
  var _a4;
  const { pinned, fromKeyboard, gos, ctrlsSvc, useHeaderRow, skipScrollPadding } = params;
  let eViewport = (_a4 = ctrlsSvc.getHeaderRowContainerCtrl(pinned)) == null ? void 0 : _a4.eViewport;
  let { x } = params;
  if (!eViewport) {
    return 0;
  }
  if (fromKeyboard) {
    x -= eViewport.getBoundingClientRect().left;
  }
  if (gos.get("enableRtl")) {
    if (useHeaderRow) {
      eViewport = eViewport.querySelector(".ag-header-row");
    }
    x = eViewport.clientWidth - x;
  }
  if (pinned == null && !skipScrollPadding) {
    x += ctrlsSvc.get("center").getCenterViewportScrollLeft();
  }
  return x;
}
function setColumnsMoving(columns, isMoving) {
  for (const column of columns) {
    column.moving = isMoving;
    column.dispatchColEvent("movingChanged", "uiColumnMoved");
  }
}
var MOVE_FAIL_THRESHOLD = 7;
var SCROLL_MOVE_WIDTH = 100;
var SCROLL_GAP_NEEDED_BEFORE_MOVE = SCROLL_MOVE_WIDTH / 2;
var SCROLL_ACCELERATION_RATE = 5;
var SCROLL_TIME_INTERVAL = 100;
var MoveColumnFeature = class extends BeanStub {
  constructor(pinned) {
    super();
    this.pinned = pinned;
    this.needToMoveLeft = false;
    this.needToMoveRight = false;
    this.lastMovedInfo = null;
    this.isCenterContainer = !_exists(pinned);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCon = p.gridBodyCtrl;
    });
  }
  getIconName() {
    var _a4;
    const { pinned, lastDraggingEvent } = this;
    const { dragItem } = lastDraggingEvent || {};
    const columns = (_a4 = dragItem == null ? void 0 : dragItem.columns) != null ? _a4 : [];
    for (const col of columns) {
      const colPinned = col.getPinned();
      if (col.getColDef().lockPinned) {
        if (colPinned == pinned) {
          return "move";
        }
        continue;
      }
      const initialPinnedState = dragItem == null ? void 0 : dragItem.containerType;
      if (initialPinnedState === pinned || !pinned) {
        return "move";
      }
      if (pinned && (!colPinned || initialPinnedState !== pinned)) {
        return "pinned";
      }
    }
    return "notAllowed";
  }
  onDragEnter(draggingEvent) {
    const dragItem = draggingEvent.dragItem;
    const columns = dragItem.columns;
    const dragCameFromToolPanel = draggingEvent.dragSource.type === 0;
    if (dragCameFromToolPanel) {
      this.setColumnsVisible(columns, true, "uiColumnDragged");
    } else {
      const visibleState = dragItem.visibleState;
      const visibleColumns = (columns || []).filter(
        (column) => visibleState[column.getId()] && !column.isVisible()
      );
      this.setColumnsVisible(visibleColumns, true, "uiColumnDragged");
    }
    if (!this.gos.get("suppressMoveWhenColumnDragging")) {
      this.attemptToPinColumns(columns, this.pinned);
    }
    this.onDragging(draggingEvent, true, true);
  }
  onDragging(draggingEvent = this.lastDraggingEvent, fromEnter = false, fakeEvent = false, finished = false) {
    const { gos, ctrlsSvc } = this.beans;
    const isSuppressMoveWhenDragging = gos.get("suppressMoveWhenColumnDragging");
    if (finished && !isSuppressMoveWhenDragging) {
      this.finishColumnMoving();
      return;
    }
    this.lastDraggingEvent = draggingEvent;
    if (!draggingEvent || !finished && _missing(draggingEvent.hDirection)) {
      return;
    }
    const mouseX = normaliseX({
      x: draggingEvent.x,
      pinned: this.pinned,
      gos,
      ctrlsSvc
    });
    if (!fromEnter) {
      this.checkCenterForScrolling(mouseX);
    }
    if (isSuppressMoveWhenDragging) {
      this.handleColumnDragWhileSuppressingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished);
    } else {
      this.handleColumnDragWhileAllowingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished);
    }
  }
  onDragLeave() {
    this.ensureIntervalCleared();
    this.clearHighlighted();
    this.updateDragItemContainerType();
    this.lastMovedInfo = null;
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, false, true, true);
    this.ensureIntervalCleared();
    this.lastMovedInfo = null;
  }
  onDragCancel() {
    this.clearHighlighted();
    this.ensureIntervalCleared();
    this.lastMovedInfo = null;
  }
  setColumnsVisible(columns, visible, source) {
    if (!(columns == null ? void 0 : columns.length)) {
      return;
    }
    const allowedCols = columns.filter((c) => !c.getColDef().lockVisible);
    if (!allowedCols.length) {
      return;
    }
    this.beans.colModel.setColsVisible(allowedCols, visible, source);
  }
  finishColumnMoving() {
    this.clearHighlighted();
    const lastMovedInfo = this.lastMovedInfo;
    if (!lastMovedInfo) {
      return;
    }
    const { columns, toIndex } = lastMovedInfo;
    this.beans.colMoves.moveColumns(columns, toIndex, "uiColumnMoved", true);
  }
  updateDragItemContainerType() {
    const { lastDraggingEvent } = this;
    if (this.gos.get("suppressMoveWhenColumnDragging") || !lastDraggingEvent) {
      return;
    }
    const dragItem = lastDraggingEvent.dragItem;
    if (!dragItem) {
      return;
    }
    dragItem.containerType = this.pinned;
  }
  handleColumnDragWhileSuppressingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished) {
    const allMovingColumns = this.getAllMovingColumns(draggingEvent, true);
    if (finished) {
      const isAttemptingToPin = this.isAttemptingToPin(allMovingColumns);
      if (isAttemptingToPin) {
        this.attemptToPinColumns(allMovingColumns, void 0, true);
      }
      const { fromLeft, xPosition } = this.getNormalisedXPositionInfo(allMovingColumns, isAttemptingToPin) || {};
      if (fromLeft == null || xPosition == null) {
        this.finishColumnMoving();
        return;
      }
      this.moveColumnsAfterHighlight({
        allMovingColumns,
        xPosition,
        fromEnter,
        fakeEvent,
        fromLeft
      });
    } else {
      if (!this.beans.dragAndDrop.isDropZoneWithinThisGrid(draggingEvent)) {
        return;
      }
      this.highlightHoveredColumn(allMovingColumns, mouseX);
    }
  }
  handleColumnDragWhileAllowingMovement(draggingEvent, fromEnter, fakeEvent, mouseX, finished) {
    const allMovingColumns = this.getAllMovingColumns(draggingEvent);
    const fromLeft = this.normaliseDirection(draggingEvent.hDirection) === "right";
    const isFromHeader = draggingEvent.dragSource.type === 1;
    const params = this.getMoveColumnParams({
      allMovingColumns,
      isFromHeader,
      xPosition: mouseX,
      fromLeft,
      fromEnter,
      fakeEvent
    });
    const lastMovedInfo = attemptMoveColumns({ ...params, finished });
    if (lastMovedInfo) {
      this.lastMovedInfo = lastMovedInfo;
    }
  }
  getAllMovingColumns(draggingEvent, useSplit = false) {
    const dragItem = draggingEvent.dragSource.getDragItem();
    let columns = null;
    if (useSplit) {
      columns = dragItem.columnsInSplit;
      if (!columns) {
        columns = dragItem.columns;
      }
    } else {
      columns = dragItem.columns;
    }
    const conditionCallback = (col) => col.getColDef().lockPinned ? col.getPinned() == this.pinned : true;
    if (!columns) {
      return [];
    }
    return columns.filter(conditionCallback);
  }
  getMoveColumnParams(params) {
    const { allMovingColumns, isFromHeader, xPosition, fromLeft, fromEnter, fakeEvent } = params;
    const { gos, colModel, colMoves, visibleCols } = this.beans;
    return {
      allMovingColumns,
      isFromHeader,
      fromLeft,
      xPosition,
      pinned: this.pinned,
      fromEnter,
      fakeEvent,
      gos,
      colModel,
      colMoves,
      visibleCols
    };
  }
  highlightHoveredColumn(movingColumns, mouseX) {
    var _a4;
    const { gos, colModel } = this.beans;
    const isRtl = gos.get("enableRtl");
    const consideredColumns = colModel.getCols().filter((col) => col.isVisible() && col.getPinned() === this.pinned);
    let start = null;
    let width = null;
    let targetColumn = null;
    for (const col of consideredColumns) {
      width = col.getActualWidth();
      start = this.getNormalisedColumnLeft(col, 0, isRtl);
      if (start != null) {
        const end = start + width;
        if (start <= mouseX && end >= mouseX) {
          targetColumn = col;
          break;
        }
      }
      start = null;
      width = null;
    }
    if (!targetColumn) {
      for (let i = consideredColumns.length - 1; i >= 0; i--) {
        const currentColumn = consideredColumns[i];
        const parent = consideredColumns[i].getParent();
        if (!parent) {
          targetColumn = currentColumn;
          break;
        }
        const leafDisplayedCols = parent == null ? void 0 : parent.getDisplayedLeafColumns();
        if (leafDisplayedCols.length) {
          targetColumn = _last(leafDisplayedCols);
          break;
        }
      }
      if (!targetColumn) {
        return;
      }
      start = this.getNormalisedColumnLeft(targetColumn, 0, isRtl);
      width = targetColumn.getActualWidth();
    } else if (movingColumns.indexOf(targetColumn) !== -1) {
      targetColumn = null;
    }
    if (((_a4 = this.lastHighlightedColumn) == null ? void 0 : _a4.column) !== targetColumn) {
      this.clearHighlighted();
    }
    if (targetColumn == null || start == null || width == null) {
      return;
    }
    let position;
    if (mouseX - start < width / 2 !== isRtl) {
      position = 0;
    } else {
      position = 1;
    }
    setColumnHighlighted(targetColumn, position);
    this.lastHighlightedColumn = { column: targetColumn, position };
  }
  getNormalisedXPositionInfo(allMovingColumns, isAttemptingToPin) {
    const { gos, visibleCols } = this.beans;
    const isRtl = gos.get("enableRtl");
    const { firstMovingCol, column, position } = this.getColumnMoveAndTargetInfo(
      allMovingColumns,
      isAttemptingToPin,
      isRtl
    );
    if (!firstMovingCol || !column || position == null) {
      return;
    }
    const visibleColumns = visibleCols.allCols;
    const movingColIndex = visibleColumns.indexOf(firstMovingCol);
    const targetIndex = visibleColumns.indexOf(column);
    const isBefore = position === 0 !== isRtl;
    const fromLeft = movingColIndex < targetIndex || movingColIndex === targetIndex && !isBefore;
    let diff = 0;
    if (isBefore) {
      if (fromLeft) {
        diff -= 1;
      }
    } else {
      if (!fromLeft) {
        diff += 1;
      }
    }
    if (targetIndex + diff === movingColIndex) {
      return;
    }
    const targetColumn = visibleColumns[targetIndex + diff];
    if (!targetColumn) {
      return;
    }
    const xPosition = this.getNormalisedColumnLeft(targetColumn, 20, isRtl);
    return { fromLeft, xPosition };
  }
  getColumnMoveAndTargetInfo(allMovingColumns, isAttemptingToPin, isRtl) {
    const lastHighlightedColumn = this.lastHighlightedColumn || {};
    const { firstMovingCol, lastMovingCol } = findFirstAndLastMovingColumns(allMovingColumns);
    if (!firstMovingCol || !lastMovingCol || lastHighlightedColumn.column || !isAttemptingToPin) {
      return {
        firstMovingCol,
        ...lastHighlightedColumn
      };
    }
    const pinned = this.getPinDirection();
    const isLeft = pinned === "left";
    return {
      firstMovingCol,
      position: isLeft ? 1 : 0,
      column: isLeft !== isRtl ? firstMovingCol : lastMovingCol
    };
  }
  normaliseDirection(hDirection) {
    if (this.gos.get("enableRtl")) {
      switch (hDirection) {
        case "left":
          return "right";
        case "right":
          return "left";
      }
    }
    return hDirection;
  }
  getNormalisedColumnLeft(col, padding, isRtl) {
    const { gos, ctrlsSvc } = this.beans;
    const left = col.getLeft();
    if (left == null) {
      return null;
    }
    const width = col.getActualWidth();
    return normaliseX({
      x: isRtl ? left + width - padding : left + padding,
      pinned: col.getPinned(),
      useHeaderRow: isRtl,
      skipScrollPadding: true,
      gos,
      ctrlsSvc
    });
  }
  isAttemptingToPin(columns) {
    const isMovingHorizontally = this.needToMoveLeft || this.needToMoveRight;
    const isFailedMoreThanThreshold = this.failedMoveAttempts > MOVE_FAIL_THRESHOLD;
    return isMovingHorizontally && isFailedMoreThanThreshold || columns.some((col) => col.getPinned() !== this.pinned);
  }
  moveColumnsAfterHighlight(params) {
    const { allMovingColumns, xPosition, fromEnter, fakeEvent, fromLeft } = params;
    const columnMoveParams = this.getMoveColumnParams({
      allMovingColumns,
      isFromHeader: true,
      xPosition,
      fromLeft,
      fromEnter,
      fakeEvent
    });
    const { columns, toIndex } = getBestColumnMoveIndexFromXPosition(columnMoveParams) || {};
    if (columns && toIndex != null) {
      this.lastMovedInfo = {
        columns,
        toIndex
      };
    }
    this.finishColumnMoving();
  }
  clearHighlighted() {
    const { lastHighlightedColumn } = this;
    if (!lastHighlightedColumn) {
      return;
    }
    setColumnHighlighted(lastHighlightedColumn.column, null);
    this.lastHighlightedColumn = null;
  }
  checkCenterForScrolling(xAdjustedForScroll) {
    if (!this.isCenterContainer) {
      return;
    }
    const centerCtrl = this.beans.ctrlsSvc.get("center");
    const firstVisiblePixel = centerCtrl.getCenterViewportScrollLeft();
    const lastVisiblePixel = firstVisiblePixel + centerCtrl.getCenterWidth();
    let needToMoveRight;
    let needToMoveLeft;
    if (this.gos.get("enableRtl")) {
      needToMoveRight = xAdjustedForScroll < firstVisiblePixel + SCROLL_GAP_NEEDED_BEFORE_MOVE;
      needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - SCROLL_GAP_NEEDED_BEFORE_MOVE;
    } else {
      needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + SCROLL_GAP_NEEDED_BEFORE_MOVE;
      needToMoveRight = xAdjustedForScroll > lastVisiblePixel - SCROLL_GAP_NEEDED_BEFORE_MOVE;
    }
    this.needToMoveRight = needToMoveRight;
    this.needToMoveLeft = needToMoveLeft;
    if (needToMoveLeft || needToMoveRight) {
      this.ensureIntervalStarted();
    } else {
      this.ensureIntervalCleared();
    }
  }
  ensureIntervalStarted() {
    if (this.movingIntervalId) {
      return;
    }
    this.intervalCount = 0;
    this.failedMoveAttempts = 0;
    this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), SCROLL_TIME_INTERVAL);
    this.beans.dragAndDrop.setDragImageCompIcon(this.needToMoveLeft ? "left" : "right", true);
  }
  ensureIntervalCleared() {
    if (!this.movingIntervalId) {
      return;
    }
    window.clearInterval(this.movingIntervalId);
    this.movingIntervalId = null;
    this.failedMoveAttempts = 0;
    this.beans.dragAndDrop.setDragImageCompIcon(this.getIconName());
  }
  moveInterval() {
    var _a4;
    let pixelsToMove;
    this.intervalCount++;
    pixelsToMove = 10 + this.intervalCount * SCROLL_ACCELERATION_RATE;
    if (pixelsToMove > SCROLL_MOVE_WIDTH) {
      pixelsToMove = SCROLL_MOVE_WIDTH;
    }
    let pixelsMoved = null;
    const scrollFeature = this.gridBodyCon.scrollFeature;
    if (this.needToMoveLeft) {
      pixelsMoved = scrollFeature.scrollHorizontally(-pixelsToMove);
    } else if (this.needToMoveRight) {
      pixelsMoved = scrollFeature.scrollHorizontally(pixelsToMove);
    }
    if (pixelsMoved !== 0) {
      this.onDragging(this.lastDraggingEvent);
      this.failedMoveAttempts = 0;
    } else {
      this.failedMoveAttempts++;
      const { pinnedCols, dragAndDrop, gos } = this.beans;
      if (this.failedMoveAttempts <= MOVE_FAIL_THRESHOLD + 1 || !pinnedCols) {
        return;
      }
      dragAndDrop.setDragImageCompIcon("pinned");
      if (!gos.get("suppressMoveWhenColumnDragging")) {
        const columns = (_a4 = this.lastDraggingEvent) == null ? void 0 : _a4.dragItem.columns;
        this.attemptToPinColumns(columns, void 0, true);
      }
    }
  }
  getPinDirection() {
    if (this.needToMoveLeft || this.pinned === "left") {
      return "left";
    }
    if (this.needToMoveRight || this.pinned === "right") {
      return "right";
    }
  }
  attemptToPinColumns(columns, pinned, fromMoving = false) {
    const allowedCols = (columns || []).filter((c) => !c.getColDef().lockPinned);
    if (!allowedCols.length) {
      return 0;
    }
    if (fromMoving) {
      pinned = this.getPinDirection();
    }
    const { pinnedCols, dragAndDrop } = this.beans;
    pinnedCols == null ? void 0 : pinnedCols.setColsPinned(allowedCols, pinned, "uiColumnDragged");
    if (fromMoving) {
      dragAndDrop.nudge();
    }
    return allowedCols.length;
  }
  destroy() {
    super.destroy();
    this.lastDraggingEvent = null;
    this.clearHighlighted();
    this.lastMovedInfo = null;
  }
};
function setColumnHighlighted(column, highlighted) {
  if (column.highlighted === highlighted) {
    return;
  }
  column.highlighted = highlighted;
  column.dispatchColEvent("headerHighlightChanged", "uiColumnMoved");
}
function findFirstAndLastMovingColumns(allMovingColumns) {
  const moveLen = allMovingColumns.length;
  let firstMovingCol;
  let lastMovingCol;
  for (let i = 0; i < moveLen; i++) {
    if (!firstMovingCol) {
      const leftCol = allMovingColumns[i];
      if (leftCol.getLeft() != null) {
        firstMovingCol = leftCol;
      }
    }
    if (!lastMovingCol) {
      const rightCol = allMovingColumns[moveLen - 1 - i];
      if (rightCol.getLeft() != null) {
        lastMovingCol = rightCol;
      }
    }
    if (firstMovingCol && lastMovingCol) {
      break;
    }
  }
  return { firstMovingCol, lastMovingCol };
}
var BodyDropTarget = class extends BeanStub {
  constructor(pinned, eContainer) {
    super();
    this.pinned = pinned;
    this.eContainer = eContainer;
  }
  postConstruct() {
    const { ctrlsSvc, dragAndDrop } = this.beans;
    const pinned = this.pinned;
    ctrlsSvc.whenReady(this, (p) => {
      let eSecondaryContainers;
      const eBodyViewport = p.gridBodyCtrl.eBodyViewport;
      switch (pinned) {
        case "left":
          eSecondaryContainers = [
            [eBodyViewport, p.left.eContainer],
            [p.bottomLeft.eContainer],
            [p.topLeft.eContainer]
          ];
          break;
        case "right":
          eSecondaryContainers = [
            [eBodyViewport, p.right.eContainer],
            [p.bottomRight.eContainer],
            [p.topRight.eContainer]
          ];
          break;
        default:
          eSecondaryContainers = [
            [eBodyViewport, p.center.eViewport],
            [p.bottomCenter.eViewport],
            [p.topCenter.eViewport]
          ];
          break;
      }
      this.eSecondaryContainers = eSecondaryContainers;
    });
    this.moveColumnFeature = this.createManagedBean(new MoveColumnFeature(pinned));
    this.bodyDropPivotTarget = this.createManagedBean(new BodyDropPivotTarget(pinned));
    dragAndDrop.addDropTarget(this);
    this.addDestroyFunc(() => dragAndDrop.removeDropTarget(this));
  }
  isInterestedIn(type) {
    return type === 1 || type === 0 && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(draggingEvent) {
    return this.beans.colModel.isPivotMode() && draggingEvent.dragSource.type === 0;
  }
  onDragEnter(draggingEvent) {
    this.currentDropListener = this.isDropColumnInPivotMode(draggingEvent) ? this.bodyDropPivotTarget : this.moveColumnFeature;
    this.currentDropListener.onDragEnter(draggingEvent);
  }
  onDragLeave(params) {
    this.currentDropListener.onDragLeave(params);
  }
  onDragging(params) {
    this.currentDropListener.onDragging(params);
  }
  onDragStop(params) {
    this.currentDropListener.onDragStop(params);
  }
  onDragCancel() {
    this.currentDropListener.onDragCancel();
  }
};
var ColumnMoveService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colMoves";
  }
  moveColumnByIndex(fromIndex, toIndex, source) {
    const gridColumns = this.beans.colModel.getCols();
    if (!gridColumns) {
      return;
    }
    const column = gridColumns[fromIndex];
    this.moveColumns([column], toIndex, source);
  }
  moveColumns(columnsToMoveKeys, toIndex, source, finished = true) {
    const { colModel, colAnimation, visibleCols, eventSvc } = this.beans;
    const gridColumns = colModel.getCols();
    if (!gridColumns) {
      return;
    }
    if (toIndex > gridColumns.length - columnsToMoveKeys.length) {
      _warn(30, { toIndex });
      return;
    }
    colAnimation == null ? void 0 : colAnimation.start();
    const movedColumns = colModel.getColsForKeys(columnsToMoveKeys);
    if (this.doesMovePassRules(movedColumns, toIndex)) {
      _moveInArray(colModel.getCols(), movedColumns, toIndex);
      visibleCols.refresh(source);
      eventSvc.dispatchEvent({
        type: "columnMoved",
        columns: movedColumns,
        column: movedColumns.length === 1 ? movedColumns[0] : null,
        toIndex,
        finished,
        source
      });
    }
    colAnimation == null ? void 0 : colAnimation.finish();
  }
  doesMovePassRules(columnsToMove, toIndex) {
    const proposedColumnOrder = this.getProposedColumnOrder(columnsToMove, toIndex);
    return this.doesOrderPassRules(proposedColumnOrder);
  }
  doesOrderPassRules(gridOrder) {
    const { colModel, gos } = this.beans;
    if (!doesMovePassMarryChildren(gridOrder, colModel.getColTree())) {
      return false;
    }
    const doesMovePassLockedPositions = (proposedColumnOrder) => {
      const lockPositionToPlacement = (position) => {
        if (!position) {
          return 0;
        }
        return position === "left" || position === true ? -1 : 1;
      };
      const isRtl = gos.get("enableRtl");
      let lastPlacement = isRtl ? 1 : -1;
      let rulePassed = true;
      proposedColumnOrder.forEach((col) => {
        const placement = lockPositionToPlacement(col.getColDef().lockPosition);
        if (isRtl) {
          if (placement > lastPlacement) {
            rulePassed = false;
          }
        } else {
          if (placement < lastPlacement) {
            rulePassed = false;
          }
        }
        lastPlacement = placement;
      });
      return rulePassed;
    };
    if (!doesMovePassLockedPositions(gridOrder)) {
      return false;
    }
    return true;
  }
  getProposedColumnOrder(columnsToMove, toIndex) {
    const gridColumns = this.beans.colModel.getCols();
    const proposedColumnOrder = gridColumns.slice();
    _moveInArray(proposedColumnOrder, columnsToMove, toIndex);
    return proposedColumnOrder;
  }
  createBodyDropTarget(pinned, dropContainer) {
    return new BodyDropTarget(pinned, dropContainer);
  }
  moveHeader(hDirection, eGui, column, pinned, bean) {
    const { ctrlsSvc, gos, colModel, visibleCols, focusSvc } = this.beans;
    const rect = eGui.getBoundingClientRect();
    const left = rect.left;
    const isGroup = isColumnGroup(column);
    const width = isGroup ? rect.width : column.getActualWidth();
    const isLeft = hDirection === "left" !== gos.get("enableRtl");
    const xPosition = normaliseX({
      x: isLeft ? left - 20 : left + width + 20,
      pinned,
      fromKeyboard: true,
      gos,
      ctrlsSvc
    });
    const headerPosition = focusSvc.focusedHeader;
    attemptMoveColumns({
      allMovingColumns: isGroup ? column.getLeafColumns() : [column],
      isFromHeader: true,
      fromLeft: hDirection === "right",
      xPosition,
      pinned,
      fromEnter: false,
      fakeEvent: false,
      gos,
      colModel,
      colMoves: this,
      visibleCols,
      finished: true
    });
    let targetColumn;
    if (isGroup) {
      const displayedLeafColumns = column.getDisplayedLeafColumns();
      targetColumn = isLeft ? displayedLeafColumns[0] : _last(displayedLeafColumns);
    } else {
      targetColumn = column;
    }
    ctrlsSvc.getScrollFeature().ensureColumnVisible(targetColumn, "auto");
    if ((!bean.isAlive() || gos.get("ensureDomOrder")) && headerPosition) {
      let restoreFocusColumn;
      if (isGroup) {
        const groupId = column.getGroupId();
        const leafCols = column.getLeafColumns();
        if (!leafCols.length) {
          return;
        }
        const parent = leafCols[0].getParent();
        if (!parent) {
          return;
        }
        restoreFocusColumn = findGroupWidthId(parent, groupId);
      } else {
        restoreFocusColumn = column;
      }
      if (restoreFocusColumn) {
        focusSvc.focusHeaderPosition({
          headerPosition: {
            ...headerPosition,
            column: restoreFocusColumn
          }
        });
      }
    }
  }
  setDragSourceForHeader(eSource, column, displayName) {
    const { gos, colModel, dragAndDrop, visibleCols } = this.beans;
    let hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
    const isGroup = isColumnGroup(column);
    const columns = isGroup ? column.getProvidedColumnGroup().getLeafColumns() : [column];
    const getDragItem = isGroup ? () => createDragItemForGroup(column, visibleCols.allCols) : () => createDragItem(column);
    const dragSource = {
      type: 1,
      eElement: eSource,
      getDefaultIconName: () => hideColumnOnExit ? "hide" : "notAllowed",
      getDragItem,
      dragItemName: displayName,
      onDragStarted: () => {
        hideColumnOnExit = !gos.get("suppressDragLeaveHidesColumns");
        setColumnsMoving(columns, true);
      },
      onDragStopped: () => setColumnsMoving(columns, false),
      onDragCancelled: () => setColumnsMoving(columns, false),
      onGridEnter: (dragItem) => {
        if (hideColumnOnExit) {
          const { columns: columns2 = [], visibleState } = dragItem != null ? dragItem : {};
          const hasVisibleState = isGroup ? (col) => !visibleState || visibleState[col.getColId()] : () => true;
          const unlockedColumns = columns2.filter(
            (col) => !col.getColDef().lockVisible && hasVisibleState(col)
          );
          colModel.setColsVisible(unlockedColumns, true, "uiColumnMoved");
        }
      },
      onGridExit: (dragItem) => {
        var _a4;
        if (hideColumnOnExit) {
          const unlockedColumns = ((_a4 = dragItem == null ? void 0 : dragItem.columns) == null ? void 0 : _a4.filter((col) => !col.getColDef().lockVisible)) || [];
          colModel.setColsVisible(unlockedColumns, false, "uiColumnMoved");
        }
      }
    };
    dragAndDrop.addDragSource(dragSource, true);
    return dragSource;
  }
};
function findGroupWidthId(columnGroup, id) {
  while (columnGroup) {
    if (columnGroup.getGroupId() === id) {
      return columnGroup;
    }
    columnGroup = columnGroup.getParent();
  }
  return void 0;
}
function createDragItem(column) {
  const visibleState = {};
  visibleState[column.getId()] = column.isVisible();
  return {
    columns: [column],
    visibleState,
    containerType: column.pinned
  };
}
function createDragItemForGroup(columnGroup, allCols) {
  var _a4;
  const allColumnsOriginalOrder = columnGroup.getProvidedColumnGroup().getLeafColumns();
  const visibleState = {};
  allColumnsOriginalOrder.forEach((column) => visibleState[column.getId()] = column.isVisible());
  const allColumnsCurrentOrder = [];
  allCols.forEach((column) => {
    if (allColumnsOriginalOrder.indexOf(column) >= 0) {
      allColumnsCurrentOrder.push(column);
      _removeFromArray(allColumnsOriginalOrder, column);
    }
  });
  allColumnsOriginalOrder.forEach((column) => allColumnsCurrentOrder.push(column));
  const columnsInSplit = [];
  const columnGroupColumns = columnGroup.getLeafColumns();
  for (const col of allColumnsCurrentOrder) {
    if (columnGroupColumns.indexOf(col) !== -1) {
      columnsInSplit.push(col);
    }
  }
  return {
    columns: allColumnsCurrentOrder,
    columnsInSplit,
    visibleState,
    containerType: (_a4 = columnsInSplit[0]) == null ? void 0 : _a4.pinned
  };
}
var ColumnMoveModule = {
  moduleName: "ColumnMove",
  version: VERSION,
  beans: [ColumnMoveService, ColumnAnimationService],
  apiFunctions: {
    moveColumnByIndex,
    moveColumns
  },
  dependsOn: [SharedDragAndDropModule],
  css: [columnMovingCSS]
};
var AutoWidthCalculator = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "autoWidthCalc";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.centerRowContainerCtrl = p.center;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(column, skipHeader) {
    const eHeaderCell = this.getHeaderCellForColumn(column);
    if (!eHeaderCell) {
      return -1;
    }
    const elements = this.beans.rowRenderer.getAllCellsNotSpanningForColumn(column);
    if (!skipHeader) {
      elements.push(eHeaderCell);
    }
    return this.getPreferredWidthForElements(elements);
  }
  getPreferredWidthForColumnGroup(columnGroup) {
    const eHeaderCell = this.getHeaderCellForColumn(columnGroup);
    if (!eHeaderCell) {
      return -1;
    }
    return this.getPreferredWidthForElements([eHeaderCell]);
  }
  getPreferredWidthForElements(elements, extraPadding) {
    const eDummyContainer = document.createElement("form");
    eDummyContainer.style.position = "fixed";
    const eBodyContainer = this.centerRowContainerCtrl.eContainer;
    elements.forEach((el) => this.cloneItemIntoDummy(el, eDummyContainer));
    eBodyContainer.appendChild(eDummyContainer);
    const dummyContainerWidth = eDummyContainer.offsetWidth;
    eBodyContainer.removeChild(eDummyContainer);
    extraPadding = extraPadding != null ? extraPadding : this.gos.get("autoSizePadding");
    return dummyContainerWidth + extraPadding;
  }
  getHeaderCellForColumn(column) {
    let element = null;
    this.beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((container) => {
      const res = container.getHtmlElementForColumnHeader(column);
      if (res != null) {
        element = res;
      }
    });
    return element;
  }
  cloneItemIntoDummy(eCell, eDummyContainer) {
    const eCellClone = eCell.cloneNode(true);
    eCellClone.style.width = "";
    eCellClone.style.position = "static";
    eCellClone.style.left = "";
    const eCloneParent = document.createElement("div");
    const eCloneParentClassList = eCloneParent.classList;
    const isHeader = ["ag-header-cell", "ag-header-group-cell"].some((cls) => eCellClone.classList.contains(cls));
    if (isHeader) {
      eCloneParentClassList.add("ag-header", "ag-header-row");
      eCloneParent.style.position = "static";
    } else {
      eCloneParentClassList.add("ag-row");
    }
    let pointer = eCell.parentElement;
    while (pointer) {
      const isRow = ["ag-header-row", "ag-row"].some((cls) => pointer.classList.contains(cls));
      if (isRow) {
        for (let i = 0; i < pointer.classList.length; i++) {
          const item = pointer.classList[i];
          if (item != "ag-row-position-absolute") {
            eCloneParentClassList.add(item);
          }
        }
        break;
      }
      pointer = pointer.parentElement;
    }
    eCloneParent.appendChild(eCellClone);
    eDummyContainer.appendChild(eCloneParent);
  }
};
var AutoWidthModule = {
  moduleName: "AutoWidth",
  version: VERSION,
  beans: [AutoWidthCalculator]
};
function setColumnWidths(beans, columnWidths, finished = true, source = "api") {
  var _a4;
  (_a4 = beans.colResize) == null ? void 0 : _a4.setColumnWidths(columnWidths, false, finished, source);
}
var GroupResizeFeature = class extends BeanStub {
  constructor(comp, eResize, pinned, columnGroup) {
    super();
    this.comp = comp;
    this.eResize = eResize;
    this.pinned = pinned;
    this.columnGroup = columnGroup;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(false);
      return;
    }
    const { horizontalResizeSvc, gos, colAutosize } = this.beans;
    const finishedWithResizeFunc = horizontalResizeSvc.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, false),
      onResizeEnd: this.onResizing.bind(this, true)
    });
    this.addDestroyFunc(finishedWithResizeFunc);
    if (!gos.get("suppressAutoSize") && colAutosize) {
      this.addDestroyFunc(
        colAutosize.addColumnGroupResize(
          this.eResize,
          this.columnGroup,
          () => this.resizeLeafColumnsToFit("uiColumnResized")
        )
      );
    }
  }
  onResizeStart(shiftKey) {
    const {
      columnsToResize,
      resizeStartWidth,
      resizeRatios,
      groupAfterColumns,
      groupAfterStartWidth,
      groupAfterRatios
    } = this.getInitialValues(shiftKey);
    this.resizeCols = columnsToResize;
    this.resizeStartWidth = resizeStartWidth;
    this.resizeRatios = resizeRatios;
    this.resizeTakeFromCols = groupAfterColumns;
    this.resizeTakeFromStartWidth = groupAfterStartWidth;
    this.resizeTakeFromRatios = groupAfterRatios;
    this.toggleColumnResizing(true);
  }
  onResizing(finished, resizeAmount, source = "uiColumnResized") {
    const resizeAmountNormalised = this.normaliseDragChange(resizeAmount);
    const width = this.resizeStartWidth + resizeAmountNormalised;
    this.resizeColumnsFromLocalValues(width, source, finished);
  }
  getInitialValues(shiftKey) {
    var _a4, _b2;
    const getInitialSizeOfColumns = (columns) => columns.reduce((totalWidth, column) => totalWidth + column.getActualWidth(), 0);
    const getSizeRatiosOfColumns = (columns, initialSizeOfColumns) => columns.map((column) => column.getActualWidth() / initialSizeOfColumns);
    const columnsToResize = this.getColumnsToResize();
    const resizeStartWidth = getInitialSizeOfColumns(columnsToResize);
    const resizeRatios = getSizeRatiosOfColumns(columnsToResize, resizeStartWidth);
    const columnSizeAndRatios = {
      columnsToResize,
      resizeStartWidth,
      resizeRatios
    };
    let groupAfter = null;
    if (shiftKey) {
      groupAfter = (_b2 = (_a4 = this.beans.colGroupSvc) == null ? void 0 : _a4.getGroupAtDirection(this.columnGroup, "After")) != null ? _b2 : null;
    }
    if (groupAfter) {
      const takeFromLeafCols = groupAfter.getDisplayedLeafColumns();
      const groupAfterColumns = columnSizeAndRatios.groupAfterColumns = takeFromLeafCols.filter(
        (col) => col.isResizable()
      );
      const groupAfterStartWidth = columnSizeAndRatios.groupAfterStartWidth = getInitialSizeOfColumns(groupAfterColumns);
      columnSizeAndRatios.groupAfterRatios = getSizeRatiosOfColumns(groupAfterColumns, groupAfterStartWidth);
    } else {
      columnSizeAndRatios.groupAfterColumns = void 0;
      columnSizeAndRatios.groupAfterStartWidth = void 0;
      columnSizeAndRatios.groupAfterRatios = void 0;
    }
    return columnSizeAndRatios;
  }
  resizeLeafColumnsToFit(source) {
    const preferredSize = this.beans.autoWidthCalc.getPreferredWidthForColumnGroup(this.columnGroup);
    const initialValues = this.getInitialValues();
    if (preferredSize > initialValues.resizeStartWidth) {
      this.resizeColumns(initialValues, preferredSize, source, true);
    }
  }
  resizeColumnsFromLocalValues(totalWidth, source, finished = true) {
    if (!this.resizeCols || !this.resizeRatios) {
      return;
    }
    const initialValues = {
      columnsToResize: this.resizeCols,
      resizeStartWidth: this.resizeStartWidth,
      resizeRatios: this.resizeRatios,
      groupAfterColumns: this.resizeTakeFromCols,
      groupAfterStartWidth: this.resizeTakeFromStartWidth,
      groupAfterRatios: this.resizeTakeFromRatios
    };
    this.resizeColumns(initialValues, totalWidth, source, finished);
  }
  resizeColumns(initialValues, totalWidth, source, finished = true) {
    var _a4;
    const {
      columnsToResize,
      resizeStartWidth,
      resizeRatios,
      groupAfterColumns,
      groupAfterStartWidth,
      groupAfterRatios
    } = initialValues;
    const resizeSets = [];
    resizeSets.push({
      columns: columnsToResize,
      ratios: resizeRatios,
      width: totalWidth
    });
    if (groupAfterColumns) {
      const diff = totalWidth - resizeStartWidth;
      resizeSets.push({
        columns: groupAfterColumns,
        ratios: groupAfterRatios,
        width: groupAfterStartWidth - diff
      });
    }
    (_a4 = this.beans.colResize) == null ? void 0 : _a4.resizeColumnSets({
      resizeSets,
      finished,
      source
    });
    if (finished) {
      this.toggleColumnResizing(false);
    }
  }
  toggleColumnResizing(resizing) {
    this.comp.toggleCss("ag-column-resizing", resizing);
  }
  getColumnsToResize() {
    const leafCols = this.columnGroup.getDisplayedLeafColumns();
    return leafCols.filter((col) => col.isResizable());
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(dragChange) {
    let result = dragChange;
    if (this.gos.get("enableRtl")) {
      if (this.pinned !== "left") {
        result *= -1;
      }
    } else if (this.pinned === "right") {
      result *= -1;
    }
    return result;
  }
  destroy() {
    super.destroy();
    this.resizeCols = void 0;
    this.resizeRatios = void 0;
    this.resizeTakeFromCols = void 0;
    this.resizeTakeFromRatios = void 0;
  }
};
var ResizeFeature = class extends BeanStub {
  constructor(pinned, column, eResize, comp, ctrl) {
    super();
    this.pinned = pinned;
    this.column = column;
    this.eResize = eResize;
    this.comp = comp;
    this.ctrl = ctrl;
  }
  postConstruct() {
    const destroyResizeFuncs = [];
    let canResize;
    let canAutosize;
    const addResize = () => {
      _setDisplayed(this.eResize, canResize);
      if (!canResize) {
        return;
      }
      const { horizontalResizeSvc, colAutosize } = this.beans;
      const finishedWithResizeFunc = horizontalResizeSvc.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, false),
        onResizeEnd: this.onResizing.bind(this, true)
      });
      destroyResizeFuncs.push(finishedWithResizeFunc);
      if (canAutosize && colAutosize) {
        destroyResizeFuncs.push(colAutosize.addColumnAutosize(this.eResize, this.column));
      }
    };
    const removeResize = () => {
      destroyResizeFuncs.forEach((f) => f());
      destroyResizeFuncs.length = 0;
    };
    const refresh = () => {
      const resize = this.column.isResizable();
      const autoSize = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      const propertyChange = resize !== canResize || autoSize !== canAutosize;
      if (propertyChange) {
        canResize = resize;
        canAutosize = autoSize;
        removeResize();
        addResize();
      }
    };
    refresh();
    this.addDestroyFunc(removeResize);
    this.ctrl.setRefreshFunction("resize", refresh);
  }
  onResizing(finished, resizeAmount) {
    var _a4, _b2;
    const { column: key, lastResizeAmount, resizeStartWidth, beans } = this;
    const resizeAmountNormalised = this.normaliseResizeAmount(resizeAmount);
    const newWidth = resizeStartWidth + resizeAmountNormalised;
    const columnWidths = [{ key, newWidth }];
    const { pinnedCols, ctrlsSvc, colResize } = beans;
    if (this.column.getPinned()) {
      const leftWidth = (_a4 = pinnedCols == null ? void 0 : pinnedCols.leftWidth) != null ? _a4 : 0;
      const rightWidth = (_b2 = pinnedCols == null ? void 0 : pinnedCols.rightWidth) != null ? _b2 : 0;
      const bodyWidth = _getInnerWidth(ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
      if (leftWidth + rightWidth + (resizeAmountNormalised - lastResizeAmount) > bodyWidth) {
        return;
      }
    }
    this.lastResizeAmount = resizeAmountNormalised;
    colResize == null ? void 0 : colResize.setColumnWidths(columnWidths, this.resizeWithShiftKey, finished, "uiColumnResized");
    if (finished) {
      this.toggleColumnResizing(false);
    }
  }
  onResizeStart(shiftKey) {
    this.resizeStartWidth = this.column.getActualWidth();
    this.lastResizeAmount = 0;
    this.resizeWithShiftKey = shiftKey;
    this.toggleColumnResizing(true);
  }
  toggleColumnResizing(resizing) {
    this.column.resizing = resizing;
    this.comp.toggleCss("ag-column-resizing", resizing);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(dragChange) {
    let result = dragChange;
    const notPinningLeft = this.pinned !== "left";
    const pinningRight = this.pinned === "right";
    if (this.gos.get("enableRtl")) {
      if (notPinningLeft) {
        result *= -1;
      }
    } else {
      if (pinningRight) {
        result *= -1;
      }
    }
    return result;
  }
};
var ColumnResizeService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colResize";
  }
  setColumnWidths(columnWidths, shiftKey, finished, source) {
    const sets = [];
    const { colModel, gos, visibleCols } = this.beans;
    columnWidths.forEach((columnWidth) => {
      const col = colModel.getColDefCol(columnWidth.key) || colModel.getCol(columnWidth.key);
      if (!col) {
        return;
      }
      sets.push({
        width: columnWidth.newWidth,
        ratios: [1],
        columns: [col]
      });
      const defaultIsShift = gos.get("colResizeDefault") === "shift";
      if (defaultIsShift) {
        shiftKey = !shiftKey;
      }
      if (shiftKey) {
        const otherCol = visibleCols.getColAfter(col);
        if (!otherCol) {
          return;
        }
        const widthDiff = col.getActualWidth() - columnWidth.newWidth;
        const otherColWidth = otherCol.getActualWidth() + widthDiff;
        sets.push({
          width: otherColWidth,
          ratios: [1],
          columns: [otherCol]
        });
      }
    });
    if (sets.length === 0) {
      return;
    }
    this.resizeColumnSets({
      resizeSets: sets,
      finished,
      source
    });
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(params) {
    var _a4;
    const { resizeSets, finished, source } = params;
    const passMinMaxCheck = !resizeSets || resizeSets.every((columnResizeSet) => checkMinAndMaxWidthsForSet(columnResizeSet));
    if (!passMinMaxCheck) {
      if (finished) {
        const columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;
        dispatchColumnResizedEvent(this.eventSvc, columns, finished, source);
      }
      return;
    }
    const changedCols = [];
    const allResizedCols = [];
    resizeSets.forEach((set) => {
      const { width, columns, ratios } = set;
      const newWidths = {};
      const finishedCols = {};
      columns.forEach((col) => allResizedCols.push(col));
      let finishedColsGrew = true;
      let loopCount = 0;
      while (finishedColsGrew) {
        loopCount++;
        if (loopCount > 1e3) {
          _error(31);
          break;
        }
        finishedColsGrew = false;
        const subsetCols = [];
        let subsetRatioTotal = 0;
        let pixelsToDistribute = width;
        columns.forEach((col, index) => {
          const thisColFinished = finishedCols[col.getId()];
          if (thisColFinished) {
            pixelsToDistribute -= newWidths[col.getId()];
          } else {
            subsetCols.push(col);
            const ratioThisCol = ratios[index];
            subsetRatioTotal += ratioThisCol;
          }
        });
        const ratioScale = 1 / subsetRatioTotal;
        subsetCols.forEach((col, index) => {
          const lastCol = index === subsetCols.length - 1;
          let colNewWidth;
          if (lastCol) {
            colNewWidth = pixelsToDistribute;
          } else {
            colNewWidth = Math.round(ratios[index] * width * ratioScale);
            pixelsToDistribute -= colNewWidth;
          }
          const minWidth = col.getMinWidth();
          const maxWidth = col.getMaxWidth();
          if (colNewWidth < minWidth) {
            colNewWidth = minWidth;
            finishedCols[col.getId()] = true;
            finishedColsGrew = true;
          } else if (maxWidth > 0 && colNewWidth > maxWidth) {
            colNewWidth = maxWidth;
            finishedCols[col.getId()] = true;
            finishedColsGrew = true;
          }
          newWidths[col.getId()] = colNewWidth;
        });
      }
      columns.forEach((col) => {
        const newWidth = newWidths[col.getId()];
        const actualWidth = col.getActualWidth();
        if (actualWidth !== newWidth) {
          col.setActualWidth(newWidth, source);
          changedCols.push(col);
        }
      });
    });
    const atLeastOneColChanged = changedCols.length > 0;
    let flexedCols = [];
    if (atLeastOneColChanged) {
      const { colFlex, visibleCols, colViewport } = this.beans;
      flexedCols = (_a4 = colFlex == null ? void 0 : colFlex.refreshFlexedColumns({
        resizingCols: allResizedCols,
        skipSetLeft: true
      })) != null ? _a4 : [];
      visibleCols.setLeftValues(source);
      visibleCols.updateBodyWidths();
      colViewport.checkViewportColumns();
    }
    const colsForEvent = allResizedCols.concat(flexedCols);
    if (atLeastOneColChanged || finished) {
      dispatchColumnResizedEvent(this.eventSvc, colsForEvent, finished, source, flexedCols);
    }
  }
  resizeHeader(column, delta, shiftKey) {
    if (!column.isResizable()) {
      return;
    }
    const actualWidth = column.getActualWidth();
    const minWidth = column.getMinWidth();
    const maxWidth = column.getMaxWidth();
    const newWidth = Math.min(Math.max(actualWidth + delta, minWidth), maxWidth);
    this.setColumnWidths([{ key: column, newWidth }], shiftKey, true, "uiColumnResized");
  }
  createResizeFeature(pinned, column, eResize, comp, ctrl) {
    return new ResizeFeature(pinned, column, eResize, comp, ctrl);
  }
  createGroupResizeFeature(comp, eResize, pinned, columnGroup) {
    return new GroupResizeFeature(comp, eResize, pinned, columnGroup);
  }
};
function checkMinAndMaxWidthsForSet(columnResizeSet) {
  const { columns, width } = columnResizeSet;
  let minWidthAccumulated = 0;
  let maxWidthAccumulated = 0;
  let maxWidthActive = true;
  columns.forEach((col) => {
    const minWidth = col.getMinWidth();
    minWidthAccumulated += minWidth || 0;
    const maxWidth = col.getMaxWidth();
    if (maxWidth > 0) {
      maxWidthAccumulated += maxWidth;
    } else {
      maxWidthActive = false;
    }
  });
  const minWidthPasses = width >= minWidthAccumulated;
  const maxWidthPasses = !maxWidthActive || width <= maxWidthAccumulated;
  return minWidthPasses && maxWidthPasses;
}
var ColumnResizeModule = {
  moduleName: "ColumnResize",
  version: VERSION,
  beans: [ColumnResizeService],
  apiFunctions: {
    setColumnWidths
  },
  dependsOn: [HorizontalResizeModule, AutoWidthModule]
};
var GroupWidthFeature = class extends BeanStub {
  constructor(comp, columnGroup) {
    super();
    this.removeChildListenersFuncs = [];
    this.columnGroup = columnGroup;
    this.comp = comp;
  }
  postConstruct() {
    this.addListenersToChildrenColumns();
    this.addManagedListeners(this.columnGroup, {
      displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this)
    });
    this.onWidthChanged();
    this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const widthChangedListener = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((column) => {
      column.__addEventListener("widthChanged", widthChangedListener);
      column.__addEventListener("visibleChanged", widthChangedListener);
      this.removeChildListenersFuncs.push(() => {
        column.__removeEventListener("widthChanged", widthChangedListener);
        column.__removeEventListener("visibleChanged", widthChangedListener);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((func) => func());
    this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns();
    this.onWidthChanged();
  }
  onWidthChanged() {
    const columnWidth = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${columnWidth}px`);
    this.comp.toggleCss("ag-hidden", columnWidth === 0);
  }
};
var HeaderGroupCellCtrl = class extends AbstractHeaderCellCtrl {
  constructor() {
    super(...arguments);
    this.onSuppressColMoveChange = () => {
      if (!this.isAlive() || this.isSuppressMoving()) {
        this.removeDragSource();
      } else {
        if (!this.dragSource) {
          this.setDragSource(this.eGui);
        }
      }
    };
  }
  wireComp(comp, eGui, eResize, eHeaderCompWrapper, compBean) {
    const { column, beans } = this;
    const { context, colNames, colHover, rangeSvc, colResize } = beans;
    this.comp = comp;
    compBean = setupCompBean(this, context, compBean);
    this.setGui(eGui, compBean);
    this.displayName = colNames.getDisplayNameForColumnGroup(column, "header");
    this.refreshHeaderStyles();
    this.addClasses();
    this.setupMovingCss(compBean);
    this.setupExpandable(compBean);
    this.setupTooltip();
    this.setupAutoHeight({
      wrapperElement: eHeaderCompWrapper,
      compBean
    });
    this.setupUserComp();
    this.addHeaderMouseListeners(compBean);
    this.addManagedPropertyListener("groupHeaderHeight", this.refreshMaxHeaderHeight.bind(this));
    this.refreshMaxHeaderHeight();
    const pinned = this.rowCtrl.pinned;
    const leafCols = column.getProvidedColumnGroup().getLeafColumns();
    colHover == null ? void 0 : colHover.createHoverFeature(compBean, leafCols, eGui);
    rangeSvc == null ? void 0 : rangeSvc.createRangeHighlightFeature(compBean, column, comp);
    compBean.createManagedBean(new SetLeftFeature(column, eGui, beans));
    compBean.createManagedBean(new GroupWidthFeature(comp, column));
    if (colResize) {
      this.resizeFeature = compBean.createManagedBean(
        colResize.createGroupResizeFeature(comp, eResize, pinned, column)
      );
    } else {
      comp.setResizableDisplayed(false);
    }
    compBean.createManagedBean(
      new ManagedFocusFeature(eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: () => void 0,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    );
    this.addHighlightListeners(compBean, leafCols);
    compBean.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange);
    this.addResizeAndMoveKeyboardListeners(compBean);
    compBean.addDestroyFunc(() => this.clearComponent());
  }
  getHeaderClassParams() {
    const { column, beans } = this;
    const colDef = column.getDefinition();
    return _addGridCommonParams(beans.gos, {
      colDef,
      columnGroup: column,
      floatingFilter: false
    });
  }
  refreshMaxHeaderHeight() {
    const { gos, comp } = this;
    const groupHeaderHeight = gos.get("groupHeaderHeight");
    if (groupHeaderHeight != null) {
      if (groupHeaderHeight === 0) {
        comp.setHeaderWrapperHidden(true);
      } else {
        comp.setHeaderWrapperMaxHeight(groupHeaderHeight);
      }
    } else {
      comp.setHeaderWrapperHidden(false);
      comp.setHeaderWrapperMaxHeight(null);
    }
  }
  addHighlightListeners(compBean, columns) {
    if (!this.beans.gos.get("suppressMoveWhenColumnDragging")) {
      return;
    }
    for (const column of columns) {
      compBean.addManagedListeners(column, {
        headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(this, column)
      });
    }
  }
  onLeafColumnHighlightChanged(column) {
    const displayedColumns = this.column.getDisplayedLeafColumns();
    const isFirst = displayedColumns[0] === column;
    const isLast = _last(displayedColumns) === column;
    if (!isFirst && !isLast) {
      return;
    }
    const highlighted = column.getHighlighted();
    const isColumnMoveAtThisLevel = !!this.rowCtrl.getHeaderCellCtrls().find((ctrl) => {
      return ctrl.column.isMoving();
    });
    let beforeOn = false;
    let afterOn = false;
    if (isColumnMoveAtThisLevel) {
      const isRtl = this.beans.gos.get("enableRtl");
      const isHighlightAfter = highlighted === 1;
      const isHighlightBefore = highlighted === 0;
      if (isFirst) {
        if (isRtl) {
          afterOn = isHighlightAfter;
        } else {
          beforeOn = isHighlightBefore;
        }
      }
      if (isLast) {
        if (isRtl) {
          beforeOn = isHighlightBefore;
        } else {
          afterOn = isHighlightAfter;
        }
      }
    }
    this.comp.toggleCss("ag-header-highlight-before", beforeOn);
    this.comp.toggleCss("ag-header-highlight-after", afterOn);
  }
  resizeHeader(delta, shiftKey) {
    const { resizeFeature } = this;
    if (!resizeFeature) {
      return;
    }
    const initialValues = resizeFeature.getInitialValues(shiftKey);
    resizeFeature.resizeColumns(initialValues, initialValues.resizeStartWidth + delta, "uiColumnResized", true);
  }
  resizeLeafColumnsToFit(source) {
    var _a4;
    (_a4 = this.resizeFeature) == null ? void 0 : _a4.resizeLeafColumnsToFit(source);
  }
  setupUserComp() {
    const { colGroupSvc, userCompFactory, gos, enterpriseMenuFactory } = this.beans;
    const columnGroup = this.column;
    const providedColumnGroup = columnGroup.getProvidedColumnGroup();
    const params = _addGridCommonParams(gos, {
      displayName: this.displayName,
      columnGroup,
      setExpanded: (expanded) => {
        colGroupSvc.setColumnGroupOpened(providedColumnGroup, expanded, "gridInitializing");
      },
      setTooltip: (value, shouldDisplayTooltip) => {
        gos.assertModuleRegistered("Tooltip", 3);
        this.setupTooltip(value, shouldDisplayTooltip);
      },
      showColumnMenu: (buttonElement, onClosedCallback) => enterpriseMenuFactory == null ? void 0 : enterpriseMenuFactory.showMenuAfterButtonClick(
        providedColumnGroup,
        buttonElement,
        "columnMenu",
        onClosedCallback
      ),
      showColumnMenuAfterMouseClick: (mouseEvent, onClosedCallback) => enterpriseMenuFactory == null ? void 0 : enterpriseMenuFactory.showMenuAfterMouseEvent(
        providedColumnGroup,
        mouseEvent,
        "columnMenu",
        onClosedCallback
      ),
      eGridHeader: this.eGui
    });
    const compDetails = _getHeaderGroupCompDetails(userCompFactory, params);
    if (compDetails) {
      this.comp.setUserCompDetails(compDetails);
    }
  }
  addHeaderMouseListeners(compBean) {
    const listener = (e) => this.handleMouseOverChange(e.type === "mouseenter");
    const clickListener = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup());
    const contextMenuListener = (event) => this.handleContextMenuMouseEvent(event, void 0, this.column.getProvidedColumnGroup());
    compBean.addManagedListeners(this.eGui, {
      mouseenter: listener,
      mouseleave: listener,
      click: clickListener,
      contextmenu: contextMenuListener
    });
  }
  handleMouseOverChange(isMouseOver) {
    this.eventSvc.dispatchEvent({
      type: isMouseOver ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column.getProvidedColumnGroup()
    });
  }
  setupTooltip(value, shouldDisplayTooltip) {
    var _a4;
    this.tooltipFeature = (_a4 = this.beans.tooltipSvc) == null ? void 0 : _a4.setupHeaderGroupTooltip(
      this.tooltipFeature,
      this,
      value,
      shouldDisplayTooltip
    );
  }
  setupExpandable(compBean) {
    const providedColGroup = this.column.getProvidedColumnGroup();
    this.refreshExpanded();
    const listener = this.refreshExpanded.bind(this);
    compBean.addManagedListeners(providedColGroup, {
      expandedChanged: listener,
      expandableChanged: listener
    });
  }
  refreshExpanded() {
    const { column } = this;
    this.expandable = column.isExpandable();
    const expanded = column.isExpanded();
    if (this.expandable) {
      this.comp.setAriaExpanded(expanded ? "true" : "false");
    } else {
      this.comp.setAriaExpanded(void 0);
    }
    this.refreshHeaderStyles();
  }
  addClasses() {
    const { column } = this;
    const colGroupDef = column.getColGroupDef();
    const classes = _getHeaderClassesFromColDef(colGroupDef, this.gos, null, column);
    if (column.isPadding()) {
      classes.push("ag-header-group-cell-no-group");
      const leafCols = column.getLeafColumns();
      if (leafCols.every((col) => col.isSpanHeaderHeight())) {
        classes.push("ag-header-span-height");
      }
    } else {
      classes.push("ag-header-group-cell-with-group");
      if (colGroupDef == null ? void 0 : colGroupDef.wrapHeaderText) {
        classes.push("ag-header-cell-wrap-text");
      }
    }
    classes.forEach((c) => this.comp.toggleCss(c, true));
  }
  setupMovingCss(compBean) {
    const { column } = this;
    const providedColumnGroup = column.getProvidedColumnGroup();
    const leafColumns = providedColumnGroup.getLeafColumns();
    const listener = () => this.comp.toggleCss("ag-header-cell-moving", column.isMoving());
    leafColumns.forEach((col) => {
      compBean.addManagedListeners(col, { movingChanged: listener });
    });
    listener();
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      this.focusThis();
    }
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const wrapperHasFocus = this.getWrapperHasFocus();
    if (!this.expandable || !wrapperHasFocus) {
      return;
    }
    if (e.key === KeyCode.ENTER) {
      const column = this.column;
      const newExpandedValue = !column.isExpanded();
      this.beans.colGroupSvc.setColumnGroupOpened(
        column.getProvidedColumnGroup(),
        newExpandedValue,
        "uiColumnExpanded"
      );
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(eHeaderGroup) {
    var _a4, _b2;
    if (!this.isAlive() || this.isSuppressMoving()) {
      return;
    }
    this.removeDragSource();
    if (!eHeaderGroup) {
      return;
    }
    this.dragSource = (_b2 = (_a4 = this.beans.colMoves) == null ? void 0 : _a4.setDragSourceForHeader(eHeaderGroup, this.column, this.displayName)) != null ? _b2 : null;
  }
  isSuppressMoving() {
    return this.gos.get("suppressMovableColumns") || this.column.getLeafColumns().some((column) => column.getColDef().suppressMovable || column.getColDef().lockPosition);
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature);
    super.destroy();
  }
};
function setColumnGroupOpened(beans, group, newValue) {
  var _a4;
  (_a4 = beans.colGroupSvc) == null ? void 0 : _a4.setColumnGroupOpened(group, newValue, "api");
}
function getColumnGroup(beans, name, instanceId) {
  var _a4, _b2;
  return (_b2 = (_a4 = beans.colGroupSvc) == null ? void 0 : _a4.getColumnGroup(name, instanceId)) != null ? _b2 : null;
}
function getProvidedColumnGroup(beans, name) {
  var _a4, _b2;
  return (_b2 = (_a4 = beans.colGroupSvc) == null ? void 0 : _a4.getProvidedColGroup(name)) != null ? _b2 : null;
}
function getDisplayNameForColumnGroup(beans, columnGroup, location) {
  return beans.colNames.getDisplayNameForColumnGroup(columnGroup, location) || "";
}
function getColumnGroupState(beans) {
  var _a4, _b2;
  return (_b2 = (_a4 = beans.colGroupSvc) == null ? void 0 : _a4.getColumnGroupState()) != null ? _b2 : [];
}
function setColumnGroupState(beans, stateItems) {
  var _a4;
  (_a4 = beans.colGroupSvc) == null ? void 0 : _a4.setColumnGroupState(stateItems, "api");
}
function resetColumnGroupState(beans) {
  var _a4;
  (_a4 = beans.colGroupSvc) == null ? void 0 : _a4.resetColumnGroupState("api");
}
function getLeftDisplayedColumnGroups(beans) {
  return beans.visibleCols.treeLeft;
}
function getCenterDisplayedColumnGroups(beans) {
  return beans.visibleCols.treeCenter;
}
function getRightDisplayedColumnGroups(beans) {
  return beans.visibleCols.treeRight;
}
function getAllDisplayedColumnGroups(beans) {
  return beans.visibleCols.getAllTrees();
}
function _removeAllFromUnorderedArray(array, toRemove) {
  for (let i = 0; i < toRemove.length; i++) {
    const index = array.indexOf(toRemove[i]);
    if (index >= 0) {
      array[index] = array[array.length - 1];
      array.pop();
    }
  }
}
var VisibleColsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "visibleCols";
    this.colsAndGroupsMap = {};
    this.leftCols = [];
    this.rightCols = [];
    this.centerCols = [];
    this.allCols = [];
    this.headerGroupRowCount = 0;
    this.bodyWidth = 0;
    this.leftWidth = 0;
    this.rightWidth = 0;
    this.isBodyWidthDirty = true;
  }
  refresh(source, skipTreeBuild = false) {
    const { colFlex, colModel, colGroupSvc, colViewport, selectionColSvc } = this.beans;
    if (!skipTreeBuild) {
      this.buildTrees(colModel, colGroupSvc);
    }
    colGroupSvc == null ? void 0 : colGroupSvc.updateOpenClosedVisibility();
    this.leftCols = pickDisplayedCols(this.treeLeft);
    this.centerCols = pickDisplayedCols(this.treeCenter);
    this.rightCols = pickDisplayedCols(this.treeRight);
    selectionColSvc == null ? void 0 : selectionColSvc.refreshVisibility(this.leftCols, this.centerCols, this.rightCols);
    this.joinColsAriaOrder(colModel);
    this.joinCols();
    this.headerGroupRowCount = this.getHeaderRowCount();
    this.setLeftValues(source);
    this.autoHeightCols = this.allCols.filter((col) => col.isAutoHeight());
    colFlex == null ? void 0 : colFlex.refreshFlexedColumns();
    this.updateBodyWidths();
    this.setFirstRightAndLastLeftPinned(colModel, this.leftCols, this.rightCols, source);
    colViewport.checkViewportColumns(false);
    this.eventSvc.dispatchEvent({
      type: "displayedColumnsChanged",
      source
    });
  }
  getHeaderRowCount() {
    if (!this.gos.get("hidePaddedHeaderRows")) {
      return this.beans.colModel.cols.treeDepth;
    }
    let headerGroupRowCount = 0;
    for (const col of this.allCols) {
      let parent = col.getParent();
      while (parent) {
        if (!parent.isPadding()) {
          const level = parent.getProvidedColumnGroup().getLevel() + 1;
          if (level > headerGroupRowCount) {
            headerGroupRowCount = level;
          }
          break;
        }
        parent = parent.getParent();
      }
    }
    return headerGroupRowCount;
  }
  // after setColumnWidth or updateGroupsAndPresentedCols
  updateBodyWidths() {
    const newBodyWidth = getWidthOfColsInList(this.centerCols);
    const newLeftWidth = getWidthOfColsInList(this.leftCols);
    const newRightWidth = getWidthOfColsInList(this.rightCols);
    this.isBodyWidthDirty = this.bodyWidth !== newBodyWidth;
    const atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;
    if (atLeastOneChanged) {
      this.bodyWidth = newBodyWidth;
      this.leftWidth = newLeftWidth;
      this.rightWidth = newRightWidth;
      this.eventSvc.dispatchEvent({
        type: "columnContainerWidthChanged"
      });
      this.eventSvc.dispatchEvent({
        type: "displayedColumnsWidthChanged"
      });
    }
  }
  // sets the left pixel position of each column
  setLeftValues(source) {
    this.setLeftValuesOfCols(source);
    this.setLeftValuesOfGroups();
  }
  setFirstRightAndLastLeftPinned(colModel, leftCols, rightCols, source) {
    let lastLeft;
    let firstRight;
    if (this.gos.get("enableRtl")) {
      lastLeft = leftCols ? leftCols[0] : null;
      firstRight = rightCols ? _last(rightCols) : null;
    } else {
      lastLeft = leftCols ? _last(leftCols) : null;
      firstRight = rightCols ? rightCols[0] : null;
    }
    colModel.getCols().forEach((col) => {
      col.setLastLeftPinned(col === lastLeft, source);
      col.setFirstRightPinned(col === firstRight, source);
    });
  }
  buildTrees(colModel, columnGroupSvc) {
    const cols = colModel.getColsToShow();
    const leftCols = cols.filter((col) => col.getPinned() == "left");
    const rightCols = cols.filter((col) => col.getPinned() == "right");
    const centerCols = cols.filter((col) => col.getPinned() != "left" && col.getPinned() != "right");
    const idCreator = new GroupInstanceIdCreator();
    const createGroups = (params) => {
      return columnGroupSvc ? columnGroupSvc.createColumnGroups(params) : params.columns;
    };
    this.treeLeft = createGroups({
      columns: leftCols,
      idCreator,
      pinned: "left",
      oldDisplayedGroups: this.treeLeft
    });
    this.treeRight = createGroups({
      columns: rightCols,
      idCreator,
      pinned: "right",
      oldDisplayedGroups: this.treeRight
    });
    this.treeCenter = createGroups({
      columns: centerCols,
      idCreator,
      pinned: null,
      oldDisplayedGroups: this.treeCenter
    });
    this.updateColsAndGroupsMap();
  }
  clear() {
    this.leftCols = [];
    this.rightCols = [];
    this.centerCols = [];
    this.allCols = [];
    this.ariaOrderColumns = [];
  }
  joinColsAriaOrder(colModel) {
    const allColumns = colModel.getCols();
    const pinnedLeft = [];
    const center = [];
    const pinnedRight = [];
    for (const col of allColumns) {
      const pinned = col.getPinned();
      if (!pinned) {
        center.push(col);
      } else if (pinned === true || pinned === "left") {
        pinnedLeft.push(col);
      } else {
        pinnedRight.push(col);
      }
    }
    this.ariaOrderColumns = pinnedLeft.concat(center).concat(pinnedRight);
  }
  getAriaColIndex(colOrGroup) {
    let col;
    if (isColumnGroup(colOrGroup)) {
      col = colOrGroup.getLeafColumns()[0];
    } else {
      col = colOrGroup;
    }
    return this.ariaOrderColumns.indexOf(col) + 1;
  }
  setLeftValuesOfGroups() {
    [this.treeLeft, this.treeRight, this.treeCenter].forEach((columns) => {
      columns.forEach((column) => {
        if (isColumnGroup(column)) {
          const columnGroup = column;
          columnGroup.checkLeft();
        }
      });
    });
  }
  setLeftValuesOfCols(source) {
    const { colModel } = this.beans;
    const primaryCols = colModel.getColDefCols();
    if (!primaryCols) {
      return;
    }
    const allColumns = colModel.getCols().slice(0);
    const doingRtl = this.gos.get("enableRtl");
    [this.leftCols, this.rightCols, this.centerCols].forEach((columns) => {
      if (doingRtl) {
        let left = getWidthOfColsInList(columns);
        columns.forEach((column) => {
          left -= column.getActualWidth();
          column.setLeft(left, source);
        });
      } else {
        let left = 0;
        columns.forEach((column) => {
          column.setLeft(left, source);
          left += column.getActualWidth();
        });
      }
      _removeAllFromUnorderedArray(allColumns, columns);
    });
    allColumns.forEach((column) => {
      column.setLeft(null, source);
    });
  }
  joinCols() {
    if (this.gos.get("enableRtl")) {
      this.allCols = this.rightCols.concat(this.centerCols).concat(this.leftCols);
    } else {
      this.allCols = this.leftCols.concat(this.centerCols).concat(this.rightCols);
    }
  }
  getAllTrees() {
    if (this.treeLeft && this.treeRight && this.treeCenter) {
      return this.treeLeft.concat(this.treeCenter).concat(this.treeRight);
    }
    return null;
  }
  // gridPanel -> ensureColumnVisible
  isColDisplayed(column) {
    return this.allCols.indexOf(column) >= 0;
  }
  getLeftColsForRow(rowNode) {
    const {
      leftCols,
      beans: { colModel }
    } = this;
    const colSpanActive = colModel.colSpanActive;
    if (!colSpanActive) {
      return leftCols;
    }
    return this.getColsForRow(rowNode, leftCols);
  }
  getRightColsForRow(rowNode) {
    const {
      rightCols,
      beans: { colModel }
    } = this;
    const colSpanActive = colModel.colSpanActive;
    if (!colSpanActive) {
      return rightCols;
    }
    return this.getColsForRow(rowNode, rightCols);
  }
  getColsForRow(rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {
    const result = [];
    let lastConsideredCol = null;
    for (let i = 0; i < displayedColumns.length; i++) {
      const col = displayedColumns[i];
      const maxAllowedColSpan = displayedColumns.length - i;
      const colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);
      const columnsToCheckFilter = [col];
      if (colSpan > 1) {
        const colsToRemove = colSpan - 1;
        for (let j = 1; j <= colsToRemove; j++) {
          columnsToCheckFilter.push(displayedColumns[i + j]);
        }
        i += colsToRemove;
      }
      let filterPasses;
      if (filterCallback) {
        filterPasses = false;
        columnsToCheckFilter.forEach((colForFilter) => {
          if (filterCallback(colForFilter)) {
            filterPasses = true;
          }
        });
      } else {
        filterPasses = true;
      }
      if (filterPasses) {
        if (result.length === 0 && lastConsideredCol) {
          const gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;
          if (gapBeforeColumn) {
            result.push(lastConsideredCol);
          }
        }
        result.push(col);
      }
      lastConsideredCol = col;
    }
    return result;
  }
  getContainerWidth(pinned) {
    switch (pinned) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  getColBefore(col) {
    const allDisplayedColumns = this.allCols;
    const oldIndex = allDisplayedColumns.indexOf(col);
    if (oldIndex > 0) {
      return allDisplayedColumns[oldIndex - 1];
    }
    return null;
  }
  isPinningLeft() {
    return this.leftCols.length > 0;
  }
  isPinningRight() {
    return this.rightCols.length > 0;
  }
  updateColsAndGroupsMap() {
    this.colsAndGroupsMap = {};
    const func = (child) => {
      this.colsAndGroupsMap[child.getUniqueId()] = child;
    };
    depthFirstAllColumnTreeSearch(this.treeCenter, false, func);
    depthFirstAllColumnTreeSearch(this.treeLeft, false, func);
    depthFirstAllColumnTreeSearch(this.treeRight, false, func);
  }
  isVisible(item) {
    const fromMap = this.colsAndGroupsMap[item.getUniqueId()];
    return fromMap === item;
  }
  getFirstColumn() {
    const isRtl = this.gos.get("enableRtl");
    const queryOrder = ["leftCols", "centerCols", "rightCols"];
    if (isRtl) {
      queryOrder.reverse();
    }
    for (let i = 0; i < queryOrder.length; i++) {
      const container = this[queryOrder[i]];
      if (container.length) {
        return isRtl ? _last(container) : container[0];
      }
    }
    return null;
  }
  // used by:
  // + rowRenderer -> for navigation
  getColAfter(col) {
    const allDisplayedColumns = this.allCols;
    const oldIndex = allDisplayedColumns.indexOf(col);
    if (oldIndex < allDisplayedColumns.length - 1) {
      return allDisplayedColumns[oldIndex + 1];
    }
    return null;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getColsLeftWidth() {
    return getWidthOfColsInList(this.leftCols);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return getWidthOfColsInList(this.rightCols);
  }
  isColAtEdge(col, edge) {
    const allColumns = this.allCols;
    if (!allColumns.length) {
      return false;
    }
    const isFirst = edge === "first";
    let columnToCompare;
    if (isColumnGroup(col)) {
      const leafColumns = col.getDisplayedLeafColumns();
      if (!leafColumns.length) {
        return false;
      }
      columnToCompare = isFirst ? leafColumns[0] : _last(leafColumns);
    } else {
      columnToCompare = col;
    }
    return (isFirst ? allColumns[0] : _last(allColumns)) === columnToCompare;
  }
};
function depthFirstAllColumnTreeSearch(tree, useDisplayedChildren, callback) {
  if (!tree) {
    return;
  }
  for (let i = 0; i < tree.length; i++) {
    const child = tree[i];
    if (isColumnGroup(child)) {
      const childTree = useDisplayedChildren ? child.getDisplayedChildren() : child.getChildren();
      depthFirstAllColumnTreeSearch(childTree, useDisplayedChildren, callback);
    }
    callback(child);
  }
}
function pickDisplayedCols(tree) {
  const res = [];
  depthFirstAllColumnTreeSearch(tree, true, (child) => {
    if (isColumn(child)) {
      res.push(child);
    }
  });
  return res;
}
var ColumnGroupService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colGroupSvc";
  }
  getColumnGroupState() {
    const columnGroupState = [];
    const gridBalancedTree = this.beans.colModel.getColTree();
    depthFirstOriginalTreeSearch(null, gridBalancedTree, (node) => {
      if (isProvidedColumnGroup(node)) {
        columnGroupState.push({
          groupId: node.getGroupId(),
          open: node.isExpanded()
        });
      }
    });
    return columnGroupState;
  }
  resetColumnGroupState(source) {
    const primaryColumnTree = this.beans.colModel.getColDefColTree();
    if (!primaryColumnTree) {
      return;
    }
    const stateItems = [];
    depthFirstOriginalTreeSearch(null, primaryColumnTree, (child) => {
      if (isProvidedColumnGroup(child)) {
        const colGroupDef = child.getColGroupDef();
        const groupState = {
          groupId: child.getGroupId(),
          open: !colGroupDef ? void 0 : colGroupDef.openByDefault
        };
        stateItems.push(groupState);
      }
    });
    this.setColumnGroupState(stateItems, source);
  }
  setColumnGroupState(stateItems, source) {
    const { colModel, colAnimation, visibleCols, eventSvc } = this.beans;
    const gridBalancedTree = colModel.getColTree();
    if (!gridBalancedTree.length) {
      return;
    }
    colAnimation == null ? void 0 : colAnimation.start();
    const impactedGroups = [];
    stateItems.forEach((stateItem) => {
      const groupKey = stateItem.groupId;
      const newValue = stateItem.open;
      const providedColumnGroup = this.getProvidedColGroup(groupKey);
      if (!providedColumnGroup) {
        return;
      }
      if (providedColumnGroup.isExpanded() === newValue) {
        return;
      }
      providedColumnGroup.setExpanded(newValue);
      impactedGroups.push(providedColumnGroup);
    });
    visibleCols.refresh(source, true);
    if (impactedGroups.length) {
      eventSvc.dispatchEvent({
        type: "columnGroupOpened",
        columnGroup: impactedGroups.length === 1 ? impactedGroups[0] : void 0,
        columnGroups: impactedGroups
      });
    }
    colAnimation == null ? void 0 : colAnimation.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(key, newValue, source) {
    let keyAsString;
    if (isProvidedColumnGroup(key)) {
      keyAsString = key.getId();
    } else {
      keyAsString = key || "";
    }
    this.setColumnGroupState([{ groupId: keyAsString, open: newValue }], source);
  }
  getProvidedColGroup(key) {
    let res = null;
    depthFirstOriginalTreeSearch(null, this.beans.colModel.getColTree(), (node) => {
      if (isProvidedColumnGroup(node)) {
        if (node.getId() === key) {
          res = node;
        }
      }
    });
    return res;
  }
  getGroupAtDirection(columnGroup, direction) {
    const requiredLevel = columnGroup.getProvidedColumnGroup().getLevel() + columnGroup.getPaddingLevel();
    const colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();
    const col = direction === "After" ? _last(colGroupLeafColumns) : colGroupLeafColumns[0];
    const getDisplayColMethod = `getCol${direction}`;
    while (true) {
      const column = this.beans.visibleCols[getDisplayColMethod](col);
      if (!column) {
        return null;
      }
      const groupPointer = this.getColGroupAtLevel(column, requiredLevel);
      if (groupPointer !== columnGroup) {
        return groupPointer;
      }
    }
  }
  getColGroupAtLevel(column, level) {
    let groupPointer = column.getParent();
    let originalGroupLevel;
    let groupPointerLevel;
    while (true) {
      const groupPointerProvidedColumnGroup = groupPointer.getProvidedColumnGroup();
      originalGroupLevel = groupPointerProvidedColumnGroup.getLevel();
      groupPointerLevel = groupPointer.getPaddingLevel();
      if (originalGroupLevel + groupPointerLevel <= level) {
        break;
      }
      groupPointer = groupPointer.getParent();
    }
    return groupPointer;
  }
  updateOpenClosedVisibility() {
    const allColumnGroups = this.beans.visibleCols.getAllTrees();
    depthFirstAllColumnTreeSearch(allColumnGroups, false, (child) => {
      if (isColumnGroup(child)) {
        child.calculateDisplayedColumns();
      }
    });
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(colId, partId) {
    if (!colId) {
      return null;
    }
    if (isColumnGroup(colId)) {
      return colId;
    }
    const allColumnGroups = this.beans.visibleCols.getAllTrees();
    const checkPartId = typeof partId === "number";
    let result = null;
    depthFirstAllColumnTreeSearch(allColumnGroups, false, (child) => {
      if (isColumnGroup(child)) {
        const columnGroup = child;
        let matched;
        if (checkPartId) {
          matched = colId === columnGroup.getGroupId() && partId === columnGroup.getPartId();
        } else {
          matched = colId === columnGroup.getGroupId();
        }
        if (matched) {
          result = columnGroup;
        }
      }
    });
    return result;
  }
  createColumnGroups(params) {
    const { columns, idCreator, pinned, oldDisplayedGroups, isStandaloneStructure } = params;
    const oldColumnsMapped = this.mapOldGroupsById(oldDisplayedGroups);
    const topLevelResultCols = [];
    let groupsOrColsAtCurrentLevel = columns;
    while (groupsOrColsAtCurrentLevel.length) {
      const currentlyIterating = groupsOrColsAtCurrentLevel;
      groupsOrColsAtCurrentLevel = [];
      let lastGroupedColIdx = 0;
      const createGroupToIndex = (to) => {
        const from = lastGroupedColIdx;
        lastGroupedColIdx = to;
        const previousNode = currentlyIterating[from];
        const previousNodeProvided = isColumnGroup(previousNode) ? previousNode.getProvidedColumnGroup() : previousNode;
        const previousNodeParent = previousNodeProvided.getOriginalParent();
        if (previousNodeParent == null) {
          for (let i = from; i < to; i++) {
            topLevelResultCols.push(currentlyIterating[i]);
          }
          return;
        }
        const newGroup = this.createColumnGroup(
          previousNodeParent,
          idCreator,
          oldColumnsMapped,
          pinned,
          isStandaloneStructure
        );
        for (let i = from; i < to; i++) {
          newGroup.addChild(currentlyIterating[i]);
        }
        groupsOrColsAtCurrentLevel.push(newGroup);
      };
      for (let i = 1; i < currentlyIterating.length; i++) {
        const thisNode = currentlyIterating[i];
        const thisNodeProvided = isColumnGroup(thisNode) ? thisNode.getProvidedColumnGroup() : thisNode;
        const thisNodeParent = thisNodeProvided.getOriginalParent();
        const previousNode = currentlyIterating[lastGroupedColIdx];
        const previousNodeProvided = isColumnGroup(previousNode) ? previousNode.getProvidedColumnGroup() : previousNode;
        const previousNodeParent = previousNodeProvided.getOriginalParent();
        if (thisNodeParent !== previousNodeParent) {
          createGroupToIndex(i);
        }
      }
      if (lastGroupedColIdx < currentlyIterating.length) {
        createGroupToIndex(currentlyIterating.length);
      }
    }
    if (!isStandaloneStructure) {
      this.setupParentsIntoCols(topLevelResultCols, null);
    }
    return topLevelResultCols;
  }
  createProvidedColumnGroup(primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, existingGroups, source) {
    const groupId = columnKeyCreator.getUniqueKey(colGroupDef.groupId || null, null);
    const colGroupDefMerged = createMergedColGroupDef(this.beans, colGroupDef, groupId);
    const providedGroup = new AgProvidedColumnGroup(colGroupDefMerged, groupId, false, level);
    this.createBean(providedGroup);
    const existingGroupAndIndex = this.findExistingGroup(colGroupDef, existingGroups);
    if (existingGroupAndIndex) {
      existingGroups.splice(existingGroupAndIndex.idx, 1);
    }
    const existingGroup = existingGroupAndIndex == null ? void 0 : existingGroupAndIndex.group;
    if (existingGroup) {
      providedGroup.setExpanded(existingGroup.isExpanded());
    }
    const children = _recursivelyCreateColumns(
      this.beans,
      colGroupDefMerged.children,
      level + 1,
      primaryColumns,
      existingColumns,
      columnKeyCreator,
      existingGroups,
      source
    );
    providedGroup.setChildren(children);
    return providedGroup;
  }
  balanceColumnTree(unbalancedTree, currentDepth, columnDepth, columnKeyCreator) {
    const result = [];
    for (let i = 0; i < unbalancedTree.length; i++) {
      const child = unbalancedTree[i];
      if (isProvidedColumnGroup(child)) {
        const originalGroup = child;
        const newChildren = this.balanceColumnTree(
          originalGroup.getChildren(),
          currentDepth + 1,
          columnDepth,
          columnKeyCreator
        );
        originalGroup.setChildren(newChildren);
        result.push(originalGroup);
      } else {
        let firstPaddedGroup;
        let currentPaddedGroup;
        for (let j = currentDepth; j < columnDepth; j++) {
          const newColId = columnKeyCreator.getUniqueKey(null, null);
          const colGroupDefMerged = createMergedColGroupDef(this.beans, null, newColId);
          const paddedGroup = new AgProvidedColumnGroup(colGroupDefMerged, newColId, true, j);
          this.createBean(paddedGroup);
          if (currentPaddedGroup) {
            currentPaddedGroup.setChildren([paddedGroup]);
          }
          currentPaddedGroup = paddedGroup;
          if (!firstPaddedGroup) {
            firstPaddedGroup = currentPaddedGroup;
          }
        }
        if (firstPaddedGroup && currentPaddedGroup) {
          result.push(firstPaddedGroup);
          const hasGroups = unbalancedTree.some((leaf) => isProvidedColumnGroup(leaf));
          if (hasGroups) {
            currentPaddedGroup.setChildren([child]);
            continue;
          } else {
            currentPaddedGroup.setChildren(unbalancedTree);
            break;
          }
        }
        result.push(child);
      }
    }
    return result;
  }
  findDepth(balancedColumnTree) {
    let depth = 0;
    let pointer = balancedColumnTree;
    while (pointer && pointer[0] && isProvidedColumnGroup(pointer[0])) {
      depth++;
      pointer = pointer[0].getChildren();
    }
    return depth;
  }
  findMaxDepth(treeChildren, depth) {
    let maxDepthThisLevel = depth;
    for (let i = 0; i < treeChildren.length; i++) {
      const abstractColumn = treeChildren[i];
      if (isProvidedColumnGroup(abstractColumn)) {
        const originalGroup = abstractColumn;
        const newDepth = this.findMaxDepth(originalGroup.getChildren(), depth + 1);
        if (maxDepthThisLevel < newDepth) {
          maxDepthThisLevel = newDepth;
        }
      }
    }
    return maxDepthThisLevel;
  }
  /**
   * Inserts dummy group columns in the hierarchy above auto-generated columns
   * in order to ensure auto-generated columns are leaf nodes (and therefore are
   * displayed correctly)
   */
  balanceTreeForAutoCols(autoCols, depth) {
    const tree = [];
    autoCols.forEach((col) => {
      let nextChild = col;
      for (let i = depth - 1; i >= 0; i--) {
        const autoGroup = new AgProvidedColumnGroup(null, `FAKE_PATH_${col.getId()}}_${i}`, true, i);
        this.createBean(autoGroup);
        autoGroup.setChildren([nextChild]);
        nextChild.originalParent = autoGroup;
        nextChild = autoGroup;
      }
      if (depth === 0) {
        col.originalParent = null;
      }
      tree.push(nextChild);
    });
    return tree;
  }
  findExistingGroup(newGroupDef, existingGroups) {
    const newHasId = newGroupDef.groupId != null;
    if (!newHasId) {
      return void 0;
    }
    for (let i = 0; i < existingGroups.length; i++) {
      const existingGroup = existingGroups[i];
      const existingDef = existingGroup.getColGroupDef();
      if (!existingDef) {
        continue;
      }
      if (existingGroup.getId() === newGroupDef.groupId) {
        return { idx: i, group: existingGroup };
      }
    }
    return void 0;
  }
  createColumnGroup(providedGroup, groupInstanceIdCreator, oldColumnsMapped, pinned, isStandaloneStructure) {
    const groupId = providedGroup.getGroupId();
    const instanceId = groupInstanceIdCreator.getInstanceIdForKey(groupId);
    const uniqueId = createUniqueColumnGroupId(groupId, instanceId);
    let columnGroup = oldColumnsMapped[uniqueId];
    if (columnGroup && columnGroup.getProvidedColumnGroup() !== providedGroup) {
      columnGroup = null;
    }
    if (_exists(columnGroup)) {
      columnGroup.reset();
    } else {
      columnGroup = new AgColumnGroup(providedGroup, groupId, instanceId, pinned);
      if (!isStandaloneStructure) {
        this.createBean(columnGroup);
      }
    }
    return columnGroup;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(displayedGroups) {
    const result = {};
    const recursive = (columnsOrGroups) => {
      columnsOrGroups.forEach((columnOrGroup) => {
        if (isColumnGroup(columnOrGroup)) {
          const columnGroup = columnOrGroup;
          result[columnOrGroup.getUniqueId()] = columnGroup;
          recursive(columnGroup.getChildren());
        }
      });
    };
    if (displayedGroups) {
      recursive(displayedGroups);
    }
    return result;
  }
  setupParentsIntoCols(columnsOrGroups, parent) {
    columnsOrGroups.forEach((columnsOrGroup) => {
      if (columnsOrGroup.parent !== parent) {
        this.beans.colViewport.colsWithinViewportHash = "";
      }
      columnsOrGroup.parent = parent;
      if (isColumnGroup(columnsOrGroup)) {
        const columnGroup = columnsOrGroup;
        this.setupParentsIntoCols(columnGroup.getChildren(), columnGroup);
      }
    });
  }
};
var ColumnGroupModule = {
  moduleName: "ColumnGroup",
  version: VERSION,
  dynamicBeans: { headerGroupCellCtrl: HeaderGroupCellCtrl },
  beans: [ColumnGroupService],
  apiFunctions: {
    getAllDisplayedColumnGroups,
    getCenterDisplayedColumnGroups,
    getColumnGroup,
    getColumnGroupState,
    getDisplayNameForColumnGroup,
    getLeftDisplayedColumnGroups,
    getProvidedColumnGroup,
    getRightDisplayedColumnGroups,
    resetColumnGroupState,
    setColumnGroupOpened,
    setColumnGroupState
  }
};
var SkeletonCellRendererElement = { tag: "div", cls: "ag-skeleton-container" };
var SkeletonCellRenderer = class extends Component {
  constructor() {
    super(SkeletonCellRendererElement);
  }
  init(params) {
    const id = `ag-cell-skeleton-renderer-${this.getCompId()}`;
    this.getGui().setAttribute("id", id);
    this.addDestroyFunc(() => _setAriaLabelledBy(params.eParentOfValue));
    _setAriaLabelledBy(params.eParentOfValue, id);
    if (params.deferRender) {
      this.setupLoading(params);
    } else {
      params.node.failedLoad ? this.setupFailed() : this.setupLoading(params);
    }
  }
  setupFailed() {
    const localeTextFunc = this.getLocaleTextFunc();
    this.getGui().textContent = localeTextFunc("loadingError", "ERR");
    const ariaFailed = localeTextFunc("ariaSkeletonCellLoadingFailed", "Row failed to load");
    _setAriaLabel(this.getGui(), ariaFailed);
  }
  setupLoading(params) {
    const skeletonEffect = _createElement({
      tag: "div",
      cls: "ag-skeleton-effect"
    });
    const rowIndex = params.node.rowIndex;
    if (rowIndex != null) {
      const width = 75 + 25 * (rowIndex % 2 === 0 ? Math.sin(rowIndex) : Math.cos(rowIndex));
      skeletonEffect.style.width = `${width}%`;
    }
    this.getGui().appendChild(skeletonEffect);
    const localeTextFunc = this.getLocaleTextFunc();
    const ariaLoading = params.deferRender ? localeTextFunc("ariaDeferSkeletonCellLoading", "Cell is loading") : localeTextFunc("ariaSkeletonCellLoading", "Row data is loading");
    _setAriaLabel(this.getGui(), ariaLoading);
  }
  refresh(_params) {
    return false;
  }
};
var CheckboxCellRendererModule = {
  moduleName: "CheckboxCellRenderer",
  version: VERSION,
  userComponents: {
    agCheckboxCellRenderer: CheckboxCellRenderer
  }
};
var SkeletonCellRendererModule = {
  moduleName: "SkeletonCellRenderer",
  version: VERSION,
  userComponents: {
    agSkeletonCellRenderer: SkeletonCellRenderer
  }
};
var ColumnFlexService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colFlex";
  }
  refreshFlexedColumns(params = {}) {
    var _a4;
    const source = (_a4 = params.source) != null ? _a4 : "flex";
    if (params.viewportWidth != null) {
      this.flexViewportWidth = params.viewportWidth;
    }
    const totalSpace = this.flexViewportWidth;
    const { visibleCols, colDelayRenderSvc } = this.beans;
    const visibleCenterCols = visibleCols.centerCols;
    let flexAfterDisplayIndex = -1;
    if (params.resizingCols) {
      const allResizingCols = new Set(params.resizingCols);
      for (let i = visibleCenterCols.length - 1; i >= 0; i--) {
        if (allResizingCols.has(visibleCenterCols[i])) {
          flexAfterDisplayIndex = i;
          break;
        }
      }
    }
    let hasFlexItems = false;
    const items = visibleCenterCols.map((col, i) => {
      const flex = col.getFlex();
      const isFlex = flex != null && flex > 0 && i > flexAfterDisplayIndex;
      hasFlexItems || (hasFlexItems = isFlex);
      return {
        col,
        isFlex,
        flex: Math.max(0, flex != null ? flex : 0),
        initialSize: col.getActualWidth(),
        min: col.getMinWidth(),
        max: col.getMaxWidth(),
        targetSize: 0
      };
    });
    if (hasFlexItems) {
      colDelayRenderSvc == null ? void 0 : colDelayRenderSvc.hideColumns("colFlex");
    }
    if (!totalSpace || !hasFlexItems) {
      return [];
    }
    let unfrozenItemCount = items.length;
    let unfrozenFlex = items.reduce((acc, item) => acc + item.flex, 0);
    let unfrozenSpace = totalSpace;
    const freeze = (item, width) => {
      item.frozenSize = width;
      item.col.setActualWidth(width, source);
      unfrozenSpace -= width;
      unfrozenFlex -= item.flex;
      unfrozenItemCount -= 1;
    };
    const isFrozen = (item) => item.frozenSize != null;
    for (const item of items) {
      if (!item.isFlex) {
        freeze(item, item.initialSize);
      }
    }
    while (unfrozenItemCount > 0) {
      const spaceToFill = Math.round(unfrozenFlex < 1 ? unfrozenSpace * unfrozenFlex : unfrozenSpace);
      let lastUnfrozenItem;
      let actualLeft = 0;
      let idealRight = 0;
      for (const item of items) {
        if (isFrozen(item)) {
          continue;
        }
        lastUnfrozenItem = item;
        idealRight += spaceToFill * (item.flex / unfrozenFlex);
        const idealSize = idealRight - actualLeft;
        const roundedSize = Math.round(idealSize);
        item.targetSize = roundedSize;
        actualLeft += roundedSize;
      }
      if (lastUnfrozenItem) {
        lastUnfrozenItem.targetSize += spaceToFill - actualLeft;
      }
      let totalViolation = 0;
      for (const item of items) {
        if (isFrozen(item)) {
          continue;
        }
        const unclampedSize = item.targetSize;
        const clampedSize = Math.min(Math.max(unclampedSize, item.min), item.max);
        totalViolation += clampedSize - unclampedSize;
        item.violationType = clampedSize === unclampedSize ? void 0 : clampedSize < unclampedSize ? "max" : "min";
        item.targetSize = clampedSize;
      }
      const freezeType = totalViolation === 0 ? "all" : totalViolation > 0 ? "min" : "max";
      for (const item of items) {
        if (isFrozen(item)) {
          continue;
        }
        if (freezeType === "all" || item.violationType === freezeType) {
          freeze(item, item.targetSize);
        }
      }
    }
    if (!params.skipSetLeft) {
      visibleCols.setLeftValues(source);
    }
    if (params.updateBodyWidths) {
      visibleCols.updateBodyWidths();
    }
    const unconstrainedFlexColumns = items.filter((item) => item.isFlex && !item.violationType).map((item) => item.col);
    if (params.fireResizedEvent) {
      const changedColumns = items.filter((item) => item.initialSize !== item.frozenSize).map((item) => item.col);
      const flexingColumns = items.filter((item) => item.flex).map((item) => item.col);
      dispatchColumnResizedEvent(this.eventSvc, changedColumns, true, source, flexingColumns);
    }
    colDelayRenderSvc == null ? void 0 : colDelayRenderSvc.revealColumns("colFlex");
    return unconstrainedFlexColumns;
  }
  initCol(column) {
    const { flex, initialFlex } = column.colDef;
    if (flex !== void 0) {
      column.flex = flex;
    } else if (initialFlex !== void 0) {
      column.flex = initialFlex;
    }
  }
  // this method should only be used by the colModel to
  // change flex when required by the applyColumnState method.
  setColFlex(column, flex) {
    column.flex = flex != null ? flex : null;
    column.dispatchStateUpdatedEvent("flex");
  }
};
function _getValueUsingField(data, field, fieldContainsDots) {
  if (!field || !data) {
    return;
  }
  if (!fieldContainsDots) {
    return data[field];
  }
  const fields = field.split(".");
  let currentObject = data;
  for (let i = 0; i < fields.length; i++) {
    if (currentObject == null) {
      return void 0;
    }
    currentObject = currentObject[fields[i]];
  }
  return currentObject;
}
var SORTED_CELL_DATA_TYPES_FOR_MATCHING = [
  "dateTimeString",
  "dateString",
  "text",
  "number",
  "boolean",
  "date"
];
var DataTypeService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "dataTypeSvc";
    this.dataTypeDefinitions = {};
    this.isPendingInference = false;
    this.isColumnTypeOverrideInDataTypeDefinitions = false;
    this.columnStateUpdatesPendingInference = {};
    this.columnStateUpdateListenerDestroyFuncs = [];
    this.columnDefinitionPropsPerDataType = {
      number() {
        return { cellEditor: "agNumberCellEditor" };
      },
      boolean() {
        return {
          cellEditor: "agCheckboxCellEditor",
          cellRenderer: "agCheckboxCellRenderer",
          getFindText: () => null,
          suppressKeyboardEvent: (params) => !!params.colDef.editable && params.event.key === KeyCode.SPACE
        };
      },
      date({ formatValue }) {
        return { cellEditor: "agDateCellEditor", keyCreator: formatValue };
      },
      dateString({ formatValue }) {
        return { cellEditor: "agDateStringCellEditor", keyCreator: formatValue };
      },
      dateTime(args) {
        return this.date(args);
      },
      dateTimeString(args) {
        return this.dateString(args);
      },
      object({ formatValue, colModel, colId }) {
        return {
          cellEditorParams: {
            useFormatter: true
          },
          comparator: (a, b) => {
            const column = colModel.getColDefCol(colId);
            const colDef = column == null ? void 0 : column.getColDef();
            if (!column || !colDef) {
              return 0;
            }
            const valA = a == null ? "" : formatValue({ column, node: null, value: a });
            const valB = b == null ? "" : formatValue({ column, node: null, value: b });
            if (valA === valB)
              return 0;
            return valA > valB ? 1 : -1;
          },
          keyCreator: formatValue
        };
      },
      text() {
        return {};
      }
    };
  }
  wireBeans(beans) {
    this.colModel = beans.colModel;
  }
  postConstruct() {
    this.processDataTypeDefinitions();
    this.addManagedPropertyListener("dataTypeDefinitions", (event) => {
      this.processDataTypeDefinitions();
      this.colModel.recreateColumnDefs(event);
    });
  }
  processDataTypeDefinitions() {
    var _a4;
    const defaultDataTypes = this.getDefaultDataTypes();
    const newDataTypeDefinitions = {};
    const newFormatValueFuncs = {};
    const generateFormatValueFunc = (dataTypeDefinition) => {
      return (params) => {
        const { column, node, value } = params;
        let valueFormatter = column.getColDef().valueFormatter;
        if (valueFormatter === dataTypeDefinition.groupSafeValueFormatter) {
          valueFormatter = dataTypeDefinition.valueFormatter;
        }
        return this.beans.valueSvc.formatValue(column, node, value, valueFormatter);
      };
    };
    for (const cellDataType of Object.keys(defaultDataTypes)) {
      const defaultDataTypeDef = defaultDataTypes[cellDataType];
      const mergedDataTypeDefinition = {
        ...defaultDataTypeDef,
        groupSafeValueFormatter: createGroupSafeValueFormatter(defaultDataTypeDef, this.gos)
      };
      newDataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
      newFormatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
    }
    const userDataTypeDefs = (_a4 = this.gos.get("dataTypeDefinitions")) != null ? _a4 : {};
    const newDataTypeMatchers = {};
    for (const cellDataType of Object.keys(userDataTypeDefs)) {
      const userDataTypeDef = userDataTypeDefs[cellDataType];
      const mergedDataTypeDefinition = this.processDataTypeDefinition(
        userDataTypeDef,
        userDataTypeDefs,
        [cellDataType],
        defaultDataTypes
      );
      if (mergedDataTypeDefinition) {
        newDataTypeDefinitions[cellDataType] = mergedDataTypeDefinition;
        if (userDataTypeDef.dataTypeMatcher) {
          newDataTypeMatchers[cellDataType] = userDataTypeDef.dataTypeMatcher;
        }
        newFormatValueFuncs[cellDataType] = generateFormatValueFunc(mergedDataTypeDefinition);
      }
    }
    const { valueParser: defaultValueParser, valueFormatter: defaultValueFormatter } = defaultDataTypes.object;
    const { valueParser: userValueParser, valueFormatter: userValueFormatter } = newDataTypeDefinitions.object;
    this.hasObjectValueParser = userValueParser !== defaultValueParser;
    this.hasObjectValueFormatter = userValueFormatter !== defaultValueFormatter;
    this.formatValueFuncs = newFormatValueFuncs;
    this.dataTypeDefinitions = newDataTypeDefinitions;
    this.dataTypeMatchers = this.sortKeysInMatchers(newDataTypeMatchers, defaultDataTypes);
  }
  /**
   * Sorts the keys in the matchers object.
   * Does not mutate the original object, creates a copy of it with sorted keys instead.
   */
  sortKeysInMatchers(matchers, dataTypes) {
    var _a4;
    const sortedMatchers = { ...matchers };
    for (const cellDataType of SORTED_CELL_DATA_TYPES_FOR_MATCHING) {
      delete sortedMatchers[cellDataType];
      sortedMatchers[cellDataType] = (_a4 = matchers[cellDataType]) != null ? _a4 : dataTypes[cellDataType].dataTypeMatcher;
    }
    return sortedMatchers;
  }
  processDataTypeDefinition(userDataTypeDef, userDataTypeDefs, alreadyProcessedDataTypes, defaultDataTypes) {
    let mergedDataTypeDefinition;
    const extendsCellDataType = userDataTypeDef.extendsDataType;
    if (userDataTypeDef.columnTypes) {
      this.isColumnTypeOverrideInDataTypeDefinitions = true;
    }
    if (userDataTypeDef.extendsDataType === userDataTypeDef.baseDataType) {
      let baseDataTypeDefinition = defaultDataTypes[extendsCellDataType];
      const overriddenBaseDataTypeDefinition = userDataTypeDefs[extendsCellDataType];
      if (baseDataTypeDefinition && overriddenBaseDataTypeDefinition) {
        baseDataTypeDefinition = overriddenBaseDataTypeDefinition;
      }
      if (!validateDataTypeDefinition(userDataTypeDef, baseDataTypeDefinition, extendsCellDataType)) {
        return void 0;
      }
      mergedDataTypeDefinition = mergeDataTypeDefinitions(baseDataTypeDefinition, userDataTypeDef);
    } else {
      if (alreadyProcessedDataTypes.includes(extendsCellDataType)) {
        _warn(44);
        return void 0;
      }
      const extendedDataTypeDefinition = userDataTypeDefs[extendsCellDataType];
      if (!validateDataTypeDefinition(userDataTypeDef, extendedDataTypeDefinition, extendsCellDataType)) {
        return void 0;
      }
      const mergedExtendedDataTypeDefinition = this.processDataTypeDefinition(
        extendedDataTypeDefinition,
        userDataTypeDefs,
        [...alreadyProcessedDataTypes, extendsCellDataType],
        defaultDataTypes
      );
      if (!mergedExtendedDataTypeDefinition) {
        return void 0;
      }
      mergedDataTypeDefinition = mergeDataTypeDefinitions(mergedExtendedDataTypeDefinition, userDataTypeDef);
    }
    return {
      ...mergedDataTypeDefinition,
      groupSafeValueFormatter: createGroupSafeValueFormatter(mergedDataTypeDefinition, this.gos)
    };
  }
  updateColDefAndGetColumnType(colDef, userColDef, colId) {
    let { cellDataType } = userColDef;
    const { field } = userColDef;
    if (cellDataType === void 0) {
      cellDataType = colDef.cellDataType;
    }
    if (cellDataType == null || cellDataType === true) {
      cellDataType = this.canInferCellDataType(colDef, userColDef) ? this.inferCellDataType(field, colId) : false;
    }
    if (!cellDataType) {
      colDef.cellDataType = false;
      return void 0;
    }
    const dataTypeDefinition = this.dataTypeDefinitions[cellDataType];
    if (!dataTypeDefinition) {
      _warn(47, { cellDataType });
      return void 0;
    }
    colDef.cellDataType = cellDataType;
    if (dataTypeDefinition.groupSafeValueFormatter) {
      colDef.valueFormatter = dataTypeDefinition.groupSafeValueFormatter;
    }
    if (dataTypeDefinition.valueParser) {
      colDef.valueParser = dataTypeDefinition.valueParser;
    }
    if (!dataTypeDefinition.suppressDefaultProperties) {
      this.setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId);
    }
    return dataTypeDefinition.columnTypes;
  }
  addColumnListeners(column) {
    if (!this.isPendingInference) {
      return;
    }
    const columnStateUpdates = this.columnStateUpdatesPendingInference[column.getColId()];
    if (!columnStateUpdates) {
      return;
    }
    const columnListener = (event) => {
      columnStateUpdates.add(event.key);
    };
    column.__addEventListener("columnStateUpdated", columnListener);
    this.columnStateUpdateListenerDestroyFuncs.push(
      () => column.__removeEventListener("columnStateUpdated", columnListener)
    );
  }
  canInferCellDataType(colDef, userColDef) {
    var _a4;
    const { gos } = this;
    if (!_isClientSideRowModel(gos)) {
      return false;
    }
    const propsToCheckForInference = { cellRenderer: true, valueGetter: true, valueParser: true, refData: true };
    if (doColDefPropsPreventInference(userColDef, propsToCheckForInference)) {
      return false;
    }
    const columnTypes = userColDef.type === null ? colDef.type : userColDef.type;
    if (columnTypes) {
      const columnTypeDefs = (_a4 = gos.get("columnTypes")) != null ? _a4 : {};
      const hasPropsPreventingInference = convertColumnTypes(columnTypes).some((columnType) => {
        const columnTypeDef = columnTypeDefs[columnType.trim()];
        return columnTypeDef && doColDefPropsPreventInference(columnTypeDef, propsToCheckForInference);
      });
      if (hasPropsPreventingInference) {
        return false;
      }
    }
    return !doColDefPropsPreventInference(colDef, propsToCheckForInference);
  }
  inferCellDataType(field, colId) {
    if (!field) {
      return void 0;
    }
    let value;
    const initialData = this.getInitialData();
    if (initialData) {
      const fieldContainsDots = field.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      value = _getValueUsingField(initialData, field, fieldContainsDots);
    } else {
      this.initWaitForRowData(colId);
    }
    if (value == null) {
      return void 0;
    }
    const matchedType = Object.keys(this.dataTypeMatchers).find(
      (_cellDataType) => this.dataTypeMatchers[_cellDataType](value)
    );
    return matchedType != null ? matchedType : "object";
  }
  getInitialData() {
    var _a4;
    const rowData = this.gos.get("rowData");
    if (rowData == null ? void 0 : rowData.length) {
      return rowData[0];
    } else if (this.initialData) {
      return this.initialData;
    } else {
      const rowNodes = (_a4 = this.beans.rowModel.rootNode) == null ? void 0 : _a4.allLeafChildren;
      if (rowNodes == null ? void 0 : rowNodes.length) {
        return rowNodes[0].data;
      }
    }
    return null;
  }
  initWaitForRowData(colId) {
    this.columnStateUpdatesPendingInference[colId] = /* @__PURE__ */ new Set();
    if (this.isPendingInference) {
      return;
    }
    this.isPendingInference = true;
    const columnTypeOverridesExist = this.isColumnTypeOverrideInDataTypeDefinitions;
    const { colAutosize, eventSvc } = this.beans;
    if (columnTypeOverridesExist && colAutosize) {
      colAutosize.shouldQueueResizeOperations = true;
    }
    const [destroyFunc] = this.addManagedEventListeners({
      rowDataUpdateStarted: (event) => {
        const { firstRowData } = event;
        if (!firstRowData) {
          return;
        }
        destroyFunc == null ? void 0 : destroyFunc();
        this.isPendingInference = false;
        this.processColumnsPendingInference(firstRowData, columnTypeOverridesExist);
        this.columnStateUpdatesPendingInference = {};
        if (columnTypeOverridesExist) {
          colAutosize == null ? void 0 : colAutosize.processResizeOperations();
        }
        eventSvc.dispatchEvent({
          type: "dataTypesInferred"
        });
      }
    });
  }
  processColumnsPendingInference(firstRowData, columnTypeOverridesExist) {
    this.initialData = firstRowData;
    const state = [];
    this.destroyColumnStateUpdateListeners();
    const newRowGroupColumnStateWithoutIndex = {};
    const newPivotColumnStateWithoutIndex = {};
    for (const colId of Object.keys(this.columnStateUpdatesPendingInference)) {
      const columnStateUpdates = this.columnStateUpdatesPendingInference[colId];
      const column = this.colModel.getCol(colId);
      if (!column) {
        return;
      }
      const oldColDef = column.getColDef();
      if (!this.resetColDefIntoCol(column, "cellDataTypeInferred")) {
        return;
      }
      const newColDef = column.getColDef();
      if (columnTypeOverridesExist && newColDef.type && newColDef.type !== oldColDef.type) {
        const updatedColumnState = getUpdatedColumnState(column, columnStateUpdates);
        if (updatedColumnState.rowGroup && updatedColumnState.rowGroupIndex == null) {
          newRowGroupColumnStateWithoutIndex[colId] = updatedColumnState;
        }
        if (updatedColumnState.pivot && updatedColumnState.pivotIndex == null) {
          newPivotColumnStateWithoutIndex[colId] = updatedColumnState;
        }
        state.push(updatedColumnState);
      }
    }
    if (columnTypeOverridesExist) {
      state.push(
        ...this.generateColumnStateForRowGroupAndPivotIndexes(
          newRowGroupColumnStateWithoutIndex,
          newPivotColumnStateWithoutIndex
        )
      );
    }
    if (state.length) {
      _applyColumnState(this.beans, { state }, "cellDataTypeInferred");
    }
    this.initialData = null;
  }
  generateColumnStateForRowGroupAndPivotIndexes(updatedRowGroupColumnState, updatedPivotColumnState) {
    const existingColumnStateUpdates = {};
    const { rowGroupColsSvc, pivotColsSvc } = this.beans;
    rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.restoreColumnOrder(existingColumnStateUpdates, updatedRowGroupColumnState);
    pivotColsSvc == null ? void 0 : pivotColsSvc.restoreColumnOrder(existingColumnStateUpdates, updatedPivotColumnState);
    return Object.values(existingColumnStateUpdates);
  }
  resetColDefIntoCol(column, source) {
    const userColDef = column.getUserProvidedColDef();
    if (!userColDef) {
      return false;
    }
    const newColDef = _addColumnDefaultAndTypes(this.beans, userColDef, column.getColId());
    column.setColDef(newColDef, userColDef, source);
    return true;
  }
  getDateStringTypeDefinition(column) {
    var _a4;
    const { dateString } = this.dataTypeDefinitions;
    if (!column) {
      return dateString;
    }
    return (_a4 = this.getDataTypeDefinition(column)) != null ? _a4 : dateString;
  }
  getDateParserFunction(column) {
    return this.getDateStringTypeDefinition(column).dateParser;
  }
  getDateFormatterFunction(column) {
    return this.getDateStringTypeDefinition(column).dateFormatter;
  }
  getDateIncludesTimeFlag(cellDataType) {
    return cellDataType === "dateTime" || cellDataType === "dateTimeString";
  }
  getDataTypeDefinition(column) {
    const colDef = column.getColDef();
    if (!colDef.cellDataType) {
      return void 0;
    }
    return this.dataTypeDefinitions[colDef.cellDataType];
  }
  getBaseDataType(column) {
    var _a4;
    return (_a4 = this.getDataTypeDefinition(column)) == null ? void 0 : _a4.baseDataType;
  }
  checkType(column, value) {
    var _a4;
    if (value == null) {
      return true;
    }
    const dataTypeMatcher = (_a4 = this.getDataTypeDefinition(column)) == null ? void 0 : _a4.dataTypeMatcher;
    if (!dataTypeMatcher) {
      return true;
    }
    return dataTypeMatcher(value);
  }
  validateColDef(colDef) {
    const warning = (property) => _warn(48, { property });
    if (colDef.cellDataType === "object") {
      const { object } = this.dataTypeDefinitions;
      if (colDef.valueFormatter === object.groupSafeValueFormatter && !this.hasObjectValueFormatter) {
        warning("Formatter");
      }
      if (colDef.editable && colDef.valueParser === object.valueParser && !this.hasObjectValueParser) {
        warning("Parser");
      }
    }
  }
  postProcess(colDef) {
    var _a4;
    const cellDataType = colDef.cellDataType;
    if (!cellDataType || typeof cellDataType !== "string") {
      return;
    }
    const { dataTypeDefinitions, beans, formatValueFuncs } = this;
    const dataTypeDefinition = dataTypeDefinitions[cellDataType];
    if (!dataTypeDefinition) {
      return;
    }
    (_a4 = beans.colFilter) == null ? void 0 : _a4.setColDefPropsForDataType(colDef, dataTypeDefinition, formatValueFuncs[cellDataType]);
  }
  // noinspection JSUnusedGlobalSymbols
  getFormatValue(cellDataType) {
    return this.formatValueFuncs[cellDataType];
  }
  isColPendingInference(colId) {
    return this.isPendingInference && !!this.columnStateUpdatesPendingInference[colId];
  }
  setColDefPropertiesForBaseDataType(colDef, cellDataType, dataTypeDefinition, colId) {
    const formatValue = this.formatValueFuncs[cellDataType];
    const partialColDef = this.columnDefinitionPropsPerDataType[dataTypeDefinition.baseDataType]({
      colDef,
      cellDataType,
      colModel: this.colModel,
      dataTypeDefinition,
      colId,
      formatValue
    });
    Object.assign(colDef, partialColDef);
  }
  getDateObjectTypeDef(baseDataType) {
    const translate = this.getLocaleTextFunc();
    const includeTime = this.getDateIncludesTimeFlag(baseDataType);
    return {
      baseDataType,
      valueParser: (params) => _parseDateTimeFromString(params.newValue && String(params.newValue)),
      valueFormatter: (params) => {
        var _a4;
        if (params.value == null) {
          return "";
        }
        if (!(params.value instanceof Date) || isNaN(params.value.getTime())) {
          return translate("invalidDate", "Invalid Date");
        }
        return (_a4 = _serialiseDate(params.value, includeTime)) != null ? _a4 : "";
      },
      dataTypeMatcher: (value) => value instanceof Date
    };
  }
  getDateStringTypeDef(baseDataType) {
    const includeTime = this.getDateIncludesTimeFlag(baseDataType);
    return {
      baseDataType,
      dateParser: (value) => {
        var _a4;
        return (_a4 = _parseDateTimeFromString(value)) != null ? _a4 : void 0;
      },
      dateFormatter: (value) => {
        var _a4;
        return (_a4 = _serialiseDate(value != null ? value : null, includeTime)) != null ? _a4 : void 0;
      },
      valueParser: (params) => _isValidDate(String(params.newValue)) ? params.newValue : null,
      valueFormatter: (params) => _isValidDate(String(params.value)) ? String(params.value) : "",
      dataTypeMatcher: (value) => typeof value === "string" && _isValidDate(value)
    };
  }
  getDefaultDataTypes() {
    const translate = this.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        // can be empty space with legacy copy
        valueParser: (params) => {
          var _a4, _b2;
          return ((_b2 = (_a4 = params.newValue) == null ? void 0 : _a4.trim) == null ? void 0 : _b2.call(_a4)) === "" ? null : Number(params.newValue);
        },
        valueFormatter: (params) => {
          if (params.value == null) {
            return "";
          }
          if (typeof params.value !== "number" || isNaN(params.value)) {
            return translate("invalidNumber", "Invalid Number");
          }
          return String(params.value);
        },
        dataTypeMatcher: (value) => typeof value === "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (params) => params.newValue === "" ? null : _toStringOrNull(params.newValue),
        dataTypeMatcher: (value) => typeof value === "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (params) => {
          var _a4, _b2;
          if (params.newValue == null) {
            return params.newValue;
          }
          return ((_b2 = (_a4 = params.newValue) == null ? void 0 : _a4.trim) == null ? void 0 : _b2.call(_a4)) === "" ? null : String(params.newValue).toLowerCase() === "true";
        },
        valueFormatter: (params) => params.value == null ? "" : String(params.value),
        dataTypeMatcher: (value) => typeof value === "boolean"
      },
      date: this.getDateObjectTypeDef("date"),
      dateString: this.getDateStringTypeDef("dateString"),
      dateTime: this.getDateObjectTypeDef("dateTime"),
      dateTimeString: {
        ...this.getDateStringTypeDef("dateTimeString"),
        dataTypeMatcher: (value) => typeof value === "string" && _isValidDateTime(value)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (params) => {
          var _a4;
          return (_a4 = _toStringOrNull(params.value)) != null ? _a4 : "";
        }
      }
    };
  }
  destroyColumnStateUpdateListeners() {
    this.columnStateUpdateListenerDestroyFuncs.forEach((destroyFunc) => destroyFunc());
    this.columnStateUpdateListenerDestroyFuncs = [];
  }
  destroy() {
    this.dataTypeDefinitions = {};
    this.dataTypeMatchers = {};
    this.formatValueFuncs = {};
    this.columnStateUpdatesPendingInference = {};
    this.destroyColumnStateUpdateListeners();
    super.destroy();
  }
};
function mergeDataTypeDefinitions(parentDataTypeDefinition, childDataTypeDefinition) {
  const mergedDataTypeDefinition = {
    ...parentDataTypeDefinition,
    ...childDataTypeDefinition
  };
  if (parentDataTypeDefinition.columnTypes && childDataTypeDefinition.columnTypes && childDataTypeDefinition.appendColumnTypes) {
    mergedDataTypeDefinition.columnTypes = [
      ...convertColumnTypes(parentDataTypeDefinition.columnTypes),
      ...convertColumnTypes(childDataTypeDefinition.columnTypes)
    ];
  }
  return mergedDataTypeDefinition;
}
function validateDataTypeDefinition(dataTypeDefinition, parentDataTypeDefinition, parentCellDataType) {
  if (!parentDataTypeDefinition) {
    _warn(45, { parentCellDataType });
    return false;
  }
  if (parentDataTypeDefinition.baseDataType !== dataTypeDefinition.baseDataType) {
    _warn(46);
    return false;
  }
  return true;
}
function createGroupSafeValueFormatter(dataTypeDefinition, gos) {
  if (!dataTypeDefinition.valueFormatter) {
    return void 0;
  }
  return (params) => {
    var _a4, _b2, _c;
    if ((_a4 = params.node) == null ? void 0 : _a4.group) {
      const aggFunc = ((_b2 = params.colDef.pivotValueColumn) != null ? _b2 : params.column).getAggFunc();
      if (aggFunc) {
        if (aggFunc === "first" || aggFunc === "last") {
          return dataTypeDefinition.valueFormatter(params);
        }
        if (dataTypeDefinition.baseDataType === "number" && aggFunc !== "count") {
          if (typeof params.value === "number") {
            return dataTypeDefinition.valueFormatter(params);
          }
          if (typeof params.value === "object") {
            if (!params.value) {
              return void 0;
            }
            if ("toNumber" in params.value) {
              return dataTypeDefinition.valueFormatter({
                ...params,
                value: params.value.toNumber()
              });
            }
            if ("value" in params.value) {
              return dataTypeDefinition.valueFormatter({
                ...params,
                value: params.value.value
              });
            }
          }
        }
        return void 0;
      }
    } else if (gos.get("groupHideOpenParents") && params.column.isRowGroupActive()) {
      if (typeof params.value === "string" && !((_c = dataTypeDefinition.dataTypeMatcher) == null ? void 0 : _c.call(dataTypeDefinition, params.value))) {
        return void 0;
      }
    }
    return dataTypeDefinition.valueFormatter(params);
  };
}
function doesColDefPropPreventInference(colDef, checkProps, prop, comparisonValue) {
  if (!checkProps[prop]) {
    return false;
  }
  const value = colDef[prop];
  if (value === null) {
    checkProps[prop] = false;
    return false;
  } else {
    return comparisonValue === void 0 ? !!value : value === comparisonValue;
  }
}
function doColDefPropsPreventInference(colDef, propsToCheckForInference) {
  return [
    ["cellRenderer", "agSparklineCellRenderer"],
    ["valueGetter", void 0],
    ["valueParser", void 0],
    ["refData", void 0]
  ].some(
    ([prop, comparisonValue]) => doesColDefPropPreventInference(colDef, propsToCheckForInference, prop, comparisonValue)
  );
}
function getUpdatedColumnState(column, columnStateUpdates) {
  const columnState = getColumnStateFromColDef(column);
  columnStateUpdates.forEach((key) => {
    delete columnState[key];
    if (key === "rowGroup") {
      delete columnState.rowGroupIndex;
    } else if (key === "pivot") {
      delete columnState.pivotIndex;
    }
  });
  return columnState;
}
var DataTypeModule = {
  moduleName: "DataType",
  version: VERSION,
  beans: [DataTypeService],
  dependsOn: [CheckboxCellRendererModule]
};
var ColumnFlexModule = {
  moduleName: "ColumnFlex",
  version: VERSION,
  beans: [ColumnFlexService]
};
function _camelCaseToHumanText(camelCase) {
  if (!camelCase || camelCase == null) {
    return null;
  }
  const rex = /([a-z])([A-Z])/g;
  const rexCaps = /([A-Z]+)([A-Z])([a-z])/g;
  const words = camelCase.replace(rex, "$1 $2").replace(rexCaps, "$1 $2$3").replace(/\./g, " ").split(" ");
  return words.map((word) => word.substring(0, 1).toUpperCase() + (word.length > 1 ? word.substring(1, word.length) : "")).join(" ");
}
var ColumnNameService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colNames";
  }
  getDisplayNameForColumn(column, location, includeAggFunc = false) {
    if (!column) {
      return null;
    }
    const headerName = this.getHeaderName(column.getColDef(), column, null, null, location);
    const { aggColNameSvc } = this.beans;
    if (includeAggFunc && aggColNameSvc) {
      return aggColNameSvc.getHeaderName(column, headerName);
    }
    return headerName;
  }
  getDisplayNameForProvidedColumnGroup(columnGroup, providedColumnGroup, location) {
    const colGroupDef = providedColumnGroup == null ? void 0 : providedColumnGroup.getColGroupDef();
    if (colGroupDef) {
      return this.getHeaderName(colGroupDef, null, columnGroup, providedColumnGroup, location);
    }
    return null;
  }
  getDisplayNameForColumnGroup(columnGroup, location) {
    return this.getDisplayNameForProvidedColumnGroup(columnGroup, columnGroup.getProvidedColumnGroup(), location);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(colDef, column, columnGroup, providedColumnGroup, location) {
    var _a4, _b2;
    const headerValueGetter = colDef.headerValueGetter;
    if (headerValueGetter) {
      const params = _addGridCommonParams(this.gos, {
        colDef,
        column,
        columnGroup,
        providedColumnGroup,
        location
      });
      if (typeof headerValueGetter === "function") {
        return headerValueGetter(params);
      } else if (typeof headerValueGetter === "string") {
        return (_b2 = (_a4 = this.beans.expressionSvc) == null ? void 0 : _a4.evaluate(headerValueGetter, params)) != null ? _b2 : null;
      }
      return "";
    } else if (colDef.headerName != null) {
      return colDef.headerName;
    } else if (colDef.field) {
      return _camelCaseToHumanText(colDef.field);
    }
    return "";
  }
};
var ColumnViewportService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colViewport";
    this.colsWithinViewport = [];
    this.headerColsWithinViewport = [];
    this.colsWithinViewportHash = "";
    this.rowsOfHeadersToRenderLeft = {};
    this.rowsOfHeadersToRenderRight = {};
    this.rowsOfHeadersToRenderCenter = {};
    this.columnsToRenderLeft = [];
    this.columnsToRenderRight = [];
    this.columnsToRenderCenter = [];
  }
  wireBeans(beans) {
    this.visibleCols = beans.visibleCols;
    this.colModel = beans.colModel;
  }
  postConstruct() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
  }
  setScrollPosition(scrollWidth, scrollPosition, afterScroll = false) {
    const { visibleCols } = this;
    const bodyWidthDirty = visibleCols.isBodyWidthDirty;
    const noChange = scrollWidth === this.scrollWidth && scrollPosition === this.scrollPosition && !bodyWidthDirty;
    if (noChange) {
      return;
    }
    this.scrollWidth = scrollWidth;
    this.scrollPosition = scrollPosition;
    visibleCols.isBodyWidthDirty = true;
    if (this.gos.get("enableRtl")) {
      const bodyWidth = visibleCols.bodyWidth;
      this.viewportLeft = bodyWidth - scrollPosition - scrollWidth;
      this.viewportRight = bodyWidth - scrollPosition;
    } else {
      this.viewportLeft = scrollPosition;
      this.viewportRight = scrollWidth + scrollPosition;
    }
    if (this.colModel.ready) {
      this.checkViewportColumns(afterScroll);
    }
  }
  /**
   * Returns the columns that are currently rendered in the viewport.
   */
  getColumnHeadersToRender(type) {
    switch (type) {
      case "left":
        return this.columnsToRenderLeft;
      case "right":
        return this.columnsToRenderRight;
      default:
        return this.columnsToRenderCenter;
    }
  }
  /**
   * Returns the column groups that are currently rendered in the viewport at a specific header row index.
   */
  getHeadersToRender(type, depth) {
    let result;
    switch (type) {
      case "left":
        result = this.rowsOfHeadersToRenderLeft[depth];
        break;
      case "right":
        result = this.rowsOfHeadersToRenderRight[depth];
        break;
      default:
        result = this.rowsOfHeadersToRenderCenter[depth];
        break;
    }
    return result != null ? result : [];
  }
  extractViewportColumns() {
    const displayedColumnsCenter = this.visibleCols.centerCols;
    if (this.isColumnVirtualisationSuppressed()) {
      this.colsWithinViewport = displayedColumnsCenter;
      this.headerColsWithinViewport = displayedColumnsCenter;
    } else {
      this.colsWithinViewport = displayedColumnsCenter.filter(this.isColumnInRowViewport.bind(this));
      this.headerColsWithinViewport = displayedColumnsCenter.filter(this.isColumnInHeaderViewport.bind(this));
    }
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  clear() {
    this.rowsOfHeadersToRenderLeft = {};
    this.rowsOfHeadersToRenderRight = {};
    this.rowsOfHeadersToRenderCenter = {};
    this.colsWithinViewportHash = "";
  }
  isColumnInHeaderViewport(col) {
    if (col.isAutoHeaderHeight() || isAnyParentAutoHeaderHeight(col)) {
      return true;
    }
    return this.isColumnInRowViewport(col);
  }
  isColumnInRowViewport(col) {
    if (col.isAutoHeight()) {
      return true;
    }
    const columnLeft = col.getLeft() || 0;
    const columnRight = columnLeft + col.getActualWidth();
    const leftBounds = this.viewportLeft - 200;
    const rightBounds = this.viewportRight + 200;
    const columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;
    const columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;
    return !columnToMuchLeft && !columnToMuchRight;
  }
  // used by Grid API only
  getViewportColumns() {
    const { leftCols, rightCols } = this.visibleCols;
    const res = this.colsWithinViewport.concat(leftCols).concat(rightCols);
    return res;
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getColsWithinViewport(rowNode) {
    if (!this.colModel.colSpanActive) {
      return this.colsWithinViewport;
    }
    const emptySpaceBeforeColumn = (col) => {
      const left = col.getLeft();
      return _exists(left) && left > this.viewportLeft;
    };
    const inViewportCallback = this.isColumnVirtualisationSuppressed() ? void 0 : this.isColumnInRowViewport.bind(this);
    const { visibleCols } = this;
    const displayedColumnsCenter = visibleCols.centerCols;
    return visibleCols.getColsForRow(rowNode, displayedColumnsCenter, inViewportCallback, emptySpaceBeforeColumn);
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns(afterScroll = false) {
    const viewportColumnsChanged = this.extractViewport();
    if (viewportColumnsChanged) {
      this.eventSvc.dispatchEvent({
        type: "virtualColumnsChanged",
        afterScroll
      });
    }
  }
  calculateHeaderRows() {
    const { leftCols, rightCols } = this.visibleCols;
    this.columnsToRenderLeft = leftCols;
    this.columnsToRenderRight = rightCols;
    this.columnsToRenderCenter = this.colsWithinViewport;
    const workOutGroupsToRender = (cols) => {
      var _a4;
      const groupsToRenderSet = /* @__PURE__ */ new Set();
      const groupsToRender = {};
      for (const col of cols) {
        let group = col.getParent();
        const skipFillers = col.isSpanHeaderHeight();
        while (group) {
          if (groupsToRenderSet.has(group)) {
            break;
          }
          const skipFillerGroup = skipFillers && group.isPadding();
          if (skipFillerGroup) {
            group = group.getParent();
            continue;
          }
          const level = group.getProvidedColumnGroup().getLevel();
          (_a4 = groupsToRender[level]) != null ? _a4 : groupsToRender[level] = [];
          groupsToRender[level].push(group);
          groupsToRenderSet.add(group);
          group = group.getParent();
        }
      }
      return groupsToRender;
    };
    this.rowsOfHeadersToRenderLeft = workOutGroupsToRender(leftCols);
    this.rowsOfHeadersToRenderRight = workOutGroupsToRender(rightCols);
    this.rowsOfHeadersToRenderCenter = workOutGroupsToRender(this.headerColsWithinViewport);
  }
  extractViewport() {
    const hashColumn = (c) => `${c.getId()}-${c.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const newHash = this.getViewportColumns().map(hashColumn).join("#");
    const changed = this.colsWithinViewportHash !== newHash;
    if (changed) {
      this.colsWithinViewportHash = newHash;
      this.calculateHeaderRows();
    }
    return changed;
  }
};
function isAnyParentAutoHeaderHeight(col) {
  while (col) {
    if (col.isAutoHeaderHeight()) {
      return true;
    }
    col = col.getParent();
  }
  return false;
}
var AgComponentUtils = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "agCompUtils";
  }
  adaptFunction(type, jsCompFunc) {
    if (!type.cellRenderer) {
      return null;
    }
    class Adapter {
      refresh() {
        return false;
      }
      getGui() {
        return this.eGui;
      }
      init(params) {
        const callbackResult = jsCompFunc(params);
        const type2 = typeof callbackResult;
        if (type2 === "string" || type2 === "number" || type2 === "boolean") {
          this.eGui = _loadTemplate("<span>" + callbackResult + "</span>");
          return;
        }
        if (callbackResult == null) {
          this.eGui = _createElement({ tag: "span" });
          return;
        }
        this.eGui = callbackResult;
      }
    }
    return Adapter;
  }
};
var CellRendererFunctionModule = {
  moduleName: "CellRendererFunction",
  version: VERSION,
  beans: [AgComponentUtils]
};
var Registry = class extends BaseRegistry {
  constructor() {
    super(...arguments);
    this.agGridDefaults = {};
    this.agGridDefaultOverrides = {};
    this.jsComps = {};
    this.selectors = {};
    this.icons = {};
  }
  postConstruct() {
    const comps = this.gos.get("components");
    if (comps != null) {
      for (const key of Object.keys(comps)) {
        this.jsComps[key] = comps[key];
      }
    }
  }
  registerModule(module2) {
    const { icons, userComponents, dynamicBeans, selectors } = module2;
    if (userComponents) {
      const registerUserComponent = (name, component, params, processParams) => {
        this.agGridDefaults[name] = component;
        if (params || processParams) {
          this.agGridDefaultOverrides[name] = { params, processParams };
        }
      };
      for (const name of Object.keys(userComponents)) {
        let comp = userComponents[name];
        if (isComponentMetaFunc(comp)) {
          comp = comp.getComp(this.beans);
        }
        if (typeof comp === "object") {
          const { classImp, params, processParams } = comp;
          registerUserComponent(name, classImp, params, processParams);
        } else {
          registerUserComponent(name, comp);
        }
      }
    }
    this.registerDynamicBeans(dynamicBeans);
    selectors == null ? void 0 : selectors.forEach((selector) => {
      this.selectors[selector.selector] = selector;
    });
    if (icons) {
      for (const name of Object.keys(icons)) {
        this.icons[name] = icons[name];
      }
    }
  }
  getUserComponent(propertyName, name) {
    var _a4;
    const createResult = (component, componentFromFramework, params, processParams) => ({
      componentFromFramework,
      component,
      params,
      processParams
    });
    const { frameworkOverrides } = this.beans;
    const registeredViaFrameworkComp = frameworkOverrides.frameworkComponent(name, this.gos.get("components"));
    if (registeredViaFrameworkComp != null) {
      return createResult(registeredViaFrameworkComp, true);
    }
    const jsComponent = this.jsComps[name];
    if (jsComponent) {
      const isFwkComp = frameworkOverrides.isFrameworkComponent(jsComponent);
      return createResult(jsComponent, isFwkComp);
    }
    const defaultComponent = this.agGridDefaults[name];
    if (defaultComponent) {
      const overrides = this.agGridDefaultOverrides[name];
      return createResult(defaultComponent, false, overrides == null ? void 0 : overrides.params, overrides == null ? void 0 : overrides.processParams);
    }
    (_a4 = this.beans.validation) == null ? void 0 : _a4.missingUserComponent(propertyName, name, this.agGridDefaults, this.jsComps);
    return null;
  }
  getSelector(name) {
    return this.selectors[name];
  }
  getIcon(name) {
    return this.icons[name];
  }
  getDynamicError(name, init) {
    var _a4, _b2;
    if (init) {
      return _errMsg(279, { name });
    }
    return (_b2 = (_a4 = this.beans.validation) == null ? void 0 : _a4.missingDynamicBean(name)) != null ? _b2 : _errMsg(256);
  }
};
var NUM_CTRLS = 23;
var CtrlsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "ctrlsSvc";
    this.params = {};
    this.ready = false;
    this.readyCallbacks = [];
  }
  postConstruct() {
    var _a4, _b2, _c;
    this.addEventListener(
      "ready",
      () => {
        this.updateReady();
        if (this.ready) {
          this.readyCallbacks.forEach((c) => c(this.params));
          this.readyCallbacks.length = 0;
        }
      },
      (_c = (_b2 = (_a4 = this.beans.frameworkOverrides).runWhenReadyAsync) == null ? void 0 : _b2.call(_a4)) != null ? _c : false
    );
  }
  updateReady() {
    const values = Object.values(this.params);
    this.ready = values.length === NUM_CTRLS && values.every((ctrl) => {
      var _a4;
      return (_a4 = ctrl == null ? void 0 : ctrl.isAlive()) != null ? _a4 : false;
    });
  }
  whenReady(caller, callback) {
    if (this.ready) {
      callback(this.params);
    } else {
      this.readyCallbacks.push(callback);
    }
    caller.addDestroyFunc(() => {
      const index = this.readyCallbacks.indexOf(callback);
      if (index >= 0) {
        this.readyCallbacks.splice(index, 1);
      }
    });
  }
  register(ctrlType, ctrl) {
    this.params[ctrlType] = ctrl;
    this.updateReady();
    if (this.ready) {
      this.dispatchLocalEvent({ type: "ready" });
    }
    ctrl.addDestroyFunc(() => {
      this.updateReady();
    });
  }
  get(ctrlType) {
    return this.params[ctrlType];
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    const { leftHeader, centerHeader, rightHeader } = this.params;
    return [leftHeader, rightHeader, centerHeader];
  }
  getHeaderRowContainerCtrl(pinned) {
    const params = this.params;
    switch (pinned) {
      case "left":
        return params.leftHeader;
      case "right":
        return params.rightHeader;
      default:
        return params.centerHeader;
    }
  }
  getScrollFeature() {
    return this.getGridBodyCtrl().scrollFeature;
  }
};
var allRegisteredModules = /* @__PURE__ */ new Set();
var globalModulesMap = {};
var gridModulesMap = {};
var currentModuleVersion;
var userHasRegistered = false;
var areGridScopedModules = false;
var isUmd = false;
function isValidModuleVersion(module2) {
  const [moduleMajor, moduleMinor] = module2.version.split(".") || [];
  const [currentModuleMajor, currentModuleMinor] = currentModuleVersion.split(".") || [];
  return moduleMajor === currentModuleMajor && moduleMinor === currentModuleMinor;
}
function runVersionChecks(module2) {
  if (!currentModuleVersion) {
    currentModuleVersion = module2.version;
  }
  const errorMsg = (details) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${details} Please update all modules to the same version.`;
  if (!module2.version) {
    _errorOnce(errorMsg(`'${module2.moduleName}' is incompatible.`));
  } else if (!isValidModuleVersion(module2)) {
    _errorOnce(
      errorMsg(
        `'${module2.moduleName}' is version ${module2.version} but the other modules are version ${currentModuleVersion}.`
      )
    );
  }
  if (module2.validate) {
    const result = module2.validate();
    if (!result.isValid) {
      const errorResult = result;
      _errorOnce(`${errorResult.message}`);
    }
  }
}
function _registerModule(module2, gridId, isInternalRegistration = false) {
  var _a4;
  if (!isInternalRegistration) {
    userHasRegistered = true;
  }
  runVersionChecks(module2);
  const rowModels = (_a4 = module2.rowModels) != null ? _a4 : ["all"];
  allRegisteredModules.add(module2);
  let moduleStore;
  if (gridId !== void 0) {
    areGridScopedModules = true;
    if (gridModulesMap[gridId] === void 0) {
      gridModulesMap[gridId] = {};
    }
    moduleStore = gridModulesMap[gridId];
  } else {
    moduleStore = globalModulesMap;
  }
  rowModels.forEach((rowModel) => {
    if (moduleStore[rowModel] === void 0) {
      moduleStore[rowModel] = {};
    }
    moduleStore[rowModel][module2.moduleName] = module2;
  });
  if (module2.dependsOn) {
    module2.dependsOn.forEach((dependency) => _registerModule(dependency, gridId, isInternalRegistration));
  }
}
function _unRegisterGridModules(gridId) {
  delete gridModulesMap[gridId];
}
function _isModuleRegistered(moduleName, gridId, rowModel) {
  const isRegisteredForRowModel = (model) => {
    var _a4, _b2, _c;
    return !!((_a4 = globalModulesMap[model]) == null ? void 0 : _a4[moduleName]) || !!((_c = (_b2 = gridModulesMap[gridId]) == null ? void 0 : _b2[model]) == null ? void 0 : _c[moduleName]);
  };
  return isRegisteredForRowModel(rowModel) || isRegisteredForRowModel("all");
}
function _areModulesGridScoped() {
  return areGridScopedModules;
}
function _getRegisteredModules(gridId, rowModel) {
  var _a4, _b2, _c, _d, _e;
  const gridModules = (_a4 = gridModulesMap[gridId]) != null ? _a4 : {};
  return [
    ...Object.values((_b2 = globalModulesMap["all"]) != null ? _b2 : {}),
    ...Object.values((_c = gridModules["all"]) != null ? _c : {}),
    ...Object.values((_d = globalModulesMap[rowModel]) != null ? _d : {}),
    ...Object.values((_e = gridModules[rowModel]) != null ? _e : {})
  ];
}
function _getAllRegisteredModules() {
  return new Set(allRegisteredModules);
}
function _hasUserRegistered() {
  return userHasRegistered;
}
function _isUmd() {
  return isUmd;
}
var coreCSS = (
  /*css*/
  `.ag-aria-description-container{border:0;z-index:9999;clip:rect(1px,1px,1px,1px);height:1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ag-unselectable{-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-selectable{-webkit-user-select:text;-moz-user-select:text;user-select:text}.ag-tab-guard{display:block;height:0;position:absolute;width:0}:where(.ag-virtual-list-viewport) .ag-tab-guard{position:sticky}.ag-tab-guard-top{top:1px}.ag-tab-guard-bottom{bottom:1px}.ag-shake-left-to-right{animation-direction:alternate;animation-duration:.2s;animation-iteration-count:infinite;animation-name:ag-shake-left-to-right}@keyframes ag-shake-left-to-right{0%{padding-left:6px;padding-right:2px}to{padding-left:2px;padding-right:6px}}.ag-body-horizontal-scroll-viewport,.ag-body-vertical-scroll-viewport,.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport,.ag-virtual-list-viewport{flex:1 1 auto;height:100%;min-width:0;overflow:hidden;position:relative}.ag-viewport{position:relative}.ag-spanning-container{position:absolute;top:0;z-index:1}.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport{overflow-x:auto;-ms-overflow-style:none!important;scrollbar-width:none!important;&::-webkit-scrollbar{display:none!important}}.ag-body-viewport{display:flex;overflow-x:hidden;&:where(.ag-layout-normal){overflow-y:auto;-webkit-overflow-scrolling:touch}}.ag-floating-bottom-container,.ag-floating-top-container,.ag-sticky-bottom-container,.ag-sticky-top-container{min-height:1px}.ag-center-cols-viewport{min-height:100%;width:100%}.ag-body-horizontal-scroll-viewport{overflow-x:scroll}.ag-body-vertical-scroll-viewport{overflow-y:scroll}.ag-virtual-list-viewport{overflow:auto;width:100%}.ag-body-container,.ag-body-horizontal-scroll-container,.ag-body-vertical-scroll-container,.ag-center-cols-container,.ag-floating-bottom-container,.ag-floating-bottom-full-width-container,.ag-floating-top-container,.ag-full-width-container,.ag-header-container,.ag-pinned-left-cols-container,.ag-pinned-right-cols-container,.ag-sticky-bottom-container,.ag-sticky-top-container,.ag-virtual-list-container{position:relative}.ag-floating-bottom-container,.ag-floating-top-container,.ag-header-container,.ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top,.ag-sticky-bottom-container,.ag-sticky-top-container{height:100%;white-space:nowrap}.ag-center-cols-container,.ag-pinned-right-cols-container{display:block}.ag-body-horizontal-scroll-container{height:100%}.ag-body-vertical-scroll-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container,.ag-full-width-container,.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{pointer-events:none;position:absolute;top:0}:where(.ag-ltr) .ag-floating-bottom-full-width-container,:where(.ag-ltr) .ag-floating-top-full-width-container,:where(.ag-ltr) .ag-full-width-container,:where(.ag-ltr) .ag-sticky-bottom-full-width-container,:where(.ag-ltr) .ag-sticky-top-full-width-container{left:0}:where(.ag-rtl) .ag-floating-bottom-full-width-container,:where(.ag-rtl) .ag-floating-top-full-width-container,:where(.ag-rtl) .ag-full-width-container,:where(.ag-rtl) .ag-sticky-bottom-full-width-container,:where(.ag-rtl) .ag-sticky-top-full-width-container{right:0}.ag-full-width-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container{display:inline-block;height:100%;overflow:hidden;width:100%}.ag-virtual-list-container{overflow:hidden}.ag-body{display:flex;flex:1 1 auto;flex-direction:row!important;min-height:0;position:relative}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:flex;min-height:0;min-width:0;position:relative;&:where(.ag-scrollbar-invisible){bottom:0;position:absolute;&:where(.ag-apple-scrollbar){opacity:0;transition:opacity .4s;visibility:hidden;&:where(.ag-scrollbar-scrolling,.ag-scrollbar-active){opacity:1;visibility:visible}}}}.ag-body-horizontal-scroll{width:100%;&:where(.ag-scrollbar-invisible){left:0;right:0}}.ag-body-vertical-scroll{height:100%;&:where(.ag-scrollbar-invisible){top:0;z-index:10}}:where(.ag-ltr) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){right:0}}:where(.ag-rtl) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){left:0}}.ag-force-vertical-scroll{overflow-y:scroll!important}.ag-horizontal-left-spacer,.ag-horizontal-right-spacer{height:100%;min-width:0;overflow-x:scroll;&:where(.ag-scroller-corner){overflow-x:hidden}}:where(.ag-row-animation) .ag-row{transition:transform .4s,top .4s,opacity .2s;&:where(.ag-after-created){transition:transform .4s,top .4s,height .4s,opacity .2s}}:where(.ag-row-animation.ag-prevent-animation) .ag-row{transition:none!important;&:where(.ag-row.ag-after-created){transition:none!important}}:where(.ag-row-no-animation) .ag-row{transition:none}.ag-row-loading{align-items:center;display:flex}.ag-row-position-absolute{position:absolute}.ag-row-position-relative{position:relative}.ag-full-width-row{overflow:hidden;pointer-events:all}.ag-row-inline-editing{z-index:1}.ag-row-dragging{z-index:2}.ag-stub-cell{align-items:center;display:flex}.ag-cell{display:inline-block;height:100%;position:absolute;white-space:nowrap;&:focus-visible{box-shadow:none}}.ag-cell-value{flex:1 1 auto}.ag-cell-value,.ag-group-value{overflow:hidden;text-overflow:ellipsis}.ag-cell-wrap-text{white-space:normal;word-break:break-word}:where(.ag-cell) .ag-icon{display:inline-block;vertical-align:middle}.ag-floating-top{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-top:not(.ag-invisible)){border-bottom:var(--ag-pinned-row-border)}.ag-floating-bottom{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-bottom:not(.ag-invisible)){border-top:var(--ag-pinned-row-border)}.ag-sticky-bottom,.ag-sticky-top{background-color:var(--ag-background-color);display:flex;height:0;overflow:hidden;position:absolute;width:100%;z-index:1}.ag-opacity-zero{opacity:0!important}.ag-cell-label-container{align-items:center;display:flex;flex-direction:row-reverse;height:100%;justify-content:space-between;width:100%}:where(.ag-right-aligned-header){.ag-cell-label-container{flex-direction:row}.ag-header-cell-text{text-align:end}}.ag-column-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr){direction:ltr;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row}}:where(.ag-rtl){direction:rtl;text-align:right;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row-reverse}.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{display:block}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(180deg)}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(-180deg)}}.ag-measurement-container{height:0;overflow:hidden;visibility:hidden;width:0}.ag-measurement-element-border{display:inline-block;&:before{border-left:var(--ag-internal-measurement-border);content:"";display:block}}.ag-group{position:relative;width:100%}.ag-group-title-bar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-title{display:inline;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-group-title-bar) .ag-group-title{cursor:default}.ag-group-toolbar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-container{display:flex}.ag-disabled .ag-group-container{pointer-events:none}.ag-disabled-group-container,.ag-disabled-group-title-bar{opacity:.5}.ag-group-container-horizontal{flex-flow:row wrap}.ag-group-container-vertical{flex-direction:column}.ag-group-title-bar-icon{cursor:pointer;flex:none}:where(.ag-ltr) .ag-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-group-title-bar-icon{margin-left:var(--ag-spacing)}:where(.ag-group-item-alignment-stretch) .ag-group-item{align-items:stretch}:where(.ag-group-item-alignment-start) .ag-group-item{align-items:flex-start}:where(.ag-group-item-alignment-end) .ag-group-item{align-items:flex-end}:where(.ag-ltr) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-left:var(--ag-row-group-indent-size)}:where(.ag-rtl) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-right:var(--ag-row-group-indent-size)}:where(.ag-ltr) .ag-row-group-leaf-indent{margin-left:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}:where(.ag-rtl) .ag-row-group-leaf-indent{margin-right:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}.ag-value-change-delta{padding:0 2px}.ag-value-change-delta-up{color:var(--ag-value-change-delta-up-color)}.ag-value-change-delta-down{color:var(--ag-value-change-delta-down-color)}.ag-value-change-value{background-color:transparent;border-radius:1px;padding-left:1px;padding-right:1px;transition:background-color 1s}.ag-value-change-value-highlight{background-color:var(--ag-value-change-value-highlight-background-color);transition:background-color .1s}.ag-cell-data-changed{background-color:var(--ag-value-change-value-highlight-background-color)!important}.ag-cell-data-changed-animation{background-color:transparent}.ag-cell-highlight{background-color:var(--ag-range-selection-highlight-color)!important}.ag-row,.ag-spanned-row{color:var(--ag-cell-text-color);font-family:var(--ag-cell-font-family);font-size:var(--ag-data-font-size);white-space:nowrap;--ag-internal-content-line-height:calc(min(var(--ag-row-height), var(--ag-line-height, 1000px)) - var(--ag-internal-row-border-width, 1px) - 2px)}.ag-row{background-color:var(--ag-background-color);border-bottom:var(--ag-row-border);height:var(--ag-row-height);width:100%;&.ag-row-editing-invalid{background-color:var(--ag-full-row-edit-invalid-background-color)}}:where(.ag-body-vertical-content-no-gap>div>div>div,.ag-body-vertical-content-no-gap>div>div>div>div)>.ag-row-last{border-bottom-color:transparent}.ag-sticky-bottom{border-top:var(--ag-row-border);box-sizing:content-box!important}.ag-group-contracted,.ag-group-expanded{cursor:pointer}.ag-cell,.ag-full-width-row .ag-cell-wrapper.ag-row-group{border:1px solid transparent;line-height:var(--ag-internal-content-line-height);-webkit-font-smoothing:subpixel-antialiased}:where(.ag-ltr) .ag-cell{border-right:var(--ag-column-border)}:where(.ag-rtl) .ag-cell{border-left:var(--ag-column-border)}.ag-spanned-cell-wrapper{background-color:var(--ag-background-color);position:absolute}.ag-spanned-cell-wrapper>.ag-spanned-cell{display:block;position:relative}:where(.ag-ltr) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-right-color:transparent}:where(.ag-rtl) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-left-color:transparent}.ag-cell-wrapper{align-items:center;display:flex;>:where(:not(.ag-cell-value,.ag-group-value)){align-items:center;display:flex;height:var(--ag-internal-content-line-height)}&:where(.ag-row-group){align-items:flex-start}:where(.ag-full-width-row) &:where(.ag-row-group){align-items:center;height:100%}}:where(.ag-ltr) .ag-cell-wrapper{padding-left:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-rtl) .ag-cell-wrapper{padding-right:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-cell-wrap-text:not(.ag-cell-auto-height)) .ag-cell-wrapper{align-items:normal;height:100%;:where(.ag-cell-value){height:100%}}:where(.ag-ltr) .ag-row>.ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-row>.ag-cell-wrapper.ag-row-group{padding-right:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-cell-focus:not(.ag-cell-range-selected):focus-within,.ag-cell-range-single-cell,.ag-cell-range-single-cell.ag-cell-range-handle,.ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),.ag-context-menu-open .ag-full-width-row.ag-row-focus .ag-cell-wrapper.ag-row-group,.ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group{border:1px solid;border-color:var(--ag-range-selection-border-color);border-style:var(--ag-range-selection-border-style);outline:initial}.ag-full-width-row.ag-row-focus:focus{box-shadow:none}:where(.ag-ltr) .ag-group-contracted,:where(.ag-ltr) .ag-group-expanded,:where(.ag-ltr) .ag-row-drag,:where(.ag-ltr) .ag-selection-checkbox{margin-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-group-contracted,:where(.ag-rtl) .ag-group-expanded,:where(.ag-rtl) .ag-row-drag,:where(.ag-rtl) .ag-selection-checkbox{margin-left:var(--ag-cell-widget-spacing)}:where(.ag-ltr) .ag-group-child-count{margin-left:3px}:where(.ag-rtl) .ag-group-child-count{margin-right:3px}.ag-row-highlight-above:after,.ag-row-highlight-below:after,.ag-row-highlight-inside:after{background-color:var(--ag-range-selection-border-color);content:"";height:1px;pointer-events:none;position:absolute;width:calc(100% - 1px)}:where(.ag-ltr) .ag-row-highlight-above:after,:where(.ag-ltr) .ag-row-highlight-below:after,:where(.ag-ltr) .ag-row-highlight-inside:after{left:1px}:where(.ag-rtl) .ag-row-highlight-above:after,:where(.ag-rtl) .ag-row-highlight-below:after,:where(.ag-rtl) .ag-row-highlight-inside:after{right:1px}.ag-row-highlight-above:after{top:0}.ag-row-highlight-below:after{bottom:0}.ag-row-highlight-indent:after{display:block;width:auto}:where(.ag-ltr) .ag-row-highlight-indent:after{left:calc((var(--ag-cell-widget-spacing) + var(--ag-icon-size))*2 + var(--ag-cell-horizontal-padding) + var(--ag-row-highlight-level)*var(--ag-row-group-indent-size));right:1px}:where(.ag-rtl) .ag-row-highlight-indent:after{left:1px;right:calc((var(--ag-cell-widget-spacing) + var(--ag-icon-size))*2 + var(--ag-cell-horizontal-padding) + var(--ag-row-highlight-level)*var(--ag-row-group-indent-size))}.ag-row-highlight-inside:after{background-color:var(--ag-selected-row-background-color);border:1px solid var(--ag-range-selection-border-color);display:block;height:auto;inset:0;width:auto}.ag-row-odd{background-color:var(--ag-odd-row-background-color)}.ag-row-selected:before{background-color:var(--ag-selected-row-background-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-full-width-row.ag-row-group:before,.ag-row-hover:not(.ag-full-width-row):before{background-color:var(--ag-row-hover-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-row-selected:before{background-color:var(--ag-row-hover-color);background-image:linear-gradient(var(--ag-selected-row-background-color),var(--ag-selected-row-background-color))}.ag-row.ag-full-width-row.ag-row-group>*{position:relative}.ag-column-hover{background-color:var(--ag-column-hover-color)}.ag-header-range-highlight{background-color:var(--ag-range-header-highlight-color)}.ag-right-aligned-cell{font-variant-numeric:tabular-nums}:where(.ag-ltr) .ag-right-aligned-cell{text-align:right}:where(.ag-rtl) .ag-right-aligned-cell{text-align:left}.ag-right-aligned-cell .ag-cell-value,.ag-right-aligned-cell .ag-group-value{margin-left:auto}:where(.ag-ltr) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-ltr) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level));padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}:where(.ag-rtl) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-rtl) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-row>.ag-cell-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}.ag-row-dragging{cursor:move;opacity:.5}.ag-details-row{background-color:var(--ag-background-color);padding:calc(var(--ag-spacing)*3.75)}.ag-layout-auto-height,.ag-layout-print{.ag-center-cols-container,.ag-center-cols-viewport{min-height:150px}}.ag-overlay-loading-wrapper{background-color:var(--ag-modal-overlay-background-color)}.ag-skeleton-container{align-content:center;height:100%;width:100%}.ag-skeleton-effect{animation:ag-skeleton-loading 1.5s ease-in-out .5s infinite;background-color:var(--ag-row-loading-skeleton-effect-color);border-radius:.25rem;height:1em;width:100%}:where(.ag-ltr) .ag-right-aligned-cell .ag-skeleton-effect{margin-left:auto}:where(.ag-rtl) .ag-right-aligned-cell .ag-skeleton-effect{margin-right:auto}@keyframes ag-skeleton-loading{0%{background-color:var(--ag-row-loading-skeleton-effect-color)}50%{background-color:color-mix(in srgb,transparent,var(--ag-row-loading-skeleton-effect-color) 40%)}to{background-color:var(--ag-row-loading-skeleton-effect-color)}}.ag-loading{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-loading{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-loading{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-ltr) .ag-loading-icon{padding-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-loading-icon{padding-left:var(--ag-cell-widget-spacing)}.ag-icon-loading{animation-duration:1s;animation-iteration-count:infinite;animation-name:spin;animation-timing-function:linear}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.ag-header{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);color:var(--ag-header-text-color);display:flex;font-family:var(--ag-header-font-family);font-size:var(--ag-header-font-size);font-weight:var(--ag-header-font-weight);overflow:hidden;white-space:nowrap;width:100%}.ag-header-row{height:var(--ag-header-height);position:absolute}.ag-floating-filter-button-button,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,:where(.ag-header-cell-sortable) .ag-header-cell-label{cursor:pointer}:where(.ag-ltr) .ag-header-expand-icon{margin-left:4px}:where(.ag-rtl) .ag-header-expand-icon{margin-right:4px}.ag-header-row:where(:not(:first-child)){:where(.ag-header-cell:not(.ag-header-span-height.ag-header-span-total,.ag-header-parent-hidden),.ag-header-group-cell.ag-header-group-cell-with-group){border-top:var(--ag-header-row-border)}}.ag-header-row:where(:not(.ag-header-row-column-group)){overflow:hidden}:where(.ag-header.ag-header-allow-overflow) .ag-header-row{overflow:visible}.ag-header-cell{display:inline-flex;overflow:hidden}.ag-header-group-cell{contain:paint;display:flex}.ag-header-cell,.ag-header-group-cell{align-items:center;gap:var(--ag-cell-widget-spacing);height:100%;padding:0 var(--ag-cell-horizontal-padding);position:absolute}@property --ag-internal-moving-color{syntax:"<color>";inherits:false;initial-value:transparent}@property --ag-internal-hover-color{syntax:"<color>";inherits:false;initial-value:transparent}.ag-header-cell:where(:not(.ag-floating-filter)),.ag-header-group-cell{&:before{background-image:linear-gradient(var(--ag-internal-hover-color),var(--ag-internal-hover-color)),linear-gradient(var(--ag-internal-moving-color),var(--ag-internal-moving-color));content:"";inset:0;position:absolute;--ag-internal-moving-color:transparent;--ag-internal-hover-color:transparent;transition:--ag-internal-moving-color var(--ag-header-cell-background-transition-duration),--ag-internal-hover-color var(--ag-header-cell-background-transition-duration)}&:where(:hover):before{--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}&:where(.ag-header-cell-moving):before{--ag-internal-moving-color:var(--ag-header-cell-moving-background-color);--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}}:where(.ag-header-cell:not(.ag-floating-filter) *,.ag-header-group-cell *){position:relative;z-index:1}.ag-header-cell-menu-button:where(:not(.ag-header-menu-always-show)){opacity:0;transition:opacity .2s}.ag-header-cell-filter-button,:where(.ag-header-cell.ag-header-active) .ag-header-cell-menu-button{opacity:1}.ag-header-cell-label,.ag-header-group-cell-label{align-items:center;align-self:stretch;display:flex;flex:1 1 auto;overflow:hidden;padding:5px 0}:where(.ag-ltr) .ag-sort-indicator-icon{padding-left:var(--ag-spacing)}:where(.ag-rtl) .ag-sort-indicator-icon{padding-right:var(--ag-spacing)}.ag-header-cell-label{text-overflow:ellipsis}.ag-header-group-cell-label.ag-sticky-label{flex:none;max-width:100%;overflow:visible;position:sticky}:where(.ag-ltr) .ag-header-group-cell-label.ag-sticky-label{left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-header-group-cell-label.ag-sticky-label{right:var(--ag-cell-horizontal-padding)}.ag-header-cell-text,.ag-header-group-text{overflow:hidden;text-overflow:ellipsis}.ag-header-cell-text{word-break:break-word}.ag-header-cell-comp-wrapper{width:100%}:where(.ag-header-group-cell) .ag-header-cell-comp-wrapper{display:flex}:where(.ag-header-cell:not(.ag-header-cell-auto-height)) .ag-header-cell-comp-wrapper{align-items:center;display:flex;height:100%}.ag-header-cell-wrap-text .ag-header-cell-comp-wrapper{white-space:normal}.ag-header-cell-comp-wrapper-limited-height>*{overflow:hidden}:where(.ag-right-aligned-header) .ag-header-cell-label{flex-direction:row-reverse}:where(.ag-ltr) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-ltr) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}.ag-header-cell:after,.ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{content:"";height:var(--ag-header-column-border-height);position:absolute;top:calc(50% - var(--ag-header-column-border-height)*.5);z-index:1}:where(.ag-ltr) .ag-header-cell:after,:where(.ag-ltr) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-right:var(--ag-header-column-border);right:0}:where(.ag-rtl) .ag-header-cell:after,:where(.ag-rtl) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-left:var(--ag-header-column-border);left:0}.ag-header-highlight-after:after,.ag-header-highlight-before:after{background-color:var(--ag-accent-color);content:"";height:100%;position:absolute;width:1px}:where(.ag-ltr) .ag-header-highlight-before:after{left:0}:where(.ag-rtl) .ag-header-highlight-before:after{right:0}:where(.ag-ltr) .ag-header-highlight-after:after{right:0;:where(.ag-pinned-left-header) &{right:1px}}:where(.ag-rtl) .ag-header-highlight-after:after{left:0;:where(.ag-pinned-left-header) &{left:1px}}.ag-header-cell-resize{align-items:center;cursor:ew-resize;display:flex;height:100%;position:absolute;top:0;width:8px;z-index:2;&:after{background-color:var(--ag-header-column-resize-handle-color);content:"";height:var(--ag-header-column-resize-handle-height);position:absolute;top:calc(50% - var(--ag-header-column-resize-handle-height)*.5);width:var(--ag-header-column-resize-handle-width);z-index:1}}:where(.ag-ltr) .ag-header-cell-resize{right:-3px;&:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-rtl) .ag-header-cell-resize{left:-3px;&:after{right:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-header-cell.ag-header-span-height) .ag-header-cell-resize:after{height:calc(100% - var(--ag-spacing)*4);top:calc(var(--ag-spacing)*2)}.ag-header-group-cell-no-group:where(.ag-header-span-height){display:none}.ag-sort-indicator-container{display:flex;gap:var(--ag-spacing)}.ag-layout-print{&.ag-body{display:block;height:unset}&.ag-root-wrapper{display:inline-block}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:none}&.ag-force-vertical-scroll{overflow-y:visible!important}}@media print{.ag-root-wrapper.ag-layout-print{display:table;.ag-body-horizontal-scroll-viewport,.ag-body-viewport,.ag-center-cols-container,.ag-center-cols-viewport,.ag-root,.ag-root-wrapper-body,.ag-virtual-list-viewport{display:block!important;height:auto!important;overflow:hidden!important}.ag-cell,.ag-row{-moz-column-break-inside:avoid;break-inside:avoid}}}ag-grid,ag-grid-angular{display:block}.ag-root-wrapper{border:var(--ag-wrapper-border);border-radius:var(--ag-wrapper-border-radius);display:flex;flex-direction:column;overflow:hidden;position:relative;&.ag-layout-normal{height:100%}}.ag-root-wrapper-body{display:flex;flex-direction:row;&.ag-layout-normal{flex:1 1 auto;height:0;min-height:0}}.ag-root{display:flex;flex-direction:column;position:relative;&.ag-layout-auto-height,&.ag-layout-normal{flex:1 1 auto;overflow:hidden;width:0}&.ag-layout-normal{height:100%}}.ag-virtual-list-item{height:var(--ag-list-item-height);position:absolute;width:100%}.ag-list-item-hovered:after{background-color:var(--ag-accent-color);content:"";height:1px;left:0;position:absolute;right:0}.ag-item-highlight-top:after{top:0}.ag-item-highlight-bottom:after{bottom:0}.ag-drag-handle{color:var(--ag-drag-handle-color);cursor:grab;:where(.ag-icon){color:var(--ag-drag-handle-color)}}.ag-chart-menu-icon,.ag-chart-settings-next,.ag-chart-settings-prev,.ag-column-group-icons,.ag-column-select-header-icon,.ag-filter-toolpanel-expand,.ag-floating-filter-button-button,.ag-group-title-bar-icon,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,.ag-panel-title-bar-button-icon,.ag-set-filter-group-icons,:where(.ag-group-contracted) .ag-icon,:where(.ag-group-expanded) .ag-icon{background-color:var(--ag-icon-button-background-color);border-radius:var(--ag-icon-button-border-radius);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-background-color);color:var(--ag-icon-button-color);&:hover{background-color:var(--ag-icon-button-hover-background-color);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-hover-background-color);color:var(--ag-icon-button-hover-color)}}.ag-filter-active{background-image:linear-gradient(var(--ag-icon-button-active-background-color),var(--ag-icon-button-active-background-color));border-radius:1px;outline:solid var(--ag-icon-button-background-spread) var(--ag-icon-button-active-background-color);position:relative;&:after{background-color:var(--ag-icon-button-active-indicator-color);border-radius:50%;content:"";height:6px;position:absolute;top:-1px;width:6px}:where(.ag-icon-filter){clip-path:path("M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z");color:var(--ag-icon-button-active-color)}}:where(.ag-ltr) .ag-filter-active{&:after{right:-1px}}:where(.ag-rtl) .ag-filter-active{&:after{left:-1px}}.ag-menu{background-color:var(--ag-menu-background-color);border:var(--ag-menu-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-menu-shadow);color:var(--ag-menu-text-color);max-height:100%;overflow-y:auto;position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}`
);
var coreDefaults = {
  wrapperBorder: true,
  rowBorder: true,
  headerRowBorder: true,
  footerRowBorder: {
    ref: "rowBorder"
  },
  columnBorder: {
    style: "solid",
    width: 1,
    color: "transparent"
  },
  headerColumnBorder: false,
  headerColumnBorderHeight: "100%",
  pinnedColumnBorder: true,
  pinnedRowBorder: true,
  sidePanelBorder: true,
  sideBarPanelWidth: 250,
  sideBarBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  sideButtonBarBackgroundColor: {
    ref: "sideBarBackgroundColor"
  },
  sideButtonBarTopPadding: 0,
  sideButtonSelectedUnderlineWidth: 2,
  sideButtonSelectedUnderlineColor: "transparent",
  sideButtonSelectedUnderlineTransitionDuration: 0,
  sideButtonBackgroundColor: "transparent",
  sideButtonTextColor: { ref: "textColor" },
  sideButtonHoverBackgroundColor: { ref: "sideButtonBackgroundColor" },
  sideButtonHoverTextColor: { ref: "sideButtonTextColor" },
  sideButtonSelectedBackgroundColor: backgroundColor,
  sideButtonSelectedTextColor: { ref: "sideButtonTextColor" },
  sideButtonBorder: "solid 1px transparent",
  sideButtonSelectedBorder: true,
  sideButtonLeftPadding: { ref: "spacing" },
  sideButtonRightPadding: { ref: "spacing" },
  sideButtonVerticalPadding: { calc: "spacing * 3" },
  headerBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  headerFontFamily: {
    ref: "fontFamily"
  },
  cellFontFamily: {
    ref: "fontFamily"
  },
  headerFontWeight: 500,
  headerFontSize: {
    ref: "fontSize"
  },
  dataFontSize: {
    ref: "fontSize"
  },
  headerTextColor: {
    ref: "textColor"
  },
  headerCellHoverBackgroundColor: "transparent",
  headerCellMovingBackgroundColor: { ref: "headerCellHoverBackgroundColor" },
  headerCellBackgroundTransitionDuration: "0.2s",
  cellTextColor: {
    ref: "textColor"
  },
  rangeSelectionBorderStyle: "solid",
  rangeSelectionBorderColor: accentColor,
  rangeSelectionBackgroundColor: accentMix(0.2),
  rangeSelectionChartBackgroundColor: "#0058FF1A",
  rangeSelectionChartCategoryBackgroundColor: "#00FF841A",
  rangeSelectionHighlightColor: accentMix(0.5),
  rangeHeaderHighlightColor: foregroundHeaderBackgroundMix(0.08),
  rowNumbersSelectedColor: accentMix(0.5),
  rowHoverColor: accentMix(0.08),
  columnHoverColor: accentMix(0.05),
  selectedRowBackgroundColor: accentMix(0.12),
  modalOverlayBackgroundColor: {
    ref: "backgroundColor",
    mix: 0.66
  },
  oddRowBackgroundColor: backgroundColor,
  wrapperBorderRadius: 8,
  cellHorizontalPadding: {
    calc: "spacing * 2 * cellHorizontalPaddingScale"
  },
  cellWidgetSpacing: {
    calc: "spacing * 1.5"
  },
  cellHorizontalPaddingScale: 1,
  rowGroupIndentSize: {
    calc: "cellWidgetSpacing + iconSize"
  },
  valueChangeDeltaUpColor: "#43a047",
  valueChangeDeltaDownColor: "#e53935",
  valueChangeValueHighlightBackgroundColor: "#16a08580",
  rowHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 3.25 * rowVerticalPaddingScale"
  },
  rowVerticalPaddingScale: 1,
  headerHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 4 * headerVerticalPaddingScale"
  },
  headerVerticalPaddingScale: 1,
  paginationPanelHeight: {
    ref: "rowHeight",
    calc: "max(rowHeight, 22px)"
  },
  dragHandleColor: foregroundMix(0.7),
  headerColumnResizeHandleHeight: "30%",
  headerColumnResizeHandleWidth: 2,
  headerColumnResizeHandleColor: {
    ref: "borderColor"
  },
  widgetContainerHorizontalPadding: {
    calc: "spacing * 1.5"
  },
  widgetContainerVerticalPadding: {
    calc: "spacing * 1.5"
  },
  widgetHorizontalSpacing: {
    calc: "spacing * 1.5"
  },
  widgetVerticalSpacing: {
    ref: "spacing"
  },
  iconButtonColor: { ref: "iconColor" },
  iconButtonBackgroundColor: "transparent",
  iconButtonBackgroundSpread: 4,
  iconButtonBorderRadius: 1,
  iconButtonHoverColor: { ref: "iconButtonColor" },
  iconButtonHoverBackgroundColor: foregroundMix(0.1),
  iconButtonActiveColor: accentColor,
  iconButtonActiveBackgroundColor: accentMix(0.28),
  iconButtonActiveIndicatorColor: accentColor,
  menuBorder: {
    color: foregroundMix(0.2)
  },
  menuBackgroundColor: foregroundBackgroundMix(0.03),
  menuTextColor: foregroundBackgroundMix(0.95),
  menuShadow: {
    ref: "popupShadow"
  },
  menuSeparatorColor: {
    ref: "borderColor"
  },
  setFilterIndentSize: {
    ref: "iconSize"
  },
  chartMenuPanelWidth: 260,
  chartMenuLabelColor: foregroundMix(0.8),
  dialogShadow: {
    ref: "popupShadow"
  },
  cellEditingBorder: {
    color: accentColor
  },
  cellEditingShadow: { ref: "cardShadow" },
  fullRowEditInvalidBackgroundColor: {
    ref: "invalidColor",
    onto: "backgroundColor",
    mix: 0.25
  },
  dialogBorder: {
    color: foregroundMix(0.2)
  },
  panelBackgroundColor: backgroundColor,
  panelTitleBarBackgroundColor: {
    ref: "headerBackgroundColor"
  },
  panelTitleBarIconColor: {
    ref: "headerTextColor"
  },
  panelTitleBarTextColor: {
    ref: "headerTextColor"
  },
  panelTitleBarFontWeight: {
    ref: "headerFontWeight"
  },
  panelTitleBarBorder: true,
  columnSelectIndentSize: {
    ref: "iconSize"
  },
  toolPanelSeparatorBorder: true,
  columnDropCellBackgroundColor: foregroundMix(0.07),
  columnDropCellTextColor: {
    ref: "textColor"
  },
  columnDropCellDragHandleColor: {
    ref: "textColor"
  },
  columnDropCellBorder: {
    color: foregroundMix(0.13)
  },
  selectCellBackgroundColor: foregroundMix(0.07),
  selectCellBorder: {
    color: foregroundMix(0.13)
  },
  advancedFilterBuilderButtonBarBorder: true,
  advancedFilterBuilderIndentSize: {
    calc: "spacing * 2 + iconSize"
  },
  advancedFilterBuilderJoinPillColor: "#f08e8d",
  advancedFilterBuilderColumnPillColor: "#a6e194",
  advancedFilterBuilderOptionPillColor: "#f3c08b",
  advancedFilterBuilderValuePillColor: "#85c0e4",
  filterPanelApplyButtonColor: backgroundColor,
  filterPanelApplyButtonBackgroundColor: accentColor,
  filterPanelCardSubtleColor: {
    ref: "textColor",
    mix: 0.7
  },
  filterPanelCardSubtleHoverColor: { ref: "textColor" },
  findMatchColor: foregroundColor,
  findMatchBackgroundColor: "#ffff00",
  findActiveMatchColor: foregroundColor,
  findActiveMatchBackgroundColor: "#ffa500",
  filterToolPanelGroupIndent: {
    ref: "spacing"
  },
  rowLoadingSkeletonEffectColor: foregroundMix(0.15),
  statusBarLabelColor: foregroundColor,
  statusBarLabelFontWeight: 500,
  statusBarValueColor: foregroundColor,
  statusBarValueFontWeight: 500,
  pinnedSourceRowTextColor: {
    ref: "textColor"
  },
  pinnedSourceRowBackgroundColor: {
    ref: "backgroundColor"
  },
  pinnedSourceRowFontWeight: 600,
  pinnedRowFontWeight: 600,
  pinnedRowBackgroundColor: {
    ref: "backgroundColor"
  },
  pinnedRowTextColor: {
    ref: "textColor"
  }
};
var batchEditStyleDefaultCSS = (
  /*css*/
  `.ag-cell-batch-edit{background-color:var(--ag-cell-batch-edit-background-color);color:var(--ag-cell-batch-edit-text-color);display:inherit}.ag-row-batch-edit{background-color:var(--ag-row-batch-edit-background-color);color:var(--ag-row-batch-edit-text-color)}`
);
var baseParams = {
  cellBatchEditBackgroundColor: "rgba(220 181 139 / 16%)",
  cellBatchEditTextColor: "#422f00",
  rowBatchEditBackgroundColor: {
    ref: "cellBatchEditBackgroundColor"
  },
  rowBatchEditTextColor: {
    ref: "cellBatchEditTextColor"
  }
};
var baseDarkBatchEditParams = {
  ...baseParams,
  cellBatchEditTextColor: "#f3d0b3"
};
var makeBatchEditStyleBaseTreeShakeable = () => createPart({
  feature: "batchEditStyle",
  params: baseParams,
  css: batchEditStyleDefaultCSS
});
var batchEditStyleBase = /* @__PURE__ */ makeBatchEditStyleBaseTreeShakeable();
var buttonStyleBaseCSS = (
  /*css*/
  `:where(.ag-button){background:none;border:none;color:inherit;cursor:pointer;font-family:inherit;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0;text-indent:inherit;text-shadow:inherit;text-transform:inherit;word-spacing:inherit;&:disabled{cursor:default}&:focus-visible{box-shadow:var(--ag-focus-shadow);outline:none}}.ag-standard-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--ag-button-background-color);border:var(--ag-button-border);border-radius:var(--ag-button-border-radius);color:var(--ag-button-text-color);cursor:pointer;font-weight:var(--ag-button-font-weight);padding:var(--ag-button-vertical-padding) var(--ag-button-horizontal-padding);&:hover{background-color:var(--ag-button-hover-background-color);border:var(--ag-button-hover-border);color:var(--ag-button-hover-text-color)}&:active{background-color:var(--ag-button-active-background-color);border:var(--ag-button-active-border);color:var(--ag-button-active-text-color)}&:disabled{background-color:var(--ag-button-disabled-background-color);border:var(--ag-button-disabled-border);color:var(--ag-button-disabled-text-color)}}`
);
var baseParams2 = {
  buttonTextColor: "inherit",
  buttonFontWeight: "normal",
  buttonBackgroundColor: "transparent",
  buttonBorder: false,
  buttonBorderRadius: { ref: "borderRadius" },
  buttonHorizontalPadding: { calc: "spacing * 2" },
  buttonVerticalPadding: { ref: "spacing" },
  buttonHoverTextColor: { ref: "buttonTextColor" },
  buttonHoverBackgroundColor: { ref: "buttonBackgroundColor" },
  buttonHoverBorder: { ref: "buttonBorder" },
  buttonActiveTextColor: { ref: "buttonHoverTextColor" },
  buttonActiveBackgroundColor: { ref: "buttonHoverBackgroundColor" },
  buttonActiveBorder: { ref: "buttonHoverBorder" },
  buttonDisabledTextColor: { ref: "inputDisabledTextColor" },
  buttonDisabledBackgroundColor: { ref: "inputDisabledBackgroundColor" },
  buttonDisabledBorder: { ref: "inputDisabledBorder" }
};
var makeButtonStyleQuartzTreeShakeable = () => createPart({
  feature: "buttonStyle",
  params: {
    ...baseParams2,
    buttonBackgroundColor: backgroundColor,
    buttonBorder: true,
    buttonHoverBackgroundColor: { ref: "rowHoverColor" },
    buttonActiveBorder: { color: accentColor }
  },
  css: buttonStyleBaseCSS
});
var buttonStyleQuartz = /* @__PURE__ */ makeButtonStyleQuartzTreeShakeable();
var columnDropStyleBorderedCSS = (
  /*css*/
  `.ag-column-drop-vertical-empty-message{align-items:center;border:dashed var(--ag-border-width);border-color:var(--ag-border-color);display:flex;inset:0;justify-content:center;margin:calc(var(--ag-spacing)*1.5) calc(var(--ag-spacing)*2);overflow:hidden;padding:calc(var(--ag-spacing)*2);position:absolute}`
);
var makeColumnDropStyleBorderedTreeShakeable = () => {
  return createPart({
    feature: "columnDropStyle",
    css: columnDropStyleBorderedCSS
  });
};
var columnDropStyleBordered = /* @__PURE__ */ makeColumnDropStyleBorderedTreeShakeable();
var gridThemeLogger = {
  warn: (...args) => {
    _warn(args[0], args[1]);
  },
  error: (...args) => {
    _error(args[0], args[1]);
  },
  preInitErr: (...args) => {
    _logPreInitErr(args[0], args[2], args[1]);
  }
};
var createTheme = () => createSharedTheme(gridThemeLogger).withParams(coreDefaults).withPart(buttonStyleQuartz).withPart(columnDropStyleBordered).withPart(batchEditStyleBase);
var checkboxStyleDefaultCSS = (
  /*css*/
  `.ag-checkbox-input-wrapper,.ag-radio-button-input-wrapper{background-color:var(--ag-checkbox-unchecked-background-color);border:solid var(--ag-checkbox-border-width) var(--ag-checkbox-unchecked-border-color);flex:none;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);:where(input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-icon-size);margin:0;opacity:0;width:var(--ag-icon-size)}&:after{content:"";display:block;inset:0;-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;pointer-events:none;position:absolute}&:where(.ag-checked){background-color:var(--ag-checkbox-checked-background-color);border-color:var(--ag-checkbox-checked-border-color);&:after{background-color:var(--ag-checkbox-checked-shape-color)}}&:where(:focus-within,:active){box-shadow:var(--ag-focus-shadow)}&:where(.ag-disabled){filter:grayscale();opacity:.5}}.ag-checkbox-input-wrapper{border-radius:var(--ag-checkbox-border-radius);&:where(.ag-checked):after{-webkit-mask-image:var(--ag-checkbox-checked-shape-image);mask-image:var(--ag-checkbox-checked-shape-image)}&:where(.ag-indeterminate){background-color:var(--ag-checkbox-indeterminate-background-color);border-color:var(--ag-checkbox-indeterminate-border-color);&:after{background-color:var(--ag-checkbox-indeterminate-shape-color);-webkit-mask-image:var(--ag-checkbox-indeterminate-shape-image);mask-image:var(--ag-checkbox-indeterminate-shape-image)}}}.ag-cell-editing-error .ag-checkbox-input-wrapper:focus-within{box-shadow:var(--ag-focus-error-shadow)}.ag-radio-button-input-wrapper{border-radius:100%;&:where(.ag-checked):after{-webkit-mask-image:var(--ag-radio-checked-shape-image);mask-image:var(--ag-radio-checked-shape-image)}}`
);
var makeCheckboxStyleDefaultTreeShakeable = () => createPart({
  feature: "checkboxStyle",
  params: {
    checkboxBorderWidth: 1,
    checkboxBorderRadius: {
      ref: "borderRadius"
    },
    checkboxUncheckedBackgroundColor: backgroundColor,
    checkboxUncheckedBorderColor: foregroundBackgroundMix(0.3),
    checkboxCheckedBackgroundColor: accentColor,
    checkboxCheckedBorderColor: { ref: "checkboxCheckedBackgroundColor" },
    checkboxCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="7" fill="none"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.75" d="M1 3.5 3.5 6l5-5"/></svg>'
    },
    checkboxCheckedShapeColor: backgroundColor,
    checkboxIndeterminateBackgroundColor: foregroundBackgroundMix(0.3),
    checkboxIndeterminateBorderColor: { ref: "checkboxIndeterminateBackgroundColor" },
    checkboxIndeterminateShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="2" fill="none"><rect width="10" height="2" fill="#000" rx="1"/></svg>'
    },
    checkboxIndeterminateShapeColor: backgroundColor,
    radioCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="6" height="6" fill="none"><circle cx="3" cy="3" r="3" fill="#000"/></svg>'
    }
  },
  css: checkboxStyleDefaultCSS
});
var checkboxStyleDefault = /* @__PURE__ */ makeCheckboxStyleDefaultTreeShakeable();
var darkParams = () => ({
  ...defaultLightColorSchemeParams,
  ...baseDarkBatchEditParams,
  backgroundColor: "hsl(217, 0%, 17%)",
  foregroundColor: "#FFF",
  chromeBackgroundColor: foregroundBackgroundMix(0.05),
  rowHoverColor: accentMix(0.15),
  selectedRowBackgroundColor: accentMix(0.2),
  menuBackgroundColor: foregroundBackgroundMix(0.1),
  browserColorScheme: "dark",
  popupShadow: "0 0px 20px #000A",
  cardShadow: "0 1px 4px 1px #000A",
  advancedFilterBuilderJoinPillColor: "#7a3a37",
  advancedFilterBuilderColumnPillColor: "#355f2d",
  advancedFilterBuilderOptionPillColor: "#5a3168",
  advancedFilterBuilderValuePillColor: "#374c86",
  filterPanelApplyButtonColor: foregroundColor,
  findMatchColor: backgroundColor,
  findActiveMatchColor: backgroundColor,
  checkboxUncheckedBorderColor: foregroundBackgroundMix(0.4),
  toggleButtonOffBackgroundColor: foregroundBackgroundMix(0.4),
  rowBatchEditBackgroundColor: foregroundBackgroundMix(0.1)
});
var darkBlueParams = () => ({
  ...darkParams(),
  backgroundColor: "#1f2836"
});
var makeColorSchemeVariableTreeShakeable = () => createPart({
  feature: "colorScheme",
  params: defaultLightColorSchemeParams,
  modeParams: {
    light: defaultLightColorSchemeParams,
    dark: darkParams(),
    "dark-blue": darkBlueParams()
  }
});
var colorSchemeVariable = /* @__PURE__ */ makeColorSchemeVariableTreeShakeable();
var iconNameToSvgFragment = {
  aggregation: '<path d="M18 7V4H6l6 8-6 8h12v-3"/>',
  arrows: '<polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/>',
  asc: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  cancel: '<path d="m18 6-12 12"/><path d="m6 6 12 12"/>',
  chart: '<line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/>',
  "color-picker": '<path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/><path d="m5 2 5 5"/><path d="M2 13h15"/><path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z"/>',
  columns: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"/>',
  contracted: '<path d="m9 18 6-6-6-6"/>',
  copy: '<rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>',
  cross: '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>',
  csv: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  cut: '<circle cx="6" cy="6" r="3"/><path d="M8.12 8.12 12 12"/><path d="M20 4 8.12 15.88"/><circle cx="6" cy="18" r="3"/><path d="M14.8 14.8 20 20"/>',
  desc: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  down: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  excel: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  expanded: '<path d="m15 18-6-6 6-6"/>',
  "eye-slash": '<path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/>',
  eye: '<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>',
  filter: '<path d="M3 6h18"/><path d="M7 12h10"/><path d="M10 18h4"/>',
  first: '<path d="m17 18-6-6 6-6"/><path d="M7 6v12"/>',
  group: '<path d="M16 12H3"/><path d="M16 18H3"/><path d="M10 6H3"/><path d="M21 18V8a2 2 0 0 0-2-2h-5"/><path d="m16 8-2-2 2-2"/>',
  last: '<path d="m7 18 6-6-6-6"/><path d="M17 6v12"/>',
  left: '<path d="m12 19-7-7 7-7"/><path d="M19 12H5"/>',
  linked: '<path d="M9 17H7A5 5 0 0 1 7 7h2"/><path d="M15 7h2a5 5 0 1 1 0 10h-2"/><line x1="8" x2="16" y1="12" y2="12"/>',
  loading: '<line x1="12" x2="12" y1="2" y2="6"/><line x1="12" x2="12" y1="18" y2="22"/><line x1="4.93" x2="7.76" y1="4.93" y2="7.76"/><line x1="16.24" x2="19.07" y1="16.24" y2="19.07"/><line x1="2" x2="6" y1="12" y2="12"/><line x1="18" x2="22" y1="12" y2="12"/><line x1="4.93" x2="7.76" y1="19.07" y2="16.24"/><line x1="16.24" x2="19.07" y1="7.76" y2="4.93"/>',
  maximize: '<polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/>',
  menu: '<line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/>',
  "menu-alt": '<circle cx="12" cy="5" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="12" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="19" r="0.75" fill="#D9D9D9"/>',
  minimize: '<polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/>',
  minus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/>',
  next: '<path d="m9 18 6-6-6-6"/>',
  none: '<path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/>',
  "not-allowed": '<circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/>',
  paste: '<path d="M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z"/><path d="M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10"/><path d="m17 10 4 4-4 4"/>',
  pin: '<line x1="12" x2="12" y1="17" y2="22"/><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z"/>',
  pivot: '<path d="M15 3v18"/><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M21 9H3"/><path d="M21 15H3"/>',
  plus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/>',
  previous: '<path d="m15 18-6-6 6-6"/>',
  right: '<path d="M5 12h14"/><path d="m12 5 7 7-7 7"/>',
  save: '<path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/>',
  "small-left": '<path d="m15 18-6-6 6-6"/>',
  "small-right": '<path d="m9 18 6-6-6-6"/>',
  tick: '<path d="M20 6 9 17l-5-5"/>',
  "tree-closed": '<path d="m9 18 6-6-6-6"/>',
  "tree-indeterminate": '<path d="M5 12h14"/>',
  "tree-open": '<path d="m6 9 6 6 6-6"/>',
  unlinked: '<path d="M9 17H7A5 5 0 0 1 7 7"/><path d="M15 7h2a5 5 0 0 1 4 8"/><line x1="8" x2="12" y1="12" y2="12"/><line x1="2" x2="22" y1="2" y2="22"/>',
  up: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  grip: '<circle cx="5" cy="8" r="0.5"/><circle cx="12" cy="8" r="0.5"/><circle cx="19" cy="8" r="0.5"/><circle cx="5" cy="16" r="0.5"/><circle cx="12" cy="16" r="0.5"/><circle cx="19" cy="16" r="0.5"/><g stroke="none" fill="currentColor"><circle cx="5" cy="8" r="1"/><circle cx="12" cy="8" r="1"/><circle cx="19" cy="8" r="1"/><circle cx="5" cy="16" r="1"/><circle cx="12" cy="16" r="1"/><circle cx="19" cy="16" r="1"/></g>',
  settings: '<path d="M20 7h-9"/><path d="M14 17H5"/><circle cx="17" cy="17" r="3"/><circle cx="7" cy="7" r="3"/>'
};
var iconNameToFullSvg = {
  "column-arrow": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" viewBox="0 0 32 32"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 26C0 28.2092 1.79086 30 4 30H14C16.2091 30 18 28.2092 18 26V15H25.8786L24.4394 16.4393C23.8536 17.0251 23.8536 17.9749 24.4394 18.5607C25.0252 19.1464 25.9748 19.1464 26.5606 18.5607L30.5606 14.5607C31.1464 13.9749 31.1464 13.0251 30.5606 12.4393L26.5606 8.43934C25.9748 7.85356 25.0252 7.85356 24.4394 8.43934C23.8536 9.02512 23.8536 9.97488 24.4394 10.5607L25.8786 12H18V6C18 3.79086 16.2091 2 14 2H4C1.79086 2 0 3.79086 0 6V26ZM14 5H10.5V12H15V6C15 5.44772 14.5523 5 14 5ZM4 5H7.5V12H3V6C3 5.44772 3.44772 5 4 5ZM10.5 15H15V26C15 26.5522 14.5523 27 14 27H10.5V15ZM4 27H7.5V15H3V26C3 26.5522 3.44772 27 4 27Z" fill="currentColor"/></svg>',
  "small-down": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 10.667 16 21.334l8.667-10.667H7.334Z"/></svg>',
  "small-up": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 21.333 16 10.666l8.667 10.667H7.334Z"/></svg>',
  "pinned-top": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="M12.53 3.72A.75.75 0 0 1 12 5H4a.75.75 0 0 1 0-1.5h8a.75.75 0 0 1 .53.22ZM3.269 10.744a.75.75 0 0 1 .2-.524l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 1 1-1.06 1.06L8.75 8.56V14a.75.75 0 0 1-1.5 0V8.56l-2.72 2.72a.75.75 0 0 1-1.26-.536Z"/></svg>',
  "pinned-bottom": '<svg xmlns="http://www.w3.org/2000/svg" fill="none" class="ag-icon" viewBox="0 0 16 16"><path fill="currentColor" d="M3.47 12.28A.75.75 0 0 1 4 11h8a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.53-.22ZM12.731 5.256a.75.75 0 0 1-.2.524l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 1 1 1.06-1.06l2.72 2.72V2a.75.75 0 0 1 1.5 0v5.44l2.72-2.72a.75.75 0 0 1 1.26.536Z"/></svg>',
  "un-pin": '<svg xmlns="http://www.w3.org/2000/svg" fill="none" class="ag-icon" viewBox="0 0 16 16"><path fill="currentColor" d="M8 11a.75.75 0 0 0-.75.75v3.333a.75.75 0 1 0 1.5 0V11.75A.75.75 0 0 0 8 11Z"/><path fill="currentColor" d="M13.11 1.436a.75.75 0 0 0-1.22-.872l-10 14a.75.75 0 1 0 1.22.872L5.207 12.5h7.376a.75.75 0 0 0 .75-.75v-1.174a2.08 2.08 0 0 0-1.153-1.863l-1.185-.599-.005-.002a.58.58 0 0 1-.323-.522V5.165a2.083 2.083 0 0 0 1.854-2.904l.589-.825Zm-3.943 5.52v.634a2.08 2.08 0 0 0 1.153 1.863l1.185.6.005.002a.58.58 0 0 1 .323.522V11H6.28l2.887-4.044ZM9.277 1H5.25a2.084 2.084 0 0 0-.083 4.165v1.676l1.5-2.132v-.292a.75.75 0 0 0-.75-.75H5.25a.584.584 0 0 1 0-1.167h2.972L9.277 1Z"/></svg>',
  "chevron-down": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 6L8 10L4 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  "chevron-up": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 10L8 6L12 10" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  "chevron-left": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  "chevron-right": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 12L10 8L6 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>',
  "filter-add": '<svg width="16" height="16" viewBox="0 0 16 16" class="ag-icon" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.12126 7.75L10.8517 7.75" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M6.65934 11.748L9.32778 11.748" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M12.2943 1.04872V6.19184M14.9886 3.74341H9.68478" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M8.25488 3C8.04799 3.18323 7.91706 3.45099 7.91699 3.74902C7.91713 4.04868 8.04988 4.31681 8.25879 4.5H2C1.58579 4.5 1.25 4.16421 1.25 3.75C1.25 3.33579 1.58579 3 2 3H8.25488Z" fill="currentColor"/></svg>',
  edit: '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 10.6262V12.5012H5.375L10.905 6.97122L9.03 5.09622L3.5 10.6262ZM12.355 5.52122C12.4014 5.47497 12.4381 5.42002 12.4632 5.35953C12.4883 5.29905 12.5012 5.23421 12.5012 5.16872C12.5012 5.10324 12.4883 5.0384 12.4632 4.97791C12.4381 4.91742 12.4014 4.86248 12.355 4.81622L11.185 3.64622C11.1387 3.59987 11.0838 3.5631 11.0233 3.53801C10.9628 3.51291 10.898 3.5 10.8325 3.5C10.767 3.5 10.7022 3.51291 10.6417 3.53801C10.5812 3.5631 10.5263 3.59987 10.48 3.64622L9.565 4.56122L11.44 6.43622L12.355 5.52122Z" fill="currentColor"/></svg>'
};
var getQuartzIconsCss = (args = {}) => {
  let result = "";
  for (const iconName of [...Object.keys(iconNameToSvgFragment), ...Object.keys(iconNameToFullSvg)]) {
    const iconSvg = quartzIconSvg(iconName, args.strokeWidth);
    result += `.ag-icon-${iconName}::before { mask-image: url('data:image/svg+xml,${encodeURIComponent(iconSvg)}'); }
`;
  }
  return result;
};
var quartzIconSvg = (name, strokeWidth = 1.5) => {
  const fullSVG = iconNameToFullSvg[name];
  if (fullSVG)
    return fullSVG;
  const svgFragment = iconNameToSvgFragment[name];
  if (!svgFragment)
    throw new Error(`Missing icon data for ${name}`);
  return `<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="black" stroke-width="${strokeWidth}" viewBox="0 0 24 24"><style>* { vector-effect: non-scaling-stroke; }</style>` + svgFragment + "</svg>";
};
var iconSetQuartz = (args = {}) => {
  return createPart({
    feature: "iconSet",
    css: () => getQuartzIconsCss(args)
  });
};
var iconSetQuartzRegular = /* @__PURE__ */ iconSetQuartz();
var inputStyleBaseCSS = (
  /*css*/
  `:where(.ag-input-field-input[type=number]:not(.ag-number-field-input-stepper)){-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield;&::-webkit-inner-spin-button,&::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}}.ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);color:var(--ag-input-text-color);font-family:inherit;font-size:inherit;line-height:inherit;margin:0;min-height:var(--ag-input-height);padding:0;&:where(:disabled){background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}&:where(:focus){background-color:var(--ag-input-focus-background-color);border:var(--ag-input-focus-border);box-shadow:var(--ag-input-focus-shadow);color:var(--ag-input-focus-text-color);outline:none}&:where(:invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&::-moz-placeholder{color:var(--ag-input-placeholder-text-color)}&::placeholder{color:var(--ag-input-placeholder-text-color)}}:where(.ag-ltr) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-left:var(--ag-input-padding-start)}:where(.ag-rtl) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-right:var(--ag-input-padding-start)}:where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{background-color:currentcolor;color:var(--ag-input-icon-color);content:"";display:block;height:12px;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;opacity:.5;position:absolute;width:12px}}:where(.ag-ltr) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{margin-left:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-left:calc(var(--ag-spacing)*1.5 + 12px)}}:where(.ag-rtl) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter,.ag-filter-add-select){.ag-input-wrapper:before{margin-right:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-right:calc(var(--ag-spacing)*1.5 + 12px)}}`
);
var inputStyleBorderedCSS = (
  /*css*/
  `.ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){&:focus{box-shadow:var(--ag-focus-shadow);&:where(.invalid),&:where(:invalid){box-shadow:var(--ag-focus-error-shadow)}}}`
);
var baseParams3 = {
  inputBackgroundColor: "transparent",
  inputBorder: false,
  inputBorderRadius: 0,
  inputTextColor: {
    ref: "textColor"
  },
  inputPlaceholderTextColor: {
    ref: "inputTextColor",
    mix: 0.5
  },
  inputPaddingStart: 0,
  inputHeight: {
    calc: "max(iconSize, fontSize) + spacing * 2"
  },
  inputFocusBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputFocusBorder: {
    ref: "inputBorder"
  },
  inputFocusShadow: "none",
  inputFocusTextColor: {
    ref: "inputTextColor"
  },
  inputDisabledBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputDisabledBorder: {
    ref: "inputBorder"
  },
  inputDisabledTextColor: {
    ref: "inputTextColor"
  },
  inputInvalidBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputInvalidBorder: {
    ref: "inputBorder"
  },
  inputInvalidTextColor: {
    ref: "inputTextColor"
  },
  inputIconColor: {
    ref: "inputTextColor"
  },
  pickerButtonBorder: false,
  pickerButtonFocusBorder: { ref: "inputFocusBorder" },
  pickerButtonBackgroundColor: { ref: "backgroundColor" },
  pickerButtonFocusBackgroundColor: { ref: "backgroundColor" },
  pickerListBorder: false,
  pickerListBackgroundColor: { ref: "backgroundColor" },
  colorPickerThumbSize: 18,
  colorPickerTrackSize: 12,
  colorPickerThumbBorderWidth: 3,
  colorPickerTrackBorderRadius: 12,
  colorPickerColorBorderRadius: 4
};
var makeInputStyleBorderedTreeShakeable = () => createPart({
  feature: "inputStyle",
  params: {
    ...baseParams3,
    inputBackgroundColor: backgroundColor,
    inputBorder: true,
    inputBorderRadius: {
      ref: "borderRadius"
    },
    inputPaddingStart: {
      ref: "spacing"
    },
    inputFocusBorder: {
      color: accentColor
    },
    inputFocusShadow: {
      ref: "focusShadow"
    },
    inputDisabledBackgroundColor: foregroundBackgroundMix(0.06),
    inputDisabledTextColor: {
      ref: "textColor",
      mix: 0.5
    },
    inputInvalidBorder: {
      color: { ref: "invalidColor" }
    },
    pickerButtonBorder: true,
    pickerListBorder: true
  },
  css: () => inputStyleBaseCSS + inputStyleBorderedCSS
});
var inputStyleBordered = /* @__PURE__ */ makeInputStyleBorderedTreeShakeable();
var tabStyleBaseCSS = (
  /*css*/
  `.ag-tabs-header{background-color:var(--ag-tab-bar-background-color);border-bottom:var(--ag-tab-bar-border);display:flex;flex:1;gap:var(--ag-tab-spacing);padding:var(--ag-tab-bar-top-padding) var(--ag-tab-bar-horizontal-padding) 0}.ag-tabs-header-wrapper{display:flex}.ag-tabs-close-button-wrapper{align-items:center;border:0;display:flex;padding:var(--ag-spacing)}:where(.ag-ltr) .ag-tabs-close-button-wrapper{border-right:solid var(--ag-border-width) var(--ag-border-color)}:where(.ag-rtl) .ag-tabs-close-button-wrapper{border-left:solid var(--ag-border-width) var(--ag-border-color)}.ag-tabs-close-button{background-color:unset;border:0;cursor:pointer;padding:0}.ag-tab{align-items:center;background-color:var(--ag-tab-background-color);border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;color:var(--ag-tab-text-color);cursor:pointer;display:flex;flex:1;justify-content:center;padding:var(--ag-tab-top-padding) var(--ag-tab-horizontal-padding) var(--ag-tab-bottom-padding);position:relative;&:hover{background-color:var(--ag-tab-hover-background-color);color:var(--ag-tab-hover-text-color)}&.ag-tab-selected{background-color:var(--ag-tab-selected-background-color);color:var(--ag-tab-selected-text-color)}&:after{background-color:var(--ag-tab-selected-underline-color);bottom:0;content:"";display:block;height:var(--ag-tab-selected-underline-width);left:0;opacity:0;position:absolute;right:0;transition:opacity var(--ag-tab-selected-underline-transition-duration)}&.ag-tab-selected:after{opacity:1}}:where(.ag-ltr) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-left-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-right-color:var(--ag-tab-selected-border-color)}}}:where(.ag-rtl) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-right-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-left-color:var(--ag-tab-selected-border-color)}}}`
);
var baseParams4 = {
  tabBarBackgroundColor: "transparent",
  tabBarHorizontalPadding: 0,
  tabBarTopPadding: 0,
  tabBackgroundColor: "transparent",
  tabTextColor: {
    ref: "textColor"
  },
  tabHorizontalPadding: {
    ref: "spacing"
  },
  tabTopPadding: {
    ref: "spacing"
  },
  tabBottomPadding: {
    ref: "spacing"
  },
  tabSpacing: "0",
  tabHoverBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabHoverTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabSelectedTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBorderWidth: { ref: "borderWidth" },
  tabSelectedBorderColor: "transparent",
  tabSelectedUnderlineColor: "transparent",
  tabSelectedUnderlineWidth: 0,
  tabSelectedUnderlineTransitionDuration: 0,
  tabBarBorder: false
};
var makeTabStyleQuartzTreeShakeable = () => createPart({
  feature: "tabStyle",
  params: {
    ...baseParams4,
    tabBarBorder: true,
    tabBarBackgroundColor: foregroundMix(0.05),
    tabTextColor: {
      ref: "textColor",
      mix: 0.7
    },
    tabSelectedTextColor: {
      ref: "textColor"
    },
    tabHoverTextColor: {
      ref: "textColor"
    },
    tabSelectedBorderColor: {
      ref: "borderColor"
    },
    tabSelectedBackgroundColor: backgroundColor
  },
  css: tabStyleBaseCSS
});
var tabStyleQuartz = /* @__PURE__ */ makeTabStyleQuartzTreeShakeable();
var makeThemeQuartzTreeShakeable = () => createTheme().withPart(checkboxStyleDefault).withPart(colorSchemeVariable).withPart(iconSetQuartzRegular).withPart(tabStyleQuartz).withPart(inputStyleBordered).withPart(columnDropStyleBordered).withParams({
  fontFamily: [
    { googleFont: "IBM Plex Sans" },
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu"
  ]
});
var themeQuartz = /* @__PURE__ */ makeThemeQuartzTreeShakeable();
var CELL_HORIZONTAL_PADDING = {
  cssName: "--ag-cell-horizontal-padding",
  changeKey: "cellHorizontalPaddingChanged",
  defaultValue: 16
};
var INDENTATION_LEVEL = {
  cssName: "--ag-indentation-level",
  changeKey: "indentationLevelChanged",
  defaultValue: 0,
  noWarn: true,
  cacheDefault: true
};
var ROW_GROUP_INDENT_SIZE = {
  cssName: "--ag-row-group-indent-size",
  changeKey: "rowGroupIndentSizeChanged",
  defaultValue: 0
};
var ROW_HEIGHT = {
  cssName: "--ag-row-height",
  changeKey: "rowHeightChanged",
  defaultValue: 42
};
var HEADER_HEIGHT = {
  cssName: "--ag-header-height",
  changeKey: "headerHeightChanged",
  defaultValue: 48
};
var LIST_ITEM_HEIGHT = {
  cssName: "--ag-list-item-height",
  changeKey: "listItemHeightChanged",
  defaultValue: 24
};
var ROW_BORDER_WIDTH = {
  cssName: "--ag-row-border",
  changeKey: "rowBorderWidthChanged",
  defaultValue: 1,
  border: true
};
var PINNED_BORDER_WIDTH = {
  cssName: "--ag-pinned-row-border",
  changeKey: "pinnedRowBorderWidthChanged",
  defaultValue: 1,
  border: true
};
function _addAdditionalCss(cssMap, modules) {
  modules.sort((a, b) => a.moduleName.localeCompare(b.moduleName)).forEach((module2) => {
    const moduleCss = module2.css;
    if (moduleCss) {
      cssMap.set(`module-${module2.moduleName}`, moduleCss);
    }
  });
}
var Environment = class extends BaseEnvironment {
  constructor() {
    super(...arguments);
    this.sizeEls = /* @__PURE__ */ new Map();
    this.lastKnownValues = /* @__PURE__ */ new Map();
    this.sizesMeasured = false;
  }
  initVariables() {
    this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable());
    this.getSizeEl(ROW_HEIGHT);
    this.getSizeEl(HEADER_HEIGHT);
    this.getSizeEl(LIST_ITEM_HEIGHT);
    this.getSizeEl(ROW_BORDER_WIDTH);
    this.getSizeEl(PINNED_BORDER_WIDTH);
    this.refreshRowBorderWidthVariable();
  }
  getPinnedRowBorderWidth() {
    return this.getCSSVariablePixelValue(PINNED_BORDER_WIDTH);
  }
  getRowBorderWidth() {
    return this.getCSSVariablePixelValue(ROW_BORDER_WIDTH);
  }
  getDefaultRowHeight() {
    return this.getCSSVariablePixelValue(ROW_HEIGHT);
  }
  getDefaultHeaderHeight() {
    return this.getCSSVariablePixelValue(HEADER_HEIGHT);
  }
  getDefaultCellHorizontalPadding() {
    return this.getCSSVariablePixelValue(CELL_HORIZONTAL_PADDING);
  }
  getCellPaddingLeft() {
    const cellHorizontalPadding = this.getDefaultCellHorizontalPadding();
    const indentationLevel = this.getCSSVariablePixelValue(INDENTATION_LEVEL);
    const rowGroupIndentSize = this.getCSSVariablePixelValue(ROW_GROUP_INDENT_SIZE);
    return cellHorizontalPadding - 1 + rowGroupIndentSize * indentationLevel;
  }
  getCellPadding() {
    const cellPaddingRight = this.getDefaultCellHorizontalPadding() - 1;
    return this.getCellPaddingLeft() + cellPaddingRight;
  }
  getDefaultColumnMinWidth() {
    return Math.min(36, this.getDefaultRowHeight());
  }
  getDefaultListItemHeight() {
    return this.getCSSVariablePixelValue(LIST_ITEM_HEIGHT);
  }
  refreshRowHeightVariable() {
    const { eRootDiv } = this;
    const oldRowHeight = eRootDiv.style.getPropertyValue("--ag-line-height").trim();
    const height = this.gos.get("rowHeight");
    if (height == null || isNaN(height) || !isFinite(height)) {
      if (oldRowHeight !== null) {
        eRootDiv.style.setProperty("--ag-line-height", null);
      }
      return -1;
    }
    const newRowHeight = `${height}px`;
    if (oldRowHeight != newRowHeight) {
      eRootDiv.style.setProperty("--ag-line-height", newRowHeight);
      return height;
    }
    return oldRowHeight != "" ? parseFloat(oldRowHeight) : -1;
  }
  getCSSVariablePixelValue(variable) {
    const cached = this.lastKnownValues.get(variable);
    if (cached != null) {
      return cached;
    }
    const measurement = this.measureSizeEl(variable);
    if (measurement === "detached" || measurement === "no-styles") {
      if (variable.cacheDefault) {
        this.lastKnownValues.set(variable, variable.defaultValue);
      }
      return variable.defaultValue;
    }
    this.lastKnownValues.set(variable, measurement);
    return measurement;
  }
  measureSizeEl(variable) {
    const sizeEl = this.getSizeEl(variable);
    if (sizeEl.offsetParent == null) {
      return "detached";
    }
    const newSize = sizeEl.offsetWidth;
    if (newSize === NO_VALUE_SENTINEL)
      return "no-styles";
    this.sizesMeasured = true;
    return newSize;
  }
  getMeasurementContainer() {
    let container = this.eMeasurementContainer;
    if (!container) {
      container = this.eMeasurementContainer = _createElement({ tag: "div", cls: "ag-measurement-container" });
      this.eRootDiv.appendChild(container);
    }
    return container;
  }
  getSizeEl(variable) {
    let sizeEl = this.sizeEls.get(variable);
    if (sizeEl) {
      return sizeEl;
    }
    const container = this.getMeasurementContainer();
    sizeEl = _createElement({ tag: "div" });
    const { border, noWarn } = variable;
    if (border) {
      sizeEl.className = "ag-measurement-element-border";
      sizeEl.style.setProperty(
        "--ag-internal-measurement-border",
        `var(${variable.cssName}, solid ${NO_VALUE_SENTINEL}px)`
      );
    } else {
      sizeEl.style.width = `var(${variable.cssName}, ${NO_VALUE_SENTINEL}px)`;
    }
    container.appendChild(sizeEl);
    this.sizeEls.set(variable, sizeEl);
    let lastMeasurement = this.measureSizeEl(variable);
    if (lastMeasurement === "no-styles" && !noWarn) {
      _warn(9, { variable });
    }
    const unsubscribe = _observeResize(this.beans, sizeEl, () => {
      const newMeasurement = this.measureSizeEl(variable);
      if (newMeasurement === "detached" || newMeasurement === "no-styles") {
        return;
      }
      this.lastKnownValues.set(variable, newMeasurement);
      if (newMeasurement !== lastMeasurement) {
        lastMeasurement = newMeasurement;
        this.fireStylesChangedEvent(variable.changeKey);
      }
    });
    this.addDestroyFunc(() => unsubscribe());
    return sizeEl;
  }
  fireStylesChangedEvent(change) {
    if (change === "rowBorderWidthChanged") {
      this.refreshRowBorderWidthVariable();
    }
    this.eventSvc.dispatchEvent({
      type: "gridStylesChanged",
      [change]: true
    });
  }
  refreshRowBorderWidthVariable() {
    const width = this.getCSSVariablePixelValue(ROW_BORDER_WIDTH);
    this.eRootDiv.style.setProperty("--ag-internal-row-border-width", `${width}px`);
  }
  postProcessThemeChange(newGridTheme, themeGridOption) {
    if (newGridTheme && getComputedStyle(this.getMeasurementContainer()).getPropertyValue("--ag-legacy-styles-loaded")) {
      if (themeGridOption) {
        _error(106);
      } else {
        _error(239);
      }
    }
  }
  getAdditionalCss() {
    const additionalCss = /* @__PURE__ */ new Map();
    additionalCss.set("core", [coreCSS]);
    _addAdditionalCss(additionalCss, Array.from(_getAllRegisteredModules()));
    return additionalCss;
  }
  getDefaultTheme() {
    return themeQuartz;
  }
  themeError(theme) {
    _error(240, { theme });
  }
};
var NO_VALUE_SENTINEL = 15538;
var EventService = class extends BaseEventService {
  postConstruct() {
    const { globalListener, globalSyncListener } = this.beans;
    if (globalListener) {
      this.addGlobalListener(globalListener, true);
    }
    if (globalSyncListener) {
      this.addGlobalListener(globalSyncListener, false);
    }
  }
};
function getHeaderIndexToFocus(beans, column, level) {
  const columnRowIndex = beans.visibleCols.headerGroupRowCount;
  if (level >= columnRowIndex) {
    return {
      column,
      headerRowIndex: level
    };
  }
  let parent = column.getParent();
  while (parent && parent.getProvidedColumnGroup().getLevel() > level) {
    parent = parent.getParent();
  }
  const isColSpanning = column.isSpanHeaderHeight();
  if (!parent || isColSpanning && parent.isPadding()) {
    return {
      column,
      headerRowIndex: columnRowIndex
    };
  }
  return {
    column: parent,
    headerRowIndex: parent.getProvidedColumnGroup().getLevel()
  };
}
var HeaderNavigationService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "headerNavigation";
    this.currentHeaderRowWithoutSpan = -1;
  }
  postConstruct() {
    const beans = this.beans;
    beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCon = p.gridBodyCtrl;
    });
    const eDocument = _getDocument(beans);
    this.addManagedElementListeners(eDocument, {
      mousedown: () => {
        this.currentHeaderRowWithoutSpan = -1;
      }
    });
  }
  getHeaderPositionForColumn(colKey, floatingFilter) {
    var _a4;
    let column;
    const { colModel, colGroupSvc, ctrlsSvc } = this.beans;
    if (typeof colKey === "string") {
      column = colModel.getCol(colKey);
      if (!column) {
        column = (_a4 = colGroupSvc == null ? void 0 : colGroupSvc.getColumnGroup(colKey)) != null ? _a4 : null;
      }
    } else {
      column = colKey;
    }
    if (!column) {
      return null;
    }
    const centerHeaderContainer = ctrlsSvc.getHeaderRowContainerCtrl();
    const allCtrls = centerHeaderContainer == null ? void 0 : centerHeaderContainer.getAllCtrls();
    const isFloatingFilterVisible = _last(allCtrls || []).type === "filter";
    const headerRowCount = getFocusHeaderRowCount(this.beans) - 1;
    let row = -1;
    let col = column;
    while (col) {
      row++;
      col = col.getParent();
    }
    let headerRowIndex = row;
    if (floatingFilter && isFloatingFilterVisible && headerRowIndex === headerRowCount - 1) {
      headerRowIndex++;
    }
    return headerRowIndex === -1 ? null : {
      headerRowIndex,
      column
    };
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(direction, event) {
    const { focusSvc, visibleCols } = this.beans;
    const { focusedHeader } = focusSvc;
    if (!focusedHeader) {
      return false;
    }
    const { headerRowIndex } = focusedHeader;
    const column = focusedHeader.column;
    const rowLen = getFocusHeaderRowCount(this.beans);
    const currentRowType = this.getHeaderRowType(headerRowIndex);
    const columnHeaderRowIndex = visibleCols.headerGroupRowCount;
    let {
      headerRowIndex: nextRow,
      column: nextFocusColumn,
      headerRowIndexWithoutSpan
    } = direction === "UP" ? getColumnVisibleParent(currentRowType, column, headerRowIndex) : getColumnVisibleChild(column, headerRowIndex, columnHeaderRowIndex);
    let skipColumn = false;
    if (nextRow < 0) {
      nextRow = 0;
      nextFocusColumn = column;
      skipColumn = true;
    }
    if (nextRow >= rowLen) {
      nextRow = -1;
      this.currentHeaderRowWithoutSpan = -1;
    } else if (headerRowIndexWithoutSpan !== void 0) {
      this.currentHeaderRowWithoutSpan = headerRowIndexWithoutSpan;
    }
    if (!skipColumn && !nextFocusColumn) {
      return false;
    }
    return focusSvc.focusHeaderPosition({
      headerPosition: { headerRowIndex: nextRow, column: nextFocusColumn },
      allowUserOverride: true,
      event
    });
  }
  /*
   * This method navigates grid header horizontally
   * @returns {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(direction, fromTab = false, event) {
    const { focusSvc, gos } = this.beans;
    const focusedHeader = { ...focusSvc.focusedHeader };
    let nextHeader;
    let normalisedDirection;
    if (this.currentHeaderRowWithoutSpan !== -1) {
      focusedHeader.headerRowIndex = this.currentHeaderRowWithoutSpan;
    } else {
      this.currentHeaderRowWithoutSpan = focusedHeader.headerRowIndex;
    }
    if (direction === "LEFT" !== gos.get("enableRtl")) {
      normalisedDirection = "Before";
      nextHeader = this.findHeader(focusedHeader, normalisedDirection);
    } else {
      normalisedDirection = "After";
      nextHeader = this.findHeader(focusedHeader, normalisedDirection);
    }
    const userFunc = gos.getCallback("tabToNextHeader");
    if (fromTab && userFunc) {
      const wasFocusedFromUserFunc = focusSvc.focusHeaderPositionFromUserFunc({
        userFunc,
        headerPosition: nextHeader,
        direction: normalisedDirection
      });
      if (wasFocusedFromUserFunc) {
        const { headerRowIndex } = focusSvc.focusedHeader || {};
        if (headerRowIndex != null && headerRowIndex != focusedHeader.headerRowIndex) {
          this.currentHeaderRowWithoutSpan = headerRowIndex;
        }
      }
      return wasFocusedFromUserFunc;
    }
    if (nextHeader || !fromTab) {
      return focusSvc.focusHeaderPosition({
        headerPosition: nextHeader,
        direction: normalisedDirection,
        fromTab,
        allowUserOverride: true,
        event
      });
    }
    return this.focusNextHeaderRow(focusedHeader, normalisedDirection, event);
  }
  focusNextHeaderRow(focusedHeader, direction, event) {
    const beans = this.beans;
    const currentIndex = focusedHeader.headerRowIndex;
    let nextFocusedCol = null;
    let nextRowIndex;
    const headerRowCount = getFocusHeaderRowCount(beans);
    const allVisibleCols = this.beans.visibleCols.allCols;
    if (direction === "Before") {
      if (currentIndex <= 0) {
        return false;
      }
      nextFocusedCol = _last(allVisibleCols);
      nextRowIndex = currentIndex - 1;
      this.currentHeaderRowWithoutSpan -= 1;
    } else {
      nextFocusedCol = allVisibleCols[0];
      nextRowIndex = currentIndex + 1;
      if (this.currentHeaderRowWithoutSpan < headerRowCount) {
        this.currentHeaderRowWithoutSpan += 1;
      } else {
        this.currentHeaderRowWithoutSpan = -1;
      }
    }
    let { column, headerRowIndex } = getHeaderIndexToFocus(this.beans, nextFocusedCol, nextRowIndex);
    if (headerRowIndex >= headerRowCount) {
      headerRowIndex = -1;
    }
    return beans.focusSvc.focusHeaderPosition({
      headerPosition: { column, headerRowIndex },
      direction,
      fromTab: true,
      allowUserOverride: true,
      event
    });
  }
  scrollToColumn(column, direction = "After") {
    if (column.getPinned()) {
      return;
    }
    let columnToScrollTo;
    if (isColumnGroup(column)) {
      const columns = column.getDisplayedLeafColumns();
      columnToScrollTo = direction === "Before" ? _last(columns) : columns[0];
    } else {
      columnToScrollTo = column;
    }
    this.gridBodyCon.scrollFeature.ensureColumnVisible(columnToScrollTo);
  }
  findHeader(focusedHeader, direction) {
    const { colGroupSvc, visibleCols } = this.beans;
    let currentFocusedColumn = focusedHeader.column;
    if (currentFocusedColumn instanceof AgColumnGroup) {
      const leafChildren = currentFocusedColumn.getDisplayedLeafColumns();
      currentFocusedColumn = direction === "Before" ? leafChildren[0] : leafChildren[leafChildren.length - 1];
    }
    const nextFocusedCol = direction === "Before" ? visibleCols.getColBefore(currentFocusedColumn) : visibleCols.getColAfter(currentFocusedColumn);
    if (!nextFocusedCol) {
      return void 0;
    }
    const headerGroupRowIndex = visibleCols.headerGroupRowCount;
    if (focusedHeader.headerRowIndex >= headerGroupRowIndex) {
      return {
        headerRowIndex: focusedHeader.headerRowIndex,
        column: nextFocusedCol
      };
    }
    const groupAtLevel = colGroupSvc == null ? void 0 : colGroupSvc.getColGroupAtLevel(nextFocusedCol, focusedHeader.headerRowIndex);
    if (!groupAtLevel) {
      const isSpanningCol = nextFocusedCol instanceof AgColumn && nextFocusedCol.isSpanHeaderHeight();
      return {
        headerRowIndex: isSpanningCol ? visibleCols.headerGroupRowCount : focusedHeader.headerRowIndex,
        column: nextFocusedCol
      };
    }
    if (groupAtLevel.isPadding() && nextFocusedCol.isSpanHeaderHeight()) {
      return {
        headerRowIndex: visibleCols.headerGroupRowCount,
        column: nextFocusedCol
      };
    }
    return {
      headerRowIndex: focusedHeader.headerRowIndex,
      column: groupAtLevel != null ? groupAtLevel : nextFocusedCol
    };
  }
  getHeaderRowType(rowIndex) {
    const centerHeaderContainer = this.beans.ctrlsSvc.getHeaderRowContainerCtrl();
    if (centerHeaderContainer) {
      return centerHeaderContainer.getRowType(rowIndex);
    }
  }
};
function getColumnVisibleParent(currentRowType, currentColumn, currentIndex) {
  const optimisticNextIndex = currentIndex - 1;
  if (currentRowType !== "filter") {
    const isSpanningCol = currentColumn instanceof AgColumn && currentColumn.isSpanHeaderHeight();
    let nextVisibleParent = currentColumn.getParent();
    while (nextVisibleParent && // skip if row isn't visible or col is padding and spanned
    (nextVisibleParent.getProvidedColumnGroup().getLevel() > optimisticNextIndex || isSpanningCol && nextVisibleParent.isPadding())) {
      nextVisibleParent = nextVisibleParent.getParent();
    }
    if (nextVisibleParent) {
      if (isSpanningCol) {
        return {
          column: nextVisibleParent,
          headerRowIndex: nextVisibleParent.getProvidedColumnGroup().getLevel(),
          headerRowIndexWithoutSpan: optimisticNextIndex
        };
      } else {
        return {
          column: nextVisibleParent,
          headerRowIndex: optimisticNextIndex,
          headerRowIndexWithoutSpan: optimisticNextIndex
        };
      }
    }
  }
  return {
    column: currentColumn,
    headerRowIndex: optimisticNextIndex,
    headerRowIndexWithoutSpan: optimisticNextIndex
  };
}
function getColumnVisibleChild(column, currentIndex, columnHeaderRowIndex) {
  const optimisticNextIndex = currentIndex + 1;
  const result = {
    column,
    headerRowIndex: optimisticNextIndex,
    headerRowIndexWithoutSpan: optimisticNextIndex
  };
  if (column instanceof AgColumnGroup) {
    if (optimisticNextIndex >= columnHeaderRowIndex) {
      return {
        column: column.getDisplayedLeafColumns()[0],
        headerRowIndex: columnHeaderRowIndex,
        headerRowIndexWithoutSpan: optimisticNextIndex
      };
    }
    const children = column.getDisplayedChildren();
    let firstChild = children[0];
    if (firstChild instanceof AgColumnGroup && firstChild.isPadding()) {
      const firstCol = firstChild.getDisplayedLeafColumns()[0];
      if (firstCol.isSpanHeaderHeight()) {
        firstChild = firstCol;
      }
    }
    result.column = firstChild;
    const isSpanningCol = firstChild instanceof AgColumn && firstChild.isSpanHeaderHeight();
    if (isSpanningCol) {
      result.headerRowIndex = columnHeaderRowIndex;
      result.headerRowIndexWithoutSpan = optimisticNextIndex;
    }
  }
  return result;
}
var FocusService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "focusSvc";
    this.focusFallbackTimeout = null;
    this.needsFocusRestored = false;
  }
  wireBeans(beans) {
    this.colModel = beans.colModel;
    this.visibleCols = beans.visibleCols;
    this.rowRenderer = beans.rowRenderer;
    this.navigation = beans.navigation;
    this.filterManager = beans.filterManager;
    this.overlays = beans.overlays;
  }
  postConstruct() {
    const clearFocusedCellListener = this.clearFocusedCell.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: clearFocusedCellListener,
      newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
      columnGroupOpened: clearFocusedCellListener,
      columnRowGroupChanged: clearFocusedCellListener
    });
    this.addDestroyFunc(_registerKeyboardFocusEvents(this.beans));
  }
  attemptToRecoverFocus() {
    this.needsFocusRestored = true;
    if (this.focusFallbackTimeout != null) {
      clearTimeout(this.focusFallbackTimeout);
    }
    this.focusFallbackTimeout = window.setTimeout(this.setFocusRecovered.bind(this), 100);
  }
  setFocusRecovered() {
    this.needsFocusRestored = false;
    if (this.focusFallbackTimeout != null) {
      clearTimeout(this.focusFallbackTimeout);
      this.focusFallbackTimeout = null;
    }
  }
  /**
   * Specifies whether to take focus, as grid either already has focus, or lost it due
   * to a destroyed cell
   * @returns true if the grid should re-take focus, otherwise false
   */
  shouldTakeFocus() {
    if (this.gos.get("suppressFocusAfterRefresh")) {
      this.setFocusRecovered();
      return false;
    }
    if (this.needsFocusRestored) {
      this.setFocusRecovered();
      return true;
    }
    return this.doesRowOrCellHaveBrowserFocus();
  }
  onColumnEverythingChanged() {
    if (!this.focusedCell) {
      return;
    }
    const col = this.focusedCell.column;
    const colFromColumnModel = this.colModel.getCol(col.getId());
    if (col !== colFromColumnModel) {
      this.clearFocusedCell();
    }
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    const { gos, focusedCell } = this;
    if (gos.get("suppressFocusAfterRefresh") || gos.get("suppressCellFocus") || !focusedCell) {
      return null;
    }
    if (!this.doesRowOrCellHaveBrowserFocus()) {
      return null;
    }
    return focusedCell;
  }
  getFocusHeaderToUseAfterRefresh() {
    if (this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeader) {
      return null;
    }
    if (!this.isDomDataPresentInHierarchy(_getActiveDomElement(this.beans), DOM_DATA_KEY_HEADER_CTRL)) {
      return null;
    }
    return this.focusedHeader;
  }
  /**
   * Check for both cells and rows, as a row might be destroyed and the dom data removed before the cell if the
   * row is animating out.
   */
  doesRowOrCellHaveBrowserFocus() {
    const activeElement = _getActiveDomElement(this.beans);
    if (this.isDomDataPresentInHierarchy(activeElement, DOM_DATA_KEY_CELL_CTRL)) {
      return true;
    }
    return this.isDomDataPresentInHierarchy(activeElement, DOM_DATA_KEY_ROW_CTRL);
  }
  isDomDataPresentInHierarchy(eBrowserCell, key) {
    let ePointer = eBrowserCell;
    while (ePointer) {
      const data = _getDomData(this.gos, ePointer, key);
      if (data) {
        return true;
      }
      ePointer = ePointer.parentNode;
    }
    return false;
  }
  getFocusedCell() {
    return this.focusedCell;
  }
  getFocusEventParams(focusedCellPosition) {
    const { rowIndex, rowPinned, column } = focusedCellPosition;
    const params = {
      rowIndex,
      rowPinned,
      column,
      isFullWidthCell: false
    };
    const rowCtrl = this.rowRenderer.getRowByPosition({ rowIndex, rowPinned });
    if (rowCtrl) {
      params.isFullWidthCell = rowCtrl.isFullWidth();
    }
    return params;
  }
  clearFocusedCell() {
    if (this.focusedCell == null) {
      return;
    }
    const focusEventParams = this.getFocusEventParams(this.focusedCell);
    this.focusedCell = null;
    this.eventSvc.dispatchEvent({
      type: "cellFocusCleared",
      ...focusEventParams
    });
  }
  setFocusedCell(params) {
    this.setFocusRecovered();
    const {
      column,
      rowIndex,
      rowPinned,
      forceBrowserFocus = false,
      preventScrollOnBrowserFocus = false,
      sourceEvent
    } = params;
    const gridColumn = this.colModel.getCol(column);
    if (!gridColumn) {
      this.focusedCell = null;
      return;
    }
    this.focusedCell = {
      rowIndex,
      rowPinned: _makeNull(rowPinned),
      column: gridColumn
    };
    const focusEventParams = this.getFocusEventParams(this.focusedCell);
    this.eventSvc.dispatchEvent({
      type: "cellFocused",
      ...focusEventParams,
      ...this.previousCellFocusParams && { previousParams: this.previousCellFocusParams },
      forceBrowserFocus,
      preventScrollOnBrowserFocus,
      sourceEvent
    });
    this.previousCellFocusParams = focusEventParams;
  }
  isCellFocused(cellPosition) {
    if (this.focusedCell == null) {
      return false;
    }
    return _areCellsEqual(cellPosition, this.focusedCell);
  }
  isHeaderWrapperFocused(headerCtrl) {
    if (this.focusedHeader == null) {
      return false;
    }
    const {
      column,
      rowCtrl: { rowIndex: headerRowIndex, pinned }
    } = headerCtrl;
    const { column: focusedColumn, headerRowIndex: focusedHeaderRowIndex } = this.focusedHeader;
    return column === focusedColumn && headerRowIndex === focusedHeaderRowIndex && pinned == focusedColumn.getPinned();
  }
  focusHeaderPosition(params) {
    var _a4;
    this.setFocusRecovered();
    if (_isHeaderFocusSuppressed(this.beans)) {
      return false;
    }
    const { direction, fromTab, allowUserOverride, event, fromCell, rowWithoutSpanValue } = params;
    let { headerPosition } = params;
    if (fromCell && ((_a4 = this.filterManager) == null ? void 0 : _a4.isAdvFilterHeaderActive())) {
      return this.focusAdvancedFilter(headerPosition);
    }
    if (allowUserOverride) {
      const currentPosition = this.focusedHeader;
      const headerRowCount = getFocusHeaderRowCount(this.beans);
      if (fromTab) {
        const userFunc = this.gos.getCallback("tabToNextHeader");
        if (userFunc) {
          headerPosition = this.getHeaderPositionFromUserFunc({
            userFunc,
            direction,
            currentPosition,
            headerPosition,
            headerRowCount
          });
        }
      } else {
        const userFunc = this.gos.getCallback("navigateToNextHeader");
        if (userFunc && event) {
          const params2 = {
            key: event.key,
            previousHeaderPosition: currentPosition,
            nextHeaderPosition: headerPosition,
            headerRowCount,
            event
          };
          headerPosition = userFunc(params2);
        }
      }
    }
    if (!headerPosition) {
      return false;
    }
    return this.focusProvidedHeaderPosition({
      headerPosition,
      direction,
      event,
      fromCell,
      rowWithoutSpanValue
    });
  }
  focusHeaderPositionFromUserFunc(params) {
    if (_isHeaderFocusSuppressed(this.beans)) {
      return false;
    }
    const { userFunc, headerPosition, direction, event } = params;
    const currentPosition = this.focusedHeader;
    const headerRowCount = getFocusHeaderRowCount(this.beans);
    const newHeaderPosition = this.getHeaderPositionFromUserFunc({
      userFunc,
      direction,
      currentPosition,
      headerPosition,
      headerRowCount
    });
    return !!newHeaderPosition && this.focusProvidedHeaderPosition({
      headerPosition: newHeaderPosition,
      direction,
      event
    });
  }
  getHeaderPositionFromUserFunc(params) {
    const { userFunc, direction, currentPosition, headerPosition, headerRowCount } = params;
    const userFuncParams = {
      backwards: direction === "Before",
      previousHeaderPosition: currentPosition,
      nextHeaderPosition: headerPosition,
      headerRowCount
    };
    const userResult = userFunc(userFuncParams);
    if (userResult === true) {
      return currentPosition;
    }
    if (userResult === false) {
      return null;
    }
    return userResult;
  }
  focusProvidedHeaderPosition(params) {
    const { headerPosition, direction, fromCell, rowWithoutSpanValue, event } = params;
    const { column, headerRowIndex } = headerPosition;
    const { filterManager, ctrlsSvc, headerNavigation } = this.beans;
    if (headerRowIndex === -1) {
      if (filterManager == null ? void 0 : filterManager.isAdvFilterHeaderActive()) {
        return this.focusAdvancedFilter(headerPosition);
      }
      return this.focusGridView({ column, event });
    }
    headerNavigation == null ? void 0 : headerNavigation.scrollToColumn(column, direction);
    const headerRowContainerCtrl = ctrlsSvc.getHeaderRowContainerCtrl(column.getPinned());
    const focusSuccess = (headerRowContainerCtrl == null ? void 0 : headerRowContainerCtrl.focusHeader(headerPosition.headerRowIndex, column, event)) || false;
    if (headerNavigation && focusSuccess && (rowWithoutSpanValue != null || fromCell)) {
      headerNavigation.currentHeaderRowWithoutSpan = rowWithoutSpanValue != null ? rowWithoutSpanValue : -1;
    }
    return focusSuccess;
  }
  focusFirstHeader() {
    var _a4;
    if (((_a4 = this.overlays) == null ? void 0 : _a4.isExclusive()) && this.focusOverlay()) {
      return true;
    }
    const firstColumn = this.visibleCols.allCols[0];
    if (!firstColumn) {
      return false;
    }
    const headerPosition = getHeaderIndexToFocus(this.beans, firstColumn, 0);
    return this.focusHeaderPosition({
      headerPosition,
      rowWithoutSpanValue: 0
    });
  }
  focusLastHeader(event) {
    var _a4;
    if (((_a4 = this.overlays) == null ? void 0 : _a4.isExclusive()) && this.focusOverlay(true)) {
      return true;
    }
    const headerRowIndex = getFocusHeaderRowCount(this.beans) - 1;
    const column = _last(this.visibleCols.allCols);
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex, column },
      rowWithoutSpanValue: -1,
      event
    });
  }
  focusPreviousFromFirstCell(event) {
    var _a4;
    if ((_a4 = this.filterManager) == null ? void 0 : _a4.isAdvFilterHeaderActive()) {
      return this.focusAdvancedFilter(null);
    }
    return this.focusLastHeader(event);
  }
  isAnyCellFocused() {
    return !!this.focusedCell;
  }
  isRowFocused(rowIndex, rowPinnedType) {
    if (this.focusedCell == null) {
      return false;
    }
    return this.focusedCell.rowIndex === rowIndex && this.focusedCell.rowPinned === _makeNull(rowPinnedType);
  }
  focusOverlay(backwards) {
    var _a4, _b2;
    const overlayGui = ((_a4 = this.overlays) == null ? void 0 : _a4.isVisible()) && ((_b2 = this.overlays.eWrapper) == null ? void 0 : _b2.getGui());
    return !!overlayGui && _focusInto(overlayGui, backwards);
  }
  focusGridView(params) {
    var _a4, _b2, _c, _d, _e, _f, _g;
    const { backwards = false, canFocusOverlay = true, event } = params;
    if ((_a4 = this.overlays) == null ? void 0 : _a4.isExclusive()) {
      return canFocusOverlay && this.focusOverlay(backwards);
    }
    if (_isCellFocusSuppressed(this.beans)) {
      if (backwards) {
        if (!_isHeaderFocusSuppressed(this.beans)) {
          return this.focusLastHeader();
        }
      }
      if (canFocusOverlay && this.focusOverlay(backwards)) {
        return true;
      }
      if (backwards) {
        return false;
      }
      return _focusNextGridCoreContainer(this.beans, backwards);
    }
    const nextRow = backwards ? _getLastRow(this.beans) : _getFirstRow(this.beans);
    if (nextRow) {
      const column = (_c = params.column) != null ? _c : (_b2 = this.focusedHeader) == null ? void 0 : _b2.column;
      const { rowIndex, rowPinned } = nextRow;
      const rowNode = _getRowNode(this.beans, nextRow);
      if (!column || !rowNode || rowIndex == null) {
        return false;
      }
      if (column.isSuppressNavigable(rowNode)) {
        const isRtl = this.gos.get("enableRtl");
        let key;
        if (!event || event.key === KeyCode.TAB) {
          key = isRtl ? KeyCode.LEFT : KeyCode.RIGHT;
        } else {
          key = event.key;
        }
        (_d = this.beans.navigation) == null ? void 0 : _d.navigateToNextCell(
          null,
          key,
          { rowIndex, column, rowPinned: rowPinned || null },
          true
        );
        return true;
      }
      (_e = this.navigation) == null ? void 0 : _e.ensureCellVisible({ rowIndex, column, rowPinned });
      if (backwards) {
        const rowCtrl = this.rowRenderer.getRowByPosition(nextRow);
        if ((rowCtrl == null ? void 0 : rowCtrl.isFullWidth()) && ((_f = this.navigation) == null ? void 0 : _f.tryToFocusFullWidthRow(nextRow, backwards))) {
          return true;
        }
      }
      this.setFocusedCell({
        rowIndex,
        column,
        rowPinned: _makeNull(rowPinned),
        forceBrowserFocus: true
      });
      (_g = this.beans.rangeSvc) == null ? void 0 : _g.setRangeToCell({ rowIndex, rowPinned, column });
      return true;
    }
    if (canFocusOverlay && this.focusOverlay(backwards)) {
      return true;
    }
    if (backwards && this.focusLastHeader()) {
      return true;
    }
    return false;
  }
  focusAdvancedFilter(position) {
    var _a4, _b2;
    this.advFilterFocusColumn = position == null ? void 0 : position.column;
    return (_b2 = (_a4 = this.beans.advancedFilter) == null ? void 0 : _a4.getCtrl().focusHeaderComp()) != null ? _b2 : false;
  }
  focusNextFromAdvancedFilter(backwards, forceFirstColumn) {
    var _a4, _b2;
    const column = (_b2 = forceFirstColumn ? void 0 : this.advFilterFocusColumn) != null ? _b2 : (_a4 = this.visibleCols.allCols) == null ? void 0 : _a4[0];
    if (backwards) {
      return this.focusHeaderPosition({
        headerPosition: {
          column,
          headerRowIndex: getFocusHeaderRowCount(this.beans) - 1
        }
      });
    } else {
      return this.focusGridView({ column });
    }
  }
  clearAdvancedFilterColumn() {
    this.advFilterFocusColumn = void 0;
  }
};
var ScrollVisibleService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "scrollVisibleSvc";
  }
  wireBeans(beans) {
    this.ctrlsSvc = beans.ctrlsSvc;
    this.colAnimation = beans.colAnimation;
  }
  postConstruct() {
    this.horizontalScrollShowing = this.gos.get("alwaysShowHorizontalScroll") === true;
    this.verticalScrollShowing = this.gos.get("alwaysShowVerticalScroll") === true;
    this.getScrollbarWidth();
    this.addManagedEventListeners({
      displayedColumnsChanged: this.updateScrollVisible.bind(this),
      displayedColumnsWidthChanged: this.updateScrollVisible.bind(this)
    });
  }
  updateScrollVisible() {
    const { colAnimation } = this;
    if (colAnimation == null ? void 0 : colAnimation.isActive()) {
      colAnimation.executeLaterVMTurn(() => {
        colAnimation.executeLaterVMTurn(() => this.updateScrollVisibleImpl());
      });
    } else {
      this.updateScrollVisibleImpl();
    }
  }
  updateScrollVisibleImpl() {
    var _a4;
    const centerRowCtrl = this.ctrlsSvc.get("center");
    if (!centerRowCtrl || ((_a4 = this.colAnimation) == null ? void 0 : _a4.isActive())) {
      return;
    }
    const params = {
      horizontalScrollShowing: centerRowCtrl.isHorizontalScrollShowing(),
      verticalScrollShowing: this.verticalScrollShowing
    };
    this.setScrollsVisible(params);
    this.updateScrollGap();
  }
  updateScrollGap() {
    const centerRowCtrl = this.ctrlsSvc.get("center");
    const horizontalGap = centerRowCtrl.hasHorizontalScrollGap();
    const verticalGap = centerRowCtrl.hasVerticalScrollGap();
    const atLeastOneDifferent = this.horizontalScrollGap !== horizontalGap || this.verticalScrollGap !== verticalGap;
    if (atLeastOneDifferent) {
      this.horizontalScrollGap = horizontalGap;
      this.verticalScrollGap = verticalGap;
      this.eventSvc.dispatchEvent({
        type: "scrollGapChanged"
      });
    }
  }
  setScrollsVisible(params) {
    const atLeastOneDifferent = this.horizontalScrollShowing !== params.horizontalScrollShowing || this.verticalScrollShowing !== params.verticalScrollShowing;
    if (atLeastOneDifferent) {
      this.horizontalScrollShowing = params.horizontalScrollShowing;
      this.verticalScrollShowing = params.verticalScrollShowing;
      this.eventSvc.dispatchEvent({
        type: "scrollVisibilityChanged"
      });
    }
  }
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const gridOptionsScrollbarWidth = this.gos.get("scrollbarWidth");
      const useGridOptions = typeof gridOptionsScrollbarWidth === "number" && gridOptionsScrollbarWidth >= 0;
      const scrollbarWidth = useGridOptions ? gridOptionsScrollbarWidth : _getScrollbarWidth();
      if (scrollbarWidth != null) {
        this.scrollbarWidth = scrollbarWidth;
        this.eventSvc.dispatchEvent({
          type: "scrollbarWidthChanged"
        });
      }
    }
    return this.scrollbarWidth;
  }
};
var GridDestroyService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "gridDestroySvc";
    this.destroyCalled = false;
  }
  destroy() {
    var _a4, _b2;
    if (this.destroyCalled) {
      return;
    }
    const { stateSvc, ctrlsSvc, context } = this.beans;
    this.eventSvc.dispatchEvent({
      type: "gridPreDestroyed",
      state: (_a4 = stateSvc == null ? void 0 : stateSvc.getState()) != null ? _a4 : {}
    });
    this.destroyCalled = true;
    (_b2 = ctrlsSvc.get("gridCtrl")) == null ? void 0 : _b2.destroyGridUi();
    context.destroy();
    super.destroy();
  }
};
var ALWAYS_SYNC_GLOBAL_EVENTS = /* @__PURE__ */ new Set(["gridPreDestroyed", "fillStart", "pasteStart"]);
var _PUBLIC_EVENTS = [
  "columnEverythingChanged",
  "newColumnsLoaded",
  "columnPivotModeChanged",
  "pivotMaxColumnsExceeded",
  "columnRowGroupChanged",
  "expandOrCollapseAll",
  "columnPivotChanged",
  "gridColumnsChanged",
  "columnValueChanged",
  "columnMoved",
  "columnVisible",
  "columnPinned",
  "columnGroupOpened",
  "columnResized",
  "displayedColumnsChanged",
  "virtualColumnsChanged",
  "columnHeaderMouseOver",
  "columnHeaderMouseLeave",
  "columnHeaderClicked",
  "columnHeaderContextMenu",
  "asyncTransactionsFlushed",
  "rowGroupOpened",
  "rowDataUpdated",
  "pinnedRowDataChanged",
  "pinnedRowsChanged",
  "rangeSelectionChanged",
  "cellSelectionChanged",
  "chartCreated",
  "chartRangeSelectionChanged",
  "chartOptionsChanged",
  "chartDestroyed",
  "toolPanelVisibleChanged",
  "toolPanelSizeChanged",
  "modelUpdated",
  "cutStart",
  "cutEnd",
  "pasteStart",
  "pasteEnd",
  "fillStart",
  "fillEnd",
  "cellSelectionDeleteStart",
  "cellSelectionDeleteEnd",
  "rangeDeleteStart",
  "rangeDeleteEnd",
  "undoStarted",
  "undoEnded",
  "redoStarted",
  "redoEnded",
  "cellClicked",
  "cellDoubleClicked",
  "cellMouseDown",
  "cellContextMenu",
  "cellValueChanged",
  "cellEditRequest",
  "rowValueChanged",
  "headerFocused",
  "cellFocused",
  "rowSelected",
  "selectionChanged",
  "tooltipShow",
  "tooltipHide",
  "cellKeyDown",
  "cellMouseOver",
  "cellMouseOut",
  "filterChanged",
  "filterModified",
  "filterUiChanged",
  "filterOpened",
  "floatingFilterUiChanged",
  "advancedFilterBuilderVisibleChanged",
  "sortChanged",
  "virtualRowRemoved",
  "rowClicked",
  "rowDoubleClicked",
  "gridReady",
  "gridPreDestroyed",
  "gridSizeChanged",
  "viewportChanged",
  "firstDataRendered",
  "dragStarted",
  "dragStopped",
  "dragCancelled",
  "rowEditingStarted",
  "rowEditingStopped",
  "cellEditingStarted",
  "cellEditingStopped",
  "bodyScroll",
  "bodyScrollEnd",
  "paginationChanged",
  "componentStateChanged",
  "storeRefreshed",
  "stateUpdated",
  "columnMenuVisibleChanged",
  "contextMenuVisibleChanged",
  "rowDragEnter",
  "rowDragMove",
  "rowDragLeave",
  "rowDragEnd",
  "rowDragCancel",
  "findChanged",
  "rowResizeStarted",
  "rowResizeEnded",
  "columnsReset",
  "bulkEditingStarted",
  "bulkEditingStopped",
  "batchEditingStarted",
  "batchEditingStopped"
];
var _PUBLIC_EVENT_HANDLERS_MAP = _PUBLIC_EVENTS.reduce(
  (mem, ev) => {
    mem[ev] = _getCallbackForEvent(ev);
    return mem;
  },
  {}
);
var makeIconParams = (dataRefSuffix, classSuffix) => ({
  tag: "span",
  ref: `eSort${dataRefSuffix}`,
  cls: `ag-sort-indicator-icon ag-sort-${classSuffix} ag-hidden`,
  attrs: { "aria-hidden": "true" }
});
var SortIndicatorElement = {
  tag: "span",
  cls: "ag-sort-indicator-container",
  children: [
    makeIconParams("Order", "order"),
    makeIconParams("Asc", "ascending-icon"),
    makeIconParams("Desc", "descending-icon"),
    makeIconParams("Mixed", "mixed-icon"),
    makeIconParams("None", "none-icon")
  ]
};
var SortIndicatorComp = class extends Component {
  constructor(skipTemplate) {
    super();
    this.eSortOrder = RefPlaceholder;
    this.eSortAsc = RefPlaceholder;
    this.eSortDesc = RefPlaceholder;
    this.eSortMixed = RefPlaceholder;
    this.eSortNone = RefPlaceholder;
    if (!skipTemplate) {
      this.setTemplate(SortIndicatorElement);
    }
  }
  attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone) {
    this.eSortOrder = eSortOrder;
    this.eSortAsc = eSortAsc;
    this.eSortDesc = eSortDesc;
    this.eSortMixed = eSortMixed;
    this.eSortNone = eSortNone;
  }
  setupSort(column, suppressOrder = false) {
    this.column = column;
    this.suppressOrder = suppressOrder;
    this.setupMultiSortIndicator();
    if (!column.isSortable() && !column.getColDef().showRowGroup) {
      return;
    }
    this.addInIcon("sortAscending", this.eSortAsc, column);
    this.addInIcon("sortDescending", this.eSortDesc, column);
    this.addInIcon("sortUnSort", this.eSortNone, column);
    const updateIcons = this.updateIcons.bind(this);
    const sortUpdated = this.onSortChanged.bind(this);
    this.addManagedPropertyListener("unSortIcon", updateIcons);
    this.addManagedEventListeners({
      newColumnsLoaded: updateIcons,
      // Watch global events, as row group columns can effect their display column.
      sortChanged: sortUpdated,
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: sortUpdated
    });
    this.onSortChanged();
  }
  addInIcon(iconName, eParent, column) {
    if (eParent == null) {
      return;
    }
    const eIcon = _createIconNoSpan(iconName, this.beans, column);
    if (eIcon) {
      eParent.appendChild(eIcon);
    }
  }
  onSortChanged() {
    this.updateIcons();
    if (!this.suppressOrder) {
      this.updateSortOrder();
    }
  }
  updateIcons() {
    const { eSortAsc, eSortDesc, eSortNone, column, gos, beans } = this;
    const sortDirection = beans.sortSvc.getDisplaySortForColumn(column);
    if (eSortAsc) {
      const isAscending = sortDirection === "asc";
      _setDisplayed(eSortAsc, isAscending, { skipAriaHidden: true });
    }
    if (eSortDesc) {
      const isDescending = sortDirection === "desc";
      _setDisplayed(eSortDesc, isDescending, { skipAriaHidden: true });
    }
    if (eSortNone) {
      const alwaysHideNoSort = !column.getColDef().unSortIcon && !gos.get("unSortIcon");
      const isNone = sortDirection === null || sortDirection === void 0;
      _setDisplayed(eSortNone, !alwaysHideNoSort && isNone, { skipAriaHidden: true });
    }
  }
  setupMultiSortIndicator() {
    const { eSortMixed, column, gos } = this;
    this.addInIcon("sortUnSort", eSortMixed, column);
    const isColumnShowingRowGroup = column.getColDef().showRowGroup;
    const areGroupsCoupled = _isColumnsSortingCoupledToGroup(gos);
    if (areGroupsCoupled && isColumnShowingRowGroup) {
      this.addManagedEventListeners({
        // Watch global events, as row group columns can effect their display column.
        sortChanged: this.updateMultiSortIndicator.bind(this),
        // when grouping changes so can sort indexes and icons
        columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
      });
      this.updateMultiSortIndicator();
    }
  }
  updateMultiSortIndicator() {
    const { eSortMixed, beans, column } = this;
    if (eSortMixed) {
      const isMixedSort = beans.sortSvc.getDisplaySortForColumn(column) === "mixed";
      _setDisplayed(eSortMixed, isMixedSort, { skipAriaHidden: true });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    var _a4;
    const {
      eSortOrder,
      column,
      beans: { sortSvc }
    } = this;
    if (!eSortOrder) {
      return;
    }
    const allColumnsWithSorting = sortSvc.getColumnsWithSortingOrdered();
    const indexThisCol = (_a4 = sortSvc.getDisplaySortIndexForColumn(column)) != null ? _a4 : -1;
    const moreThanOneColSorting = allColumnsWithSorting.some(
      (col) => {
        var _a5;
        return (_a5 = sortSvc.getDisplaySortIndexForColumn(col)) != null ? _a5 : -1 >= 1;
      }
    );
    const showIndex = indexThisCol >= 0 && moreThanOneColSorting;
    _setDisplayed(eSortOrder, showIndex, { skipAriaHidden: true });
    if (indexThisCol >= 0) {
      eSortOrder.textContent = (indexThisCol + 1).toString();
    } else {
      _clearElement(eSortOrder);
    }
  }
};
var SortIndicatorSelector = {
  selector: "AG-SORT-INDICATOR",
  component: SortIndicatorComp
};
var DEFAULT_SORTING_ORDER = ["asc", "desc", null];
var SortService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "sortSvc";
  }
  progressSort(column, multiSort, source) {
    const nextDirection = this.getNextSortDirection(column);
    this.setSortForColumn(column, nextDirection, multiSort, source);
  }
  progressSortFromEvent(column, event) {
    const sortUsingCtrl = this.gos.get("multiSortKey") === "ctrl";
    const multiSort = sortUsingCtrl ? event.ctrlKey || event.metaKey : event.shiftKey;
    this.progressSort(column, multiSort, "uiColumnSorted");
  }
  setSortForColumn(column, sort, multiSort, source) {
    var _a4;
    if (sort !== "asc" && sort !== "desc") {
      sort = null;
    }
    const { gos, showRowGroupCols } = this.beans;
    const isColumnsSortingCoupledToGroup = _isColumnsSortingCoupledToGroup(gos);
    let columnsToUpdate = [column];
    if (isColumnsSortingCoupledToGroup) {
      if (column.getColDef().showRowGroup) {
        const rowGroupColumns = (_a4 = showRowGroupCols == null ? void 0 : showRowGroupCols.getSourceColumnsForGroupColumn) == null ? void 0 : _a4.call(showRowGroupCols, column);
        const sortableRowGroupColumns = rowGroupColumns == null ? void 0 : rowGroupColumns.filter((col) => col.isSortable());
        if (sortableRowGroupColumns) {
          columnsToUpdate = [column, ...sortableRowGroupColumns];
        }
      }
    }
    columnsToUpdate.forEach((col) => this.setColSort(col, sort, source));
    const doingMultiSort = (multiSort || gos.get("alwaysMultiSort")) && !gos.get("suppressMultiSort");
    const updatedColumns = [];
    if (!doingMultiSort) {
      const clearedColumns = this.clearSortBarTheseColumns(columnsToUpdate, source);
      updatedColumns.push(...clearedColumns);
    }
    this.updateSortIndex(column);
    updatedColumns.push(...columnsToUpdate);
    this.dispatchSortChangedEvents(source, updatedColumns);
  }
  updateSortIndex(lastColToChange) {
    const { gos, colModel, showRowGroupCols } = this.beans;
    const isCoupled = _isColumnsSortingCoupledToGroup(gos);
    const groupParent = showRowGroupCols == null ? void 0 : showRowGroupCols.getShowRowGroupCol(lastColToChange.getId());
    const lastSortIndexCol = isCoupled ? groupParent || lastColToChange : lastColToChange;
    const allSortedCols = this.getColumnsWithSortingOrdered();
    colModel.forAllCols((col) => this.setColSortIndex(col, null));
    const allSortedColsWithoutChangesOrGroups = allSortedCols.filter((col) => {
      if (isCoupled && col.getColDef().showRowGroup) {
        return false;
      }
      return col !== lastSortIndexCol;
    });
    const sortedColsWithIndices = lastSortIndexCol.getSort() ? [...allSortedColsWithoutChangesOrGroups, lastSortIndexCol] : allSortedColsWithoutChangesOrGroups;
    sortedColsWithIndices.forEach((col, idx) => this.setColSortIndex(col, idx));
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(source, columns) {
    this.dispatchSortChangedEvents(source, columns);
  }
  isSortActive() {
    let isSorting = false;
    this.beans.colModel.forAllCols((col) => {
      if (col.getSort()) {
        isSorting = true;
      }
    });
    return isSorting;
  }
  dispatchSortChangedEvents(source, columns) {
    const event = {
      type: "sortChanged",
      source
    };
    if (columns) {
      event.columns = columns;
    }
    this.eventSvc.dispatchEvent(event);
  }
  clearSortBarTheseColumns(columnsToSkip, source) {
    const clearedColumns = [];
    this.beans.colModel.forAllCols((columnToClear) => {
      if (!columnsToSkip.includes(columnToClear)) {
        if (columnToClear.getSort()) {
          clearedColumns.push(columnToClear);
        }
        this.setColSort(columnToClear, void 0, source);
      }
    });
    return clearedColumns;
  }
  getNextSortDirection(column) {
    var _a4, _b2;
    const sortingOrder = (_b2 = (_a4 = column.getColDef().sortingOrder) != null ? _a4 : this.gos.get("sortingOrder")) != null ? _b2 : DEFAULT_SORTING_ORDER;
    const currentIndex = sortingOrder.indexOf(column.getSort());
    const notInArray = currentIndex < 0;
    const lastItemInArray = currentIndex == sortingOrder.length - 1;
    return notInArray || lastItemInArray ? sortingOrder[0] : sortingOrder[currentIndex + 1];
  }
  /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    var _a4;
    const { gos, colModel, showRowGroupCols, rowGroupColsSvc } = this.beans;
    let allSortedCols = [];
    colModel.forAllCols((col) => {
      if (col.getSort()) {
        allSortedCols.push(col);
      }
    });
    if (colModel.isPivotMode()) {
      const isSortingLinked = _isColumnsSortingCoupledToGroup(gos);
      allSortedCols = allSortedCols.filter((col) => {
        const isAggregated = !!col.getAggFunc();
        const isSecondary = !col.isPrimary();
        const isGroup = isSortingLinked ? showRowGroupCols == null ? void 0 : showRowGroupCols.getShowRowGroupCol(col.getId()) : col.getColDef().showRowGroup;
        return isAggregated || isSecondary || isGroup;
      });
    }
    const sortedRowGroupCols = (_a4 = rowGroupColsSvc == null ? void 0 : rowGroupColsSvc.columns.filter((col) => !!col.getSort())) != null ? _a4 : [];
    const allColsIndexes = {};
    allSortedCols.forEach((col, index) => allColsIndexes[col.getId()] = index);
    allSortedCols.sort((a, b) => {
      const iA = a.getSortIndex();
      const iB = b.getSortIndex();
      if (iA != null && iB != null) {
        return iA - iB;
      } else if (iA == null && iB == null) {
        const posA = allColsIndexes[a.getId()];
        const posB = allColsIndexes[b.getId()];
        return posA > posB ? 1 : -1;
      } else if (iB == null) {
        return -1;
      } else {
        return 1;
      }
    });
    const isSortLinked = _isColumnsSortingCoupledToGroup(gos) && !!sortedRowGroupCols.length;
    if (isSortLinked) {
      allSortedCols = [
        ...new Set(
          // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
          allSortedCols.map((col) => {
            var _a5;
            return (_a5 = showRowGroupCols == null ? void 0 : showRowGroupCols.getShowRowGroupCol(col.getId())) != null ? _a5 : col;
          })
        )
      ];
    }
    const indexMap = /* @__PURE__ */ new Map();
    allSortedCols.forEach((col, idx) => indexMap.set(col, idx));
    if (isSortLinked) {
      sortedRowGroupCols.forEach((col) => {
        const groupDisplayCol = showRowGroupCols.getShowRowGroupCol(col.getId());
        indexMap.set(col, indexMap.get(groupDisplayCol));
      });
    }
    return indexMap;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([, idx1], [, idx2]) => idx1 - idx2).map(([col]) => col);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((column) => column.getSort()).map((column) => ({
      sort: column.getSort(),
      colId: column.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((column) => column.getSort()).map((column) => ({
      sort: column.getSort(),
      column
    }));
  }
  canColumnDisplayMixedSort(column) {
    const isColumnSortCouplingActive = _isColumnsSortingCoupledToGroup(this.gos);
    const isGroupDisplayColumn = !!column.getColDef().showRowGroup;
    return isColumnSortCouplingActive && isGroupDisplayColumn;
  }
  getDisplaySortForColumn(column) {
    var _a4;
    const linkedColumns = (_a4 = this.beans.showRowGroupCols) == null ? void 0 : _a4.getSourceColumnsForGroupColumn(column);
    if (!this.canColumnDisplayMixedSort(column) || !(linkedColumns == null ? void 0 : linkedColumns.length)) {
      return column.getSort();
    }
    const columnHasUniqueData = column.getColDef().field != null || !!column.getColDef().valueGetter;
    const sortableColumns = columnHasUniqueData ? [column, ...linkedColumns] : linkedColumns;
    const firstSort = sortableColumns[0].getSort();
    const allMatch = sortableColumns.every((col) => col.getSort() == firstSort);
    if (!allMatch) {
      return "mixed";
    }
    return firstSort;
  }
  getDisplaySortIndexForColumn(column) {
    return this.getIndexedSortMap().get(column);
  }
  setupHeader(comp, column, clickElement) {
    let lastMovingChanged = 0;
    comp.addManagedListeners(column, {
      movingChanged: () => {
        lastMovingChanged = Date.now();
      }
    });
    if (clickElement) {
      comp.addManagedElementListeners(clickElement, {
        click: (event) => {
          const moving = column.isMoving();
          const nowTime = Date.now();
          const movedRecently = nowTime - lastMovingChanged < 50;
          const columnMoving = moving || movedRecently;
          if (!columnMoving) {
            this.progressSortFromEvent(column, event);
          }
        }
      });
    }
    const onSortingChanged = () => {
      var _a4;
      const sort = column.getSort();
      comp.toggleCss("ag-header-cell-sorted-asc", sort === "asc");
      comp.toggleCss("ag-header-cell-sorted-desc", sort === "desc");
      comp.toggleCss("ag-header-cell-sorted-none", !sort);
      if (column.getColDef().showRowGroup) {
        const sourceColumns = (_a4 = this.beans.showRowGroupCols) == null ? void 0 : _a4.getSourceColumnsForGroupColumn(column);
        const sortDirectionsMatch = sourceColumns == null ? void 0 : sourceColumns.every(
          (sourceCol) => column.getSort() == sourceCol.getSort()
        );
        const isMultiSorting = !sortDirectionsMatch;
        comp.toggleCss("ag-header-cell-sorted-mixed", isMultiSorting);
      }
    };
    comp.addManagedEventListeners({
      sortChanged: onSortingChanged,
      columnRowGroupChanged: onSortingChanged
    });
  }
  initCol(column) {
    const { sort, initialSort, sortIndex, initialSortIndex } = column.colDef;
    if (sort !== void 0) {
      if (sort === "asc" || sort === "desc") {
        column.sort = sort;
      }
    } else {
      if (initialSort === "asc" || initialSort === "desc") {
        column.sort = initialSort;
      }
    }
    if (sortIndex !== void 0) {
      if (sortIndex !== null) {
        column.sortIndex = sortIndex;
      }
    } else {
      if (initialSortIndex !== null) {
        column.sortIndex = initialSortIndex;
      }
    }
  }
  updateColSort(column, sort, source) {
    if (sort !== void 0) {
      if (sort === "desc" || sort === "asc") {
        this.setColSort(column, sort, source);
      } else {
        this.setColSort(column, void 0, source);
      }
    }
  }
  setColSort(column, sort, source) {
    if (column.sort !== sort) {
      column.sort = sort;
      column.dispatchColEvent("sortChanged", source);
    }
    column.dispatchStateUpdatedEvent("sort");
  }
  setColSortIndex(column, sortOrder) {
    column.sortIndex = sortOrder;
    column.dispatchStateUpdatedEvent("sortIndex");
  }
  createSortIndicator(skipTemplate) {
    return new SortIndicatorComp(skipTemplate);
  }
  getSortIndicatorSelector() {
    return SortIndicatorSelector;
  }
};
var USER_COMP_MODULES = {
  agSetColumnFilter: "SetFilter",
  agSetColumnFloatingFilter: "SetFilter",
  agMultiColumnFilter: "MultiFilter",
  agMultiColumnFloatingFilter: "MultiFilter",
  agGroupColumnFilter: "GroupFilter",
  agGroupColumnFloatingFilter: "GroupFilter",
  agGroupCellRenderer: "GroupCellRenderer",
  agGroupRowRenderer: "GroupCellRenderer",
  agRichSelect: "RichSelect",
  agRichSelectCellEditor: "RichSelect",
  agDetailCellRenderer: "SharedMasterDetail",
  agSparklineCellRenderer: "Sparklines",
  agDragAndDropImage: "SharedDragAndDrop",
  agColumnHeader: "ColumnHeaderComp",
  agColumnGroupHeader: "ColumnGroupHeaderComp",
  agSortIndicator: "Sort",
  agAnimateShowChangeCellRenderer: "HighlightChanges",
  agAnimateSlideCellRenderer: "HighlightChanges",
  agLoadingCellRenderer: "LoadingCellRenderer",
  agSkeletonCellRenderer: "SkeletonCellRenderer",
  agCheckboxCellRenderer: "CheckboxCellRenderer",
  agLoadingOverlay: "Overlay",
  agNoRowsOverlay: "Overlay",
  agTooltipComponent: "Tooltip",
  agReadOnlyFloatingFilter: "CustomFilter",
  agTextColumnFilter: "TextFilter",
  agNumberColumnFilter: "NumberFilter",
  agDateColumnFilter: "DateFilter",
  agDateInput: "DateFilter",
  agTextColumnFloatingFilter: "TextFilter",
  agNumberColumnFloatingFilter: "NumberFilter",
  agDateColumnFloatingFilter: "DateFilter",
  agCellEditor: "TextEditor",
  agSelectCellEditor: "SelectEditor",
  agTextCellEditor: "TextEditor",
  agNumberCellEditor: "NumberEditor",
  agDateCellEditor: "DateEditor",
  agDateStringCellEditor: "DateEditor",
  agCheckboxCellEditor: "CheckboxEditor",
  agLargeTextCellEditor: "LargeTextEditor",
  agMenuItem: "MenuItem",
  agColumnsToolPanel: "ColumnsToolPanel",
  agFiltersToolPanel: "FiltersToolPanel",
  agNewFiltersToolPanel: "NewFiltersToolPanel",
  agAggregationComponent: "StatusBar",
  agSelectedRowCountComponent: "StatusBar",
  agTotalRowCountComponent: "StatusBar",
  agFilteredRowCountComponent: "StatusBar",
  agTotalAndFilteredRowCountComponent: "StatusBar",
  agFindCellRenderer: "Find"
};
var COLUMN_DEFINITION_MOD_VALIDATIONS = {
  aggFunc: "SharedAggregation",
  autoHeight: "RowAutoHeight",
  cellClass: "CellStyle",
  cellClassRules: "CellStyle",
  cellEditor: ({ cellEditor, editable }) => {
    var _a4;
    if (!editable) {
      return null;
    }
    if (typeof cellEditor === "string") {
      return (_a4 = USER_COMP_MODULES[cellEditor]) != null ? _a4 : "CustomEditor";
    }
    return "CustomEditor";
  },
  cellRenderer: ({ cellRenderer }) => {
    if (typeof cellRenderer !== "string") {
      return null;
    }
    return USER_COMP_MODULES[cellRenderer];
  },
  cellStyle: "CellStyle",
  columnChooserParams: "ColumnMenu",
  contextMenuItems: "ContextMenu",
  dndSource: "DragAndDrop",
  dndSourceOnRowDrag: "DragAndDrop",
  editable: ({ editable, cellEditor }) => {
    if (editable && !cellEditor) {
      return "TextEditor";
    }
    return null;
  },
  enableCellChangeFlash: "HighlightChanges",
  enablePivot: "SharedPivot",
  enableRowGroup: "SharedRowGrouping",
  enableValue: "SharedAggregation",
  filter: ({ filter }) => {
    var _a4;
    if (filter && typeof filter !== "string" && typeof filter !== "boolean") {
      return "CustomFilter";
    }
    if (typeof filter === "string") {
      return (_a4 = USER_COMP_MODULES[filter]) != null ? _a4 : "ColumnFilter";
    }
    return "ColumnFilter";
  },
  floatingFilter: "ColumnFilter",
  getQuickFilterText: "QuickFilter",
  headerTooltip: "Tooltip",
  mainMenuItems: "ColumnMenu",
  menuTabs: (options) => {
    var _a4;
    const enterpriseMenuTabs = ["columnsMenuTab", "generalMenuTab"];
    if ((_a4 = options.menuTabs) == null ? void 0 : _a4.some((tab) => enterpriseMenuTabs.includes(tab))) {
      return "ColumnMenu";
    }
    return null;
  },
  pivot: "SharedPivot",
  pivotIndex: "SharedPivot",
  rowDrag: "RowDrag",
  rowGroup: "SharedRowGrouping",
  rowGroupIndex: "SharedRowGrouping",
  tooltipField: "Tooltip",
  tooltipValueGetter: "Tooltip",
  spanRows: "CellSpan",
  rowGroupingHierarchy: "SharedRowGrouping"
};
var GRID_OPTIONS_MODULES = {
  alignedGrids: "AlignedGrids",
  allowContextMenuWithControlKey: "ContextMenu",
  autoSizeStrategy: "ColumnAutoSize",
  cellSelection: "CellSelection",
  columnHoverHighlight: "ColumnHover",
  datasource: "InfiniteRowModel",
  doesExternalFilterPass: "ExternalFilter",
  editType: "EditCore",
  invalidEditValueMode: "EditCore",
  enableAdvancedFilter: "AdvancedFilter",
  enableCellSpan: "CellSpan",
  enableCharts: "IntegratedCharts",
  enableRangeSelection: "CellSelection",
  enableRowPinning: "PinnedRow",
  findSearchValue: "Find",
  getFullRowEditValidationErrors: "EditCore",
  getContextMenuItems: "ContextMenu",
  getLocaleText: "Locale",
  getMainMenuItems: "ColumnMenu",
  getRowClass: "RowStyle",
  getRowStyle: "RowStyle",
  groupTotalRow: "SharedRowGrouping",
  grandTotalRow: "SharedRowGrouping",
  initialState: "GridState",
  isExternalFilterPresent: "ExternalFilter",
  isRowPinnable: "PinnedRow",
  isRowPinned: "PinnedRow",
  localeText: "Locale",
  masterDetail: "SharedMasterDetail",
  pagination: "Pagination",
  pinnedBottomRowData: "PinnedRow",
  pinnedTopRowData: "PinnedRow",
  pivotMode: "SharedPivot",
  pivotPanelShow: "RowGroupingPanel",
  quickFilterText: "QuickFilter",
  rowClass: "RowStyle",
  rowClassRules: "RowStyle",
  rowData: "ClientSideRowModel",
  rowDragManaged: "RowDrag",
  rowGroupPanelShow: "RowGroupingPanel",
  rowNumbers: "RowNumbers",
  rowSelection: "SharedRowSelection",
  rowStyle: "RowStyle",
  serverSideDatasource: "ServerSideRowModel",
  sideBar: "SideBar",
  statusBar: "StatusBar",
  treeData: "SharedTreeData",
  undoRedoCellEditing: "UndoRedoEdit",
  valueCache: "ValueCache",
  viewportDatasource: "ViewportRowModel"
};
var changeSetId = 0;
var gridInstanceSequence = 0;
var GRID_DOM_KEY = "__ag_grid_instance";
var GridOptionsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "gos";
    this.domDataKey = "__AG_" + Math.random().toString();
    this.instanceId = gridInstanceSequence++;
    this.gridReadyFired = false;
    this.queueEvents = [];
    this.propEventSvc = new LocalEventService();
    this.globalEventHandlerFactory = (restrictToSyncOnly) => {
      return (eventName, event) => {
        if (!this.isAlive()) {
          return;
        }
        const alwaysSync = ALWAYS_SYNC_GLOBAL_EVENTS.has(eventName);
        if (alwaysSync && !restrictToSyncOnly || !alwaysSync && restrictToSyncOnly) {
          return;
        }
        if (!isPublicEventHandler(eventName)) {
          return;
        }
        const fireEvent = (name, e) => {
          const eventHandlerName = _PUBLIC_EVENT_HANDLERS_MAP[name];
          const eventHandler = this.gridOptions[eventHandlerName];
          if (typeof eventHandler === "function") {
            this.beans.frameworkOverrides.wrapOutgoing(() => eventHandler(e));
          }
        };
        if (this.gridReadyFired) {
          fireEvent(eventName, event);
        } else {
          if (eventName === "gridReady") {
            fireEvent(eventName, event);
            this.gridReadyFired = true;
            for (const q of this.queueEvents) {
              fireEvent(q.eventName, q.event);
            }
            this.queueEvents = [];
          } else {
            this.queueEvents.push({ eventName, event });
          }
        }
      };
    };
  }
  wireBeans(beans) {
    this.gridOptions = beans.gridOptions;
    this.validation = beans.validation;
    this.api = beans.gridApi;
    this.gridId = beans.context.getId();
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get gridOptionsContext() {
    return this.gridOptions["context"];
  }
  postConstruct() {
    this.validateGridOptions(this.gridOptions);
    this.eventSvc.addGlobalListener(this.globalEventHandlerFactory().bind(this), true);
    this.eventSvc.addGlobalListener(this.globalEventHandlerFactory(true).bind(this), false);
    this.propEventSvc.setFrameworkOverrides(this.beans.frameworkOverrides);
    this.addManagedEventListeners({
      gridOptionsChanged: ({ options }) => {
        this.updateGridOptions({ options, force: true, source: "optionsUpdated" });
      }
    });
  }
  destroy() {
    super.destroy();
    this.queueEvents = [];
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(property) {
    var _a4;
    return (_a4 = this.gridOptions[property]) != null ? _a4 : GRID_OPTION_DEFAULTS[property];
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(property) {
    return this.mergeGridCommonParams(this.gridOptions[property]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(property) {
    return _exists(this.gridOptions[property]);
  }
  /**
   * Wrap the user callback and attach the api and context to the params object on the way through.
   * @param callback User provided callback
   * @returns Wrapped callback where the params object not require api and context
   */
  mergeGridCommonParams(callback) {
    if (callback) {
      const wrapped = (callbackParams) => {
        return callback(this.addCommon(callbackParams));
      };
      return wrapped;
    }
    return callback;
  }
  updateGridOptions({
    options,
    force,
    source = "api"
  }) {
    const changeSet = { id: changeSetId++, properties: [] };
    const events = [];
    const { gridOptions, validation } = this;
    for (const key of Object.keys(options)) {
      const value = options[key];
      validation == null ? void 0 : validation.warnOnInitialPropertyUpdate(source, key);
      const shouldForce = force || typeof value === "object" && source === "api";
      const previousValue = gridOptions[key];
      if (shouldForce || previousValue !== value) {
        gridOptions[key] = value;
        const event = {
          type: key,
          currentValue: value,
          previousValue,
          changeSet,
          source
        };
        events.push(event);
      }
    }
    this.validateGridOptions(this.gridOptions);
    changeSet.properties = events.map((event) => event.type);
    events.forEach((event) => {
      _logIfDebug(this, `Updated property ${event.type} from`, event.previousValue, ` to `, event.currentValue);
      this.propEventSvc.dispatchEvent(event);
    });
  }
  addPropertyEventListener(key, listener) {
    this.propEventSvc.addEventListener(key, listener);
  }
  removePropertyEventListener(key, listener) {
    this.propEventSvc.removeEventListener(key, listener);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  /** Prefer _addGridCommonParams from gridOptionsUtils for bundle size savings */
  addCommon(params) {
    params.api = this.api;
    params.context = this.gridOptionsContext;
    return params;
  }
  validateOptions(options, modValidations) {
    for (const key of Object.keys(options)) {
      const value = options[key];
      if (value == null || value === false) {
        continue;
      }
      let moduleToCheck = modValidations[key];
      if (typeof moduleToCheck === "function") {
        moduleToCheck = moduleToCheck(options, this.gridOptions, this.beans);
      }
      if (moduleToCheck) {
        this.assertModuleRegistered(moduleToCheck, key);
      }
    }
  }
  validateGridOptions(gridOptions) {
    var _a4;
    this.validateOptions(gridOptions, GRID_OPTIONS_MODULES);
    (_a4 = this.validation) == null ? void 0 : _a4.processGridOptions(gridOptions);
  }
  validateColDef(colDef, colId, skipInferenceCheck) {
    var _a4, _b2;
    if (skipInferenceCheck || !((_a4 = this.beans.dataTypeSvc) == null ? void 0 : _a4.isColPendingInference(colId))) {
      this.validateOptions(colDef, COLUMN_DEFINITION_MOD_VALIDATIONS);
      (_b2 = this.validation) == null ? void 0 : _b2.validateColDef(colDef);
    }
  }
  assertModuleRegistered(moduleName, reasonOrId) {
    const registered = Array.isArray(moduleName) ? moduleName.some((modName) => this.isModuleRegistered(modName)) : this.isModuleRegistered(moduleName);
    if (!registered) {
      _error(200, {
        ...this.getModuleErrorParams(),
        moduleName,
        reasonOrId
      });
    }
    return registered;
  }
  getModuleErrorParams() {
    return {
      gridId: this.gridId,
      gridScoped: _areModulesGridScoped(),
      rowModelType: this.get("rowModelType"),
      isUmd: _isUmd()
    };
  }
  isModuleRegistered(moduleName) {
    return _isModuleRegistered(moduleName, this.gridId, this.get("rowModelType"));
  }
  setInstanceDomData(element) {
    element[GRID_DOM_KEY] = this.instanceId;
  }
  isElementInThisInstance(element) {
    let pointer = element;
    while (pointer) {
      const instanceId = pointer[GRID_DOM_KEY];
      if (_exists(instanceId)) {
        const eventFromThisGrid = instanceId === this.instanceId;
        return eventFromThisGrid;
      }
      pointer = pointer.parentElement;
    }
    return false;
  }
};
function isPublicEventHandler(eventName) {
  return !!_PUBLIC_EVENT_HANDLERS_MAP[eventName];
}
function getHeaderCompElementParams(includeSortIndicator) {
  const hiddenAttrs = { "aria-hidden": "true" };
  return {
    tag: "div",
    cls: "ag-cell-label-container",
    role: "presentation",
    children: [
      {
        tag: "span",
        ref: "eMenu",
        cls: "ag-header-icon ag-header-cell-menu-button",
        attrs: hiddenAttrs
      },
      {
        tag: "span",
        ref: "eFilterButton",
        cls: "ag-header-icon ag-header-cell-filter-button",
        attrs: hiddenAttrs
      },
      {
        tag: "div",
        ref: "eLabel",
        cls: "ag-header-cell-label",
        role: "presentation",
        children: [
          { tag: "span", ref: "eText", cls: "ag-header-cell-text" },
          {
            tag: "span",
            ref: "eFilter",
            cls: "ag-header-icon ag-header-label-icon ag-filter-icon",
            attrs: hiddenAttrs
          },
          includeSortIndicator ? { tag: "ag-sort-indicator", ref: "eSortIndicator" } : null
        ]
      }
    ]
  };
}
var HeaderCompElement = getHeaderCompElementParams(true);
var HeaderCompElementNoSort = getHeaderCompElementParams(false);
var HeaderComp = class extends Component {
  constructor() {
    super(...arguments);
    this.eFilter = RefPlaceholder;
    this.eFilterButton = RefPlaceholder;
    this.eSortIndicator = RefPlaceholder;
    this.eMenu = RefPlaceholder;
    this.eLabel = RefPlaceholder;
    this.eText = RefPlaceholder;
    this.eSortOrder = RefPlaceholder;
    this.eSortAsc = RefPlaceholder;
    this.eSortDesc = RefPlaceholder;
    this.eSortMixed = RefPlaceholder;
    this.eSortNone = RefPlaceholder;
    this.isLoadingInnerComponent = false;
  }
  refresh(params) {
    var _a4, _b2, _c;
    const oldParams = this.params;
    this.params = params;
    if (this.workOutTemplate(params, !!((_a4 = this.beans) == null ? void 0 : _a4.sortSvc)) != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || params.enableSorting != this.currentSort || this.currentSuppressMenuHide != null && this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || oldParams.enableFilterButton != params.enableFilterButton || oldParams.enableFilterIcon != params.enableFilterIcon) {
      return false;
    }
    if (this.innerHeaderComponent) {
      const mergedParams = { ...params };
      _mergeDeep(mergedParams, params.innerHeaderComponentParams);
      (_c = (_b2 = this.innerHeaderComponent).refresh) == null ? void 0 : _c.call(_b2, mergedParams);
    } else {
      this.setDisplayName(params);
    }
    return true;
  }
  workOutTemplate(params, isSorting) {
    const paramsTemplate = params.template;
    if (paramsTemplate) {
      return (paramsTemplate == null ? void 0 : paramsTemplate.trim) ? paramsTemplate.trim() : paramsTemplate;
    } else {
      return isSorting ? HeaderCompElement : HeaderCompElementNoSort;
    }
  }
  init(params) {
    this.params = params;
    const { sortSvc, touchSvc, rowNumbersSvc, userCompFactory } = this.beans;
    const sortComp = sortSvc == null ? void 0 : sortSvc.getSortIndicatorSelector();
    this.currentTemplate = this.workOutTemplate(params, !!sortComp);
    this.setTemplate(this.currentTemplate, sortComp ? [sortComp] : void 0);
    touchSvc == null ? void 0 : touchSvc.setupForHeader(this);
    this.setMenu();
    this.setupSort();
    rowNumbersSvc == null ? void 0 : rowNumbersSvc.setupForHeader(this);
    this.setupFilterIcon();
    this.setupFilterButton();
    this.workOutInnerHeaderComponent(userCompFactory, params);
    this.setDisplayName(params);
  }
  workOutInnerHeaderComponent(userCompFactory, params) {
    const userCompDetails = _getInnerHeaderCompDetails(userCompFactory, params, params);
    if (!userCompDetails) {
      return;
    }
    this.isLoadingInnerComponent = true;
    userCompDetails.newAgStackInstance().then((comp) => {
      this.isLoadingInnerComponent = false;
      if (!comp) {
        return;
      }
      if (this.isAlive()) {
        this.innerHeaderComponent = comp;
        if (this.eText) {
          this.eText.appendChild(comp.getGui());
        }
      } else {
        this.destroyBean(comp);
      }
    });
  }
  setDisplayName(params) {
    const { displayName } = params;
    const oldDisplayName = this.currentDisplayName;
    this.currentDisplayName = displayName;
    if (!this.eText || oldDisplayName === displayName || this.innerHeaderComponent || this.isLoadingInnerComponent) {
      return;
    }
    this.eText.textContent = _toString(displayName);
  }
  addInIcon(iconName, eParent, column) {
    const eIcon = _createIconNoSpan(iconName, this.beans, column);
    if (eIcon) {
      eParent.appendChild(eIcon);
    }
  }
  workOutShowMenu() {
    var _a4;
    return this.params.enableMenu && !!((_a4 = this.beans.menuSvc) == null ? void 0 : _a4.isHeaderMenuButtonEnabled());
  }
  shouldSuppressMenuHide() {
    var _a4;
    return !!((_a4 = this.beans.menuSvc) == null ? void 0 : _a4.isHeaderMenuButtonAlwaysShowEnabled());
  }
  setMenu() {
    if (!this.eMenu) {
      return;
    }
    this.currentShowMenu = this.workOutShowMenu();
    if (!this.currentShowMenu) {
      _removeFromParent(this.eMenu);
      this.eMenu = void 0;
      return;
    }
    const { gos, eMenu, params } = this;
    const isLegacyMenu = _isLegacyMenuEnabled(gos);
    this.addInIcon(isLegacyMenu ? "menu" : "menuAlt", eMenu, params.column);
    eMenu.classList.toggle("ag-header-menu-icon", !isLegacyMenu);
    const currentSuppressMenuHide = this.shouldSuppressMenuHide();
    this.currentSuppressMenuHide = currentSuppressMenuHide;
    this.addManagedElementListeners(eMenu, { click: () => this.showColumnMenu(this.eMenu) });
    this.toggleMenuAlwaysShow(currentSuppressMenuHide);
  }
  toggleMenuAlwaysShow(alwaysShow) {
    var _a4;
    (_a4 = this.eMenu) == null ? void 0 : _a4.classList.toggle("ag-header-menu-always-show", alwaysShow);
  }
  showColumnMenu(element) {
    const { currentSuppressMenuHide, params } = this;
    if (!currentSuppressMenuHide) {
      this.toggleMenuAlwaysShow(true);
    }
    params.showColumnMenu(element, () => {
      if (!currentSuppressMenuHide) {
        this.toggleMenuAlwaysShow(false);
      }
    });
  }
  onMenuKeyboardShortcut(isFilterShortcut) {
    var _a4, _b2, _c;
    const { params, gos, beans, eMenu, eFilterButton } = this;
    const column = params.column;
    const isLegacyMenuEnabled = _isLegacyMenuEnabled(gos);
    if (isFilterShortcut && !isLegacyMenuEnabled) {
      if ((_a4 = beans.menuSvc) == null ? void 0 : _a4.isFilterMenuInHeaderEnabled(column)) {
        params.showFilter((_b2 = eFilterButton != null ? eFilterButton : eMenu) != null ? _b2 : this.getGui());
        return true;
      }
    } else if (params.enableMenu) {
      this.showColumnMenu((_c = eMenu != null ? eMenu : eFilterButton) != null ? _c : this.getGui());
      return true;
    }
    return false;
  }
  setupSort() {
    const { sortSvc } = this.beans;
    if (!sortSvc) {
      return;
    }
    const { enableSorting, column } = this.params;
    this.currentSort = enableSorting;
    if (!this.eSortIndicator) {
      this.eSortIndicator = this.createBean(sortSvc.createSortIndicator(true));
      const { eSortIndicator, eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone } = this;
      eSortIndicator.attachCustomElements(eSortOrder, eSortAsc, eSortDesc, eSortMixed, eSortNone);
    }
    this.eSortIndicator.setupSort(column);
    if (!this.currentSort) {
      return;
    }
    sortSvc.setupHeader(this, column, this.eLabel);
  }
  setupFilterIcon() {
    const { eFilter, params } = this;
    if (!eFilter) {
      return;
    }
    const onFilterChangedIcon = () => {
      const filterPresent = params.column.isFilterActive();
      _setDisplayed(eFilter, filterPresent, { skipAriaHidden: true });
    };
    this.configureFilter(params.enableFilterIcon, eFilter, onFilterChangedIcon, "filterActive");
  }
  setupFilterButton() {
    const { eFilterButton, params } = this;
    if (!eFilterButton) {
      return;
    }
    const configured = this.configureFilter(
      params.enableFilterButton,
      eFilterButton,
      this.onFilterChangedButton.bind(this),
      "filter"
    );
    if (configured) {
      this.addManagedElementListeners(eFilterButton, {
        click: () => params.showFilter(eFilterButton)
      });
    } else {
      this.eFilterButton = void 0;
    }
  }
  configureFilter(enabled, element, filterChangedCallback, icon) {
    if (!enabled) {
      _removeFromParent(element);
      return false;
    }
    const column = this.params.column;
    this.addInIcon(icon, element, column);
    this.addManagedListeners(column, { filterChanged: filterChangedCallback });
    filterChangedCallback();
    return true;
  }
  onFilterChangedButton() {
    const filterPresent = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", filterPresent);
  }
  getAnchorElementForMenu(isFilter) {
    var _a4, _b2;
    const { eFilterButton, eMenu } = this;
    if (isFilter) {
      return (_a4 = eFilterButton != null ? eFilterButton : eMenu) != null ? _a4 : this.getGui();
    }
    return (_b2 = eMenu != null ? eMenu : eFilterButton) != null ? _b2 : this.getGui();
  }
  destroy() {
    super.destroy();
    if (this.innerHeaderComponent) {
      this.destroyBean(this.innerHeaderComponent);
      this.innerHeaderComponent = void 0;
    }
  }
};
var HeaderGroupCompElement = {
  tag: "div",
  cls: "ag-header-group-cell-label",
  role: "presentation",
  children: [
    { tag: "span", ref: "agLabel", cls: "ag-header-group-text", role: "presentation" },
    { tag: "span", ref: "agOpened", cls: `ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded` },
    { tag: "span", ref: "agClosed", cls: `ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed` }
  ]
};
var HeaderGroupComp = class extends Component {
  constructor() {
    super(HeaderGroupCompElement);
    this.agOpened = RefPlaceholder;
    this.agClosed = RefPlaceholder;
    this.agLabel = RefPlaceholder;
    this.isLoadingInnerComponent = false;
  }
  init(params) {
    const { userCompFactory, touchSvc } = this.beans;
    this.params = params;
    this.checkWarnings();
    this.workOutInnerHeaderGroupComponent(userCompFactory, params);
    this.setupLabel(params);
    this.addGroupExpandIcon(params);
    this.setupExpandIcons();
    touchSvc == null ? void 0 : touchSvc.setupForHeaderGroup(this);
  }
  checkWarnings() {
    const paramsAny = this.params;
    if (paramsAny.template) {
      _warn(89);
    }
  }
  workOutInnerHeaderGroupComponent(userCompFactory, params) {
    const userCompDetails = _getInnerHeaderGroupCompDetails(userCompFactory, params, params);
    if (!userCompDetails) {
      return;
    }
    this.isLoadingInnerComponent = true;
    userCompDetails.newAgStackInstance().then((comp) => {
      this.isLoadingInnerComponent = false;
      if (!comp) {
        return;
      }
      if (this.isAlive()) {
        this.innerHeaderGroupComponent = comp;
        this.agLabel.appendChild(comp.getGui());
      } else {
        this.destroyBean(comp);
      }
    });
  }
  setupExpandIcons() {
    const {
      agOpened,
      agClosed,
      params: { columnGroup },
      beans
    } = this;
    this.addInIcon("columnGroupOpened", agOpened);
    this.addInIcon("columnGroupClosed", agClosed);
    const expandAction = (event) => {
      if (_isStopPropagationForAgGrid(event)) {
        return;
      }
      const newExpandedValue = !columnGroup.isExpanded();
      beans.colGroupSvc.setColumnGroupOpened(
        columnGroup.getProvidedColumnGroup(),
        newExpandedValue,
        "uiColumnExpanded"
      );
    };
    this.addTouchAndClickListeners(beans, agClosed, expandAction);
    this.addTouchAndClickListeners(beans, agOpened, expandAction);
    const stopPropagationAction = (event) => {
      _stopPropagationForAgGrid(event);
    };
    this.addManagedElementListeners(agClosed, { dblclick: stopPropagationAction });
    this.addManagedElementListeners(agOpened, { dblclick: stopPropagationAction });
    this.addManagedElementListeners(this.getGui(), { dblclick: expandAction });
    this.updateIconVisibility();
    const providedColumnGroup = columnGroup.getProvidedColumnGroup();
    const updateIcon = this.updateIconVisibility.bind(this);
    this.addManagedListeners(providedColumnGroup, {
      expandedChanged: updateIcon,
      expandableChanged: updateIcon
    });
  }
  addTouchAndClickListeners(beans, eElement, action) {
    var _a4;
    (_a4 = beans.touchSvc) == null ? void 0 : _a4.setupForHeaderGroupElement(this, eElement, action);
    this.addManagedElementListeners(eElement, { click: action });
  }
  updateIconVisibility() {
    const {
      agOpened,
      agClosed,
      params: { columnGroup }
    } = this;
    if (columnGroup.isExpandable()) {
      const expanded = columnGroup.isExpanded();
      _setDisplayed(agOpened, expanded);
      _setDisplayed(agClosed, !expanded);
    } else {
      _setDisplayed(agOpened, false);
      _setDisplayed(agClosed, false);
    }
  }
  addInIcon(iconName, element) {
    const eIcon = _createIconNoSpan(iconName, this.beans, null);
    if (eIcon) {
      element.appendChild(eIcon);
    }
  }
  addGroupExpandIcon(params) {
    if (!params.columnGroup.isExpandable()) {
      const { agOpened, agClosed } = this;
      _setDisplayed(agOpened, false);
      _setDisplayed(agClosed, false);
      return;
    }
  }
  setupLabel(params) {
    var _a4;
    const { displayName, columnGroup } = params;
    const hasInnerComponent = this.innerHeaderGroupComponent || this.isLoadingInnerComponent;
    if (_exists(displayName) && !hasInnerComponent) {
      this.agLabel.textContent = _toString(displayName);
    }
    this.toggleCss("ag-sticky-label", !((_a4 = columnGroup.getColGroupDef()) == null ? void 0 : _a4.suppressStickyLabel));
  }
  destroy() {
    super.destroy();
    if (this.innerHeaderGroupComponent) {
      this.destroyBean(this.innerHeaderGroupComponent);
      this.innerHeaderGroupComponent = void 0;
    }
  }
};
var ColumnHeaderCompModule = {
  moduleName: "ColumnHeaderComp",
  version: VERSION,
  userComponents: {
    agColumnHeader: HeaderComp
  },
  icons: {
    // button to launch legacy column menu
    menu: "menu",
    // button to launch new enterprise column menu
    menuAlt: "menu-alt"
  }
};
var ColumnGroupHeaderCompModule = {
  moduleName: "ColumnGroupHeaderComp",
  version: VERSION,
  userComponents: {
    agColumnGroupHeader: HeaderGroupComp
  },
  icons: {
    // header column group shown when expanded (click to contract)
    columnGroupOpened: "expanded",
    // header column group shown when contracted (click to expand)
    columnGroupClosed: "contracted"
  }
};
var AnimationFrameService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "animationFrameSvc";
    this.p1 = { list: [], sorted: false };
    this.p2 = { list: [], sorted: false };
    this.f1 = { list: [], sorted: false };
    this.destroyTasks = [];
    this.ticking = false;
    this.scrollGoingDown = true;
    this.lastScrollTop = 0;
    this.taskCount = 0;
  }
  setScrollTop(scrollTop) {
    this.scrollGoingDown = scrollTop >= this.lastScrollTop;
    if (scrollTop === 0) {
      this.scrollGoingDown = true;
    }
    this.lastScrollTop = scrollTop;
  }
  postConstruct() {
    this.active = !this.gos.get("suppressAnimationFrame");
    this.batchFrameworkComps = this.beans.frameworkOverrides.batchFrameworkComps;
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verify() {
    if (this.active === false) {
      _warn(92);
    }
  }
  createTask(task, index, list, isFramework, isDeferred = false) {
    this.verify();
    let taskList = list;
    if (isFramework && this.batchFrameworkComps) {
      taskList = "f1";
    }
    const taskItem = { task, index, createOrder: ++this.taskCount, deferred: isDeferred };
    this.addTaskToList(this[taskList], taskItem);
    this.schedule();
  }
  addTaskToList(taskList, task) {
    taskList.list.push(task);
    taskList.sorted = false;
  }
  sortTaskList(taskList) {
    if (taskList.sorted) {
      return;
    }
    const sortDirection = this.scrollGoingDown ? 1 : -1;
    taskList.list.sort((a, b) => {
      if (a.deferred !== b.deferred) {
        return a.deferred ? -1 : 1;
      }
      if (a.index !== b.index) {
        return sortDirection * (b.index - a.index);
      }
      return b.createOrder - a.createOrder;
    });
    taskList.sorted = true;
  }
  addDestroyTask(task) {
    this.verify();
    this.destroyTasks.push(task);
    this.schedule();
  }
  executeFrame(millis) {
    const { p1, p2, f1, destroyTasks, beans } = this;
    const { ctrlsSvc, frameworkOverrides } = beans;
    const p1Tasks = p1.list;
    const p2Tasks = p2.list;
    const f1Tasks = f1.list;
    const frameStart = Date.now();
    let duration = 0;
    const noMaxMillis = millis <= 0;
    const scrollFeature = ctrlsSvc.getScrollFeature();
    while (noMaxMillis || duration < millis) {
      const gridBodyDidSomething = scrollFeature.scrollGridIfNeeded();
      if (!gridBodyDidSomething) {
        let task;
        if (p1Tasks.length) {
          this.sortTaskList(p1);
          task = p1Tasks.pop().task;
        } else if (p2Tasks.length) {
          this.sortTaskList(p2);
          task = p2Tasks.pop().task;
        } else if (f1Tasks.length) {
          frameworkOverrides.wrapOutgoing(() => {
            while (noMaxMillis || duration < millis) {
              const gridBodyDidSomething2 = scrollFeature.scrollGridIfNeeded();
              if (!gridBodyDidSomething2) {
                if (f1Tasks.length) {
                  this.sortTaskList(f1);
                  task = f1Tasks.pop().task;
                  task();
                } else {
                  break;
                }
              } else {
                break;
              }
              duration = Date.now() - frameStart;
            }
          });
          task = () => {
          };
        } else if (destroyTasks.length) {
          task = destroyTasks.pop();
        } else {
          break;
        }
        task();
      }
      duration = Date.now() - frameStart;
    }
    if (p1Tasks.length || p2Tasks.length || f1Tasks.length || destroyTasks.length) {
      this.requestFrame();
    } else {
      this.ticking = false;
    }
  }
  flushAllFrames() {
    if (!this.active) {
      return;
    }
    this.executeFrame(-1);
  }
  schedule() {
    if (!this.active) {
      return;
    }
    if (!this.ticking) {
      this.ticking = true;
      this.requestFrame();
    }
  }
  requestFrame() {
    const callback = this.executeFrame.bind(this, 60);
    _requestAnimationFrame(this.beans, callback);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
};
var AnimationFrameModule = {
  moduleName: "AnimationFrame",
  version: VERSION,
  beans: [AnimationFrameService]
};
var IconService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "iconSvc";
  }
  createIconNoSpan(iconName, params) {
    return _createIconNoSpan(iconName, this.beans, params == null ? void 0 : params.column);
  }
};
var TouchService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "touchSvc";
  }
  mockBodyContextMenu(ctrl, listener) {
    this.mockContextMenu(ctrl, ctrl.eBodyViewport, listener);
  }
  mockHeaderContextMenu(ctrl, listener) {
    this.mockContextMenu(ctrl, ctrl.eGui, listener);
  }
  mockRowContextMenu(ctrl) {
    if (!_isIOSUserAgent()) {
      return;
    }
    const listener = (mouseListener, touch, touchEvent) => {
      var _a4, _b2;
      const { rowCtrl, cellCtrl } = ctrl.getControlsForEventTarget((_a4 = touchEvent == null ? void 0 : touchEvent.target) != null ? _a4 : null);
      if (cellCtrl == null ? void 0 : cellCtrl.column) {
        cellCtrl.dispatchCellContextMenuEvent(touchEvent != null ? touchEvent : null);
      }
      (_b2 = this.beans.contextMenuSvc) == null ? void 0 : _b2.handleContextMenuMouseEvent(void 0, touchEvent, rowCtrl, cellCtrl);
    };
    this.mockContextMenu(ctrl, ctrl.element, listener);
  }
  handleCellDoubleClick(ctrl, mouseEvent) {
    const isDoubleClickOnIPad = () => {
      if (!_isIOSUserAgent() || _isEventSupported("dblclick")) {
        return false;
      }
      const nowMillis = Date.now();
      const res = nowMillis - ctrl.lastIPadMouseClickEvent < 200;
      ctrl.lastIPadMouseClickEvent = nowMillis;
      return res;
    };
    if (isDoubleClickOnIPad()) {
      ctrl.onCellDoubleClicked(mouseEvent);
      mouseEvent.preventDefault();
      return true;
    }
    return false;
  }
  setupForHeader(comp) {
    const { gos, sortSvc, menuSvc } = this.beans;
    if (gos.get("suppressTouch")) {
      return;
    }
    const { params, eMenu, eFilterButton } = comp;
    const touchListener = new TouchListener(comp.getGui(), true);
    const suppressMenuHide = comp.shouldSuppressMenuHide();
    const tapMenuButton = suppressMenuHide && _exists(eMenu) && params.enableMenu;
    const menuTouchListener = tapMenuButton ? new TouchListener(eMenu, true) : touchListener;
    if (params.enableMenu || (menuSvc == null ? void 0 : menuSvc.isHeaderContextMenuEnabled(params.column))) {
      const eventType = tapMenuButton ? "tap" : "longTap";
      const showMenuFn = (event) => params.showColumnMenuAfterMouseClick(event.touchStart);
      comp.addManagedListeners(menuTouchListener, { [eventType]: showMenuFn });
    }
    if (params.enableSorting) {
      const tapListener = (event) => {
        const target = event.touchStart.target;
        if (suppressMenuHide && ((eMenu == null ? void 0 : eMenu.contains(target)) || (eFilterButton == null ? void 0 : eFilterButton.contains(target)))) {
          return;
        }
        sortSvc == null ? void 0 : sortSvc.progressSort(params.column, false, "uiColumnSorted");
      };
      comp.addManagedListeners(touchListener, { tap: tapListener });
    }
    if (params.enableFilterButton && eFilterButton) {
      const filterButtonTouchListener = new TouchListener(eFilterButton, true);
      comp.addManagedListeners(filterButtonTouchListener, {
        tap: () => params.showFilter(eFilterButton)
      });
      comp.addDestroyFunc(() => filterButtonTouchListener.destroy());
    }
    comp.addDestroyFunc(() => touchListener.destroy());
    if (tapMenuButton) {
      comp.addDestroyFunc(() => menuTouchListener.destroy());
    }
  }
  setupForHeaderGroup(comp) {
    var _a4;
    const params = comp.params;
    if ((_a4 = this.beans.menuSvc) == null ? void 0 : _a4.isHeaderContextMenuEnabled(
      params.columnGroup.getProvidedColumnGroup()
    )) {
      const touchListener = new TouchListener(params.eGridHeader, true);
      const showMenuFn = (event) => params.showColumnMenuAfterMouseClick(event.touchStart);
      comp.addManagedListeners(touchListener, { longTap: showMenuFn });
      comp.addDestroyFunc(() => touchListener.destroy());
    }
  }
  setupForHeaderGroupElement(comp, eElement, action) {
    const touchListener = new TouchListener(eElement, true);
    comp.addManagedListeners(touchListener, { tap: action });
    comp.addDestroyFunc(() => touchListener.destroy());
  }
  mockContextMenu(ctrl, element, listener) {
    if (!_isIOSUserAgent()) {
      return;
    }
    const touchListener = new TouchListener(element);
    const longTapListener = (event) => {
      if (!_isEventFromThisInstance(this.beans, event.touchEvent)) {
        return;
      }
      listener(void 0, event.touchStart, event.touchEvent);
    };
    ctrl.addManagedListeners(touchListener, { longTap: longTapListener });
    ctrl.addDestroyFunc(() => touchListener.destroy());
  }
};
var TouchModule = {
  moduleName: "Touch",
  version: VERSION,
  beans: [TouchService]
};
var CellNavigationService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "cellNavigation";
  }
  wireBeans(beans) {
    this.rowSpanSvc = beans.rowSpanSvc;
  }
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(key, focusedCell, ctrlPressed = false) {
    if (ctrlPressed) {
      return this.getNextCellToFocusWithCtrlPressed(key, focusedCell);
    }
    return this.getNextCellToFocusWithoutCtrlPressed(key, focusedCell);
  }
  getNextCellToFocusWithCtrlPressed(key, focusedCell) {
    const upKey = key === KeyCode.UP;
    const downKey = key === KeyCode.DOWN;
    const leftKey = key === KeyCode.LEFT;
    let column;
    let rowIndex;
    const { pageBounds, gos, visibleCols, pinnedRowModel } = this.beans;
    const { rowPinned } = focusedCell;
    if (upKey || downKey) {
      if (rowPinned && pinnedRowModel) {
        if (upKey) {
          rowIndex = 0;
        } else {
          rowIndex = rowPinned === "top" ? pinnedRowModel.getPinnedTopRowCount() - 1 : pinnedRowModel.getPinnedBottomRowCount() - 1;
        }
      } else {
        rowIndex = upKey ? pageBounds.getFirstRow() : pageBounds.getLastRow();
      }
      column = focusedCell.column;
    } else {
      const isRtl = gos.get("enableRtl");
      rowIndex = focusedCell.rowIndex;
      const allColumns = leftKey !== isRtl ? visibleCols.allCols : [...visibleCols.allCols].reverse();
      column = allColumns.find(
        (col) => this.isCellGoodToFocusOn({
          rowIndex,
          rowPinned: null,
          column: col
        })
      );
    }
    return column ? {
      rowIndex,
      rowPinned,
      column
    } : null;
  }
  getNextCellToFocusWithoutCtrlPressed(key, focusedCell) {
    let pointer = focusedCell;
    let finished = false;
    while (!finished) {
      switch (key) {
        case KeyCode.UP:
          pointer = this.getCellAbove(pointer);
          break;
        case KeyCode.DOWN:
          pointer = this.getCellBelow(pointer);
          break;
        case KeyCode.RIGHT:
          pointer = this.gos.get("enableRtl") ? this.getCellToLeft(pointer) : this.getCellToRight(pointer);
          break;
        case KeyCode.LEFT:
          pointer = this.gos.get("enableRtl") ? this.getCellToRight(pointer) : this.getCellToLeft(pointer);
          break;
        default:
          pointer = null;
          _warn(8, { key });
          break;
      }
      if (pointer) {
        finished = this.isCellGoodToFocusOn(pointer);
      } else {
        finished = true;
      }
    }
    return pointer;
  }
  isCellGoodToFocusOn(gridCell) {
    const column = gridCell.column;
    let rowNode;
    const { pinnedRowModel, rowModel } = this.beans;
    switch (gridCell.rowPinned) {
      case "top":
        rowNode = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedTopRow(gridCell.rowIndex);
        break;
      case "bottom":
        rowNode = pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedBottomRow(gridCell.rowIndex);
        break;
      default:
        rowNode = rowModel.getRow(gridCell.rowIndex);
        break;
    }
    if (!rowNode) {
      return false;
    }
    const suppressNavigable = this.isSuppressNavigable(column, rowNode);
    return !suppressNavigable;
  }
  getCellToLeft(lastCell) {
    if (!lastCell) {
      return null;
    }
    const colToLeft = this.beans.visibleCols.getColBefore(lastCell.column);
    if (!colToLeft) {
      return null;
    }
    return {
      rowIndex: lastCell.rowIndex,
      column: colToLeft,
      rowPinned: lastCell.rowPinned
    };
  }
  getCellToRight(lastCell) {
    if (!lastCell) {
      return null;
    }
    const colToRight = this.beans.visibleCols.getColAfter(lastCell.column);
    if (!colToRight) {
      return null;
    }
    return {
      rowIndex: lastCell.rowIndex,
      column: colToRight,
      rowPinned: lastCell.rowPinned
    };
  }
  getCellBelow(lastCell) {
    var _a4, _b2;
    if (!lastCell) {
      return null;
    }
    const adjustedLastCell = (_b2 = (_a4 = this.rowSpanSvc) == null ? void 0 : _a4.getCellEnd(lastCell)) != null ? _b2 : lastCell;
    const rowBelow = _getRowBelow(this.beans, adjustedLastCell, true);
    if (rowBelow) {
      return {
        rowIndex: rowBelow.rowIndex,
        column: lastCell.column,
        rowPinned: rowBelow.rowPinned
      };
    }
    return null;
  }
  getCellAbove(lastCell) {
    var _a4, _b2;
    if (!lastCell) {
      return null;
    }
    const adjustedLastCell = (_b2 = (_a4 = this.rowSpanSvc) == null ? void 0 : _a4.getCellStart(lastCell)) != null ? _b2 : lastCell;
    const rowAbove = _getRowAbove(
      this.beans,
      {
        rowIndex: adjustedLastCell.rowIndex,
        rowPinned: adjustedLastCell.rowPinned
      },
      true
    );
    if (rowAbove) {
      return {
        rowIndex: rowAbove.rowIndex,
        column: lastCell.column,
        rowPinned: rowAbove.rowPinned
      };
    }
    return null;
  }
  getNextTabbedCell(gridCell, backwards) {
    if (backwards) {
      return this.getNextTabbedCellBackwards(gridCell);
    }
    return this.getNextTabbedCellForwards(gridCell);
  }
  getNextTabbedCellForwards(gridCell) {
    var _a4;
    const { visibleCols, pagination } = this.beans;
    const displayedColumns = visibleCols.allCols;
    let newRowIndex = gridCell.rowIndex;
    let newFloating = gridCell.rowPinned;
    let newColumn = visibleCols.getColAfter(gridCell.column);
    if (!newColumn) {
      newColumn = displayedColumns[0];
      const rowBelow = _getRowBelow(this.beans, gridCell, true);
      if (_missing(rowBelow)) {
        return null;
      }
      if (!rowBelow.rowPinned && !((_a4 = pagination == null ? void 0 : pagination.isRowInPage(rowBelow.rowIndex)) != null ? _a4 : true)) {
        return null;
      }
      newRowIndex = rowBelow ? rowBelow.rowIndex : null;
      newFloating = rowBelow ? rowBelow.rowPinned : null;
    }
    return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
  }
  getNextTabbedCellBackwards(gridCell) {
    var _a4;
    const { beans } = this;
    const { visibleCols, pagination } = beans;
    const displayedColumns = visibleCols.allCols;
    let newRowIndex = gridCell.rowIndex;
    let newFloating = gridCell.rowPinned;
    let newColumn = visibleCols.getColBefore(gridCell.column);
    if (!newColumn) {
      newColumn = _last(displayedColumns);
      const rowAbove = _getRowAbove(beans, { rowIndex: gridCell.rowIndex, rowPinned: gridCell.rowPinned }, true);
      if (_missing(rowAbove)) {
        return null;
      }
      if (!rowAbove.rowPinned && !((_a4 = pagination == null ? void 0 : pagination.isRowInPage(rowAbove.rowIndex)) != null ? _a4 : true)) {
        return null;
      }
      newRowIndex = rowAbove ? rowAbove.rowIndex : null;
      newFloating = rowAbove ? rowAbove.rowPinned : null;
    }
    return { rowIndex: newRowIndex, column: newColumn, rowPinned: newFloating };
  }
  isSuppressNavigable(column, rowNode) {
    const { suppressNavigable } = column.colDef;
    if (typeof suppressNavigable === "boolean") {
      return suppressNavigable;
    }
    if (typeof suppressNavigable === "function") {
      const params = column.createColumnFunctionCallbackParams(rowNode);
      const userFunc = suppressNavigable;
      return userFunc(params);
    }
    return false;
  }
};
function getFocusedCell(beans) {
  return beans.focusSvc.getFocusedCell();
}
function clearFocusedCell(beans) {
  return beans.focusSvc.clearFocusedCell();
}
function setFocusedCell(beans, rowIndex, colKey, rowPinned) {
  beans.focusSvc.setFocusedCell({ rowIndex, column: colKey, rowPinned, forceBrowserFocus: true });
}
function tabToNextCell(beans, event) {
  var _a4, _b2;
  return (_b2 = (_a4 = beans.navigation) == null ? void 0 : _a4.tabToNextCell(false, event)) != null ? _b2 : false;
}
function tabToPreviousCell(beans, event) {
  var _a4, _b2;
  return (_b2 = (_a4 = beans.navigation) == null ? void 0 : _a4.tabToNextCell(true, event)) != null ? _b2 : false;
}
function setFocusedHeader(beans, colKey, floatingFilter = false) {
  var _a4;
  const headerPosition = (_a4 = beans.headerNavigation) == null ? void 0 : _a4.getHeaderPositionForColumn(colKey, floatingFilter);
  if (!headerPosition) {
    return;
  }
  beans.focusSvc.focusHeaderPosition({ headerPosition });
}
var EditCellValidationModel = class {
  constructor() {
    this.cellValidations = /* @__PURE__ */ new Map();
  }
  getCellValidation(position) {
    var _a4, _b2;
    const { rowNode, column } = position || {};
    return (_b2 = (_a4 = this.cellValidations) == null ? void 0 : _a4.get(rowNode)) == null ? void 0 : _b2.get(column);
  }
  hasCellValidation(position) {
    if (!position || !position.rowNode || !position.column) {
      return this.cellValidations.size > 0;
    }
    return !!this.getCellValidation(position);
  }
  setCellValidation(position, validation) {
    const { rowNode, column } = position;
    if (!this.cellValidations.has(rowNode)) {
      this.cellValidations.set(rowNode, /* @__PURE__ */ new Map());
    }
    this.cellValidations.get(rowNode).set(column, validation);
  }
  clearCellValidation(position) {
    var _a4;
    const { rowNode, column } = position;
    (_a4 = this.cellValidations.get(rowNode)) == null ? void 0 : _a4.delete(column);
  }
  setCellValidationMap(validationMap) {
    this.cellValidations = validationMap;
  }
  getCellValidationMap() {
    return this.cellValidations;
  }
  clearCellValidationMap() {
    this.cellValidations.clear();
  }
};
var EditRowValidationModel = class {
  constructor() {
    this.rowValidations = /* @__PURE__ */ new Map();
  }
  getRowValidation(position) {
    const { rowNode } = position || {};
    return this.rowValidations.get(rowNode);
  }
  hasRowValidation(position) {
    if (!position || !position.rowNode) {
      return this.rowValidations.size > 0;
    }
    return !!this.getRowValidation(position);
  }
  setRowValidation({ rowNode }, rowValidation) {
    this.rowValidations.set(rowNode, rowValidation);
  }
  clearRowValidation({ rowNode }) {
    this.rowValidations.delete(rowNode);
  }
  setRowValidationMap(validationMap) {
    this.rowValidations = validationMap;
  }
  getRowValidationMap() {
    return this.rowValidations;
  }
  clearRowValidationMap() {
    this.rowValidations.clear();
  }
};
function _getRowCtrl(beans, inputs = {}) {
  var _a4;
  const { rowIndex, rowId, rowCtrl, rowPinned } = inputs;
  if (rowCtrl) {
    return rowCtrl;
  }
  const { rowModel, rowRenderer } = beans;
  let { rowNode } = inputs;
  if (!rowNode) {
    if (rowId) {
      rowNode = _getRowById(beans, rowId, rowPinned);
    } else if (rowIndex != null) {
      rowNode = rowModel.getRow(rowIndex);
    }
  }
  return (_a4 = rowRenderer.getRowCtrls(rowNode ? [rowNode] : [])) == null ? void 0 : _a4[0];
}
function _getCellCtrl(beans, inputs = {}) {
  var _a4, _b2, _c, _d, _e;
  const { cellCtrl, colId, columnId, column } = inputs;
  if (cellCtrl) {
    return cellCtrl;
  }
  const actualColumn = beans.colModel.getCol((_a4 = colId != null ? colId : columnId) != null ? _a4 : _getColId(column));
  const rowCtrl = (_b2 = inputs.rowCtrl) != null ? _b2 : _getRowCtrl(beans, inputs);
  const result = (_c = rowCtrl == null ? void 0 : rowCtrl.getCellCtrl(actualColumn)) != null ? _c : void 0;
  if (result) {
    return result;
  }
  const rowNode = (_d = inputs.rowNode) != null ? _d : rowCtrl == null ? void 0 : rowCtrl.rowNode;
  if (rowNode) {
    return (_e = beans.rowRenderer.getCellCtrls([rowNode], [actualColumn])) == null ? void 0 : _e[0];
  }
  return void 0;
}
function _getColId(column) {
  if (!column) {
    return void 0;
  }
  if (typeof column === "string") {
    return column;
  }
  return column.getColId();
}
var UNEDITED = Symbol("unedited");
function getCellEditorInstanceMap(beans, params = {}) {
  var _a4;
  const res = [];
  const ctrls = beans.rowRenderer.getCellCtrls(params.rowNodes, params.columns);
  for (const ctrl of ctrls) {
    const cellEditor = (_a4 = ctrl.comp) == null ? void 0 : _a4.getCellEditor();
    if (cellEditor) {
      res.push({
        ctrl,
        editor: _unwrapUserComp(cellEditor)
      });
    }
  }
  return res;
}
function _valueFromEditor(beans, cellEditor, params) {
  var _a4, _b2, _c;
  const noValueResult = { editorValueExists: false };
  if (_hasValidationRules(beans)) {
    const validationErrors = (_a4 = cellEditor.getValidationErrors) == null ? void 0 : _a4.call(cellEditor);
    if (((_b2 = validationErrors == null ? void 0 : validationErrors.length) != null ? _b2 : 0) > 0) {
      return noValueResult;
    }
  }
  if (params == null ? void 0 : params.isCancelling) {
    return noValueResult;
  }
  if (params == null ? void 0 : params.isStopping) {
    const isCancelAfterEnd = (_c = cellEditor == null ? void 0 : cellEditor.isCancelAfterEnd) == null ? void 0 : _c.call(cellEditor);
    if (isCancelAfterEnd) {
      return { ...noValueResult, isCancelAfterEnd };
    }
  }
  const editorValue = cellEditor.getValue();
  return {
    editorValue,
    editorValueExists: true
  };
}
function _syncFromEditors(beans, params) {
  var _a4;
  (_a4 = beans.editModelSvc) == null ? void 0 : _a4.getEditPositions().forEach((cellId) => {
    var _a5, _b2;
    const cellCtrl = _getCellCtrl(beans, cellId);
    if (!cellCtrl) {
      return;
    }
    const editor = (_a5 = cellCtrl.comp) == null ? void 0 : _a5.getCellEditor();
    if (!editor) {
      return;
    }
    const { editorValue, editorValueExists, isCancelAfterEnd } = _valueFromEditor(beans, editor, params);
    if (isCancelAfterEnd) {
      (_b2 = beans.editModelSvc) == null ? void 0 : _b2.setEdit(cellId, { editorState: { isCancelAfterEnd } });
    }
    _syncFromEditor(beans, cellId, editorValue, void 0, !editorValueExists, params);
  });
}
function _syncFromEditor(beans, position, editorValue, _source, valueSameAsSource, params) {
  const { editModelSvc, valueSvc } = beans;
  if (!editModelSvc) {
    return;
  }
  const { rowNode, column } = position;
  if (!(rowNode && column)) {
    return;
  }
  let edit = editModelSvc.getEdit(position, true);
  if (!(edit == null ? void 0 : edit.sourceValue)) {
    edit = editModelSvc.setEdit(position, {
      sourceValue: valueSvc.getValue(column, rowNode, void 0, "api"),
      pendingValue: edit ? edit.editorValue : UNEDITED
    });
  }
  editModelSvc.setEdit(position, {
    editorValue: valueSameAsSource ? edit.sourceValue : editorValue
  });
  if (params == null ? void 0 : params.persist) {
    _persistEditorValue(beans, position);
  }
}
function _persistEditorValue(beans, position) {
  const { editModelSvc } = beans;
  const edit = editModelSvc == null ? void 0 : editModelSvc.getEdit(position, true);
  editModelSvc == null ? void 0 : editModelSvc.setEdit(position, {
    pendingValue: edit == null ? void 0 : edit.editorValue
  });
}
function _hasValidationRules(beans) {
  var _a4;
  const { gos, colModel } = beans;
  const getFullRowEditValidationErrors = !!gos.get("getFullRowEditValidationErrors");
  const columnsHaveRules = (_a4 = colModel.getColumnDefs()) == null ? void 0 : _a4.filter((c) => c.editable).some(({ cellEditorParams }) => {
    const { minLength, maxLength, getValidationErrors, min, max } = cellEditorParams || {};
    return minLength !== void 0 || maxLength !== void 0 || getValidationErrors !== void 0 || min !== void 0 || max !== void 0;
  });
  const editorsHaveRules = beans.gridApi.getCellEditorInstances().some((editor) => editor.getValidationElement || editor.getValidationErrors);
  return columnsHaveRules || getFullRowEditValidationErrors || editorsHaveRules;
}
function _populateModelValidationErrors(beans, force) {
  var _a4, _b2, _c, _d, _e, _f, _g, _h, _i;
  if (!(force || _hasValidationRules(beans))) {
    return;
  }
  const mappedEditors = getCellEditorInstanceMap(beans);
  const cellValidationModel = new EditCellValidationModel();
  const { ariaAnnounce, localeSvc, editModelSvc, gos } = beans;
  const includeRows = gos.get("editType") === "fullRow";
  const translate = _getLocaleTextFunc(localeSvc);
  const ariaValidationErrorPrefix = translate("ariaValidationErrorPrefix", "Cell Editor Validation");
  for (const mappedEditor of mappedEditors) {
    const { ctrl, editor } = mappedEditor;
    const { rowNode, column } = ctrl;
    const errorMessages = (_b2 = (_a4 = editor.getValidationErrors) == null ? void 0 : _a4.call(editor)) != null ? _b2 : [];
    const el = ((_c = editor.getValidationElement) == null ? void 0 : _c.call(editor, false)) || !((_d = editor.isPopup) == null ? void 0 : _d.call(editor)) && ctrl.eGui;
    if (el) {
      const isInvalid = errorMessages != null && errorMessages.length > 0;
      const invalidMessage = isInvalid ? errorMessages.join(". ") : "";
      _setAriaInvalid(el, isInvalid);
      if (isInvalid) {
        ariaAnnounce.announceValue(`${ariaValidationErrorPrefix} ${errorMessages}`, "editorValidation");
      }
      if (el instanceof HTMLInputElement) {
        el.setCustomValidity(invalidMessage);
      } else {
        el.classList.toggle("invalid", isInvalid);
      }
    }
    if ((errorMessages == null ? void 0 : errorMessages.length) > 0) {
      cellValidationModel.setCellValidation(
        {
          rowNode,
          column
        },
        {
          errorMessages
        }
      );
    }
  }
  _syncFromEditors(beans, { persist: false });
  editModelSvc == null ? void 0 : editModelSvc.setCellValidationModel(cellValidationModel);
  const rowCtrlSet = /* @__PURE__ */ new Set();
  for (const { ctrl } of mappedEditors) {
    rowCtrlSet.add(ctrl.rowCtrl);
  }
  if (includeRows) {
    const rowValidations = _generateRowValidationErrors(beans);
    editModelSvc == null ? void 0 : editModelSvc.setRowValidationModel(rowValidations);
  }
  for (const rowCtrl of rowCtrlSet.values()) {
    (_e = rowCtrl.rowEditStyleFeature) == null ? void 0 : _e.applyRowStyles();
    for (const cellCtrl of rowCtrl.getAllCellCtrls()) {
      (_f = cellCtrl.tooltipFeature) == null ? void 0 : _f.refreshTooltip(true);
      (_g = cellCtrl.editorTooltipFeature) == null ? void 0 : _g.refreshTooltip(true);
      (_i = (_h = cellCtrl.editStyleFeature) == null ? void 0 : _h.applyCellStyles) == null ? void 0 : _i.call(_h);
    }
  }
}
var _generateRowValidationErrors = (beans) => {
  var _a4, _b2, _c;
  const rowValidationModel = new EditRowValidationModel();
  const getFullRowEditValidationErrors = beans.gos.get("getFullRowEditValidationErrors");
  const editMap = (_a4 = beans.editModelSvc) == null ? void 0 : _a4.getEditMap();
  if (!editMap) {
    return rowValidationModel;
  }
  for (const rowNode of editMap.keys()) {
    const rowEditMap = editMap.get(rowNode);
    if (!rowEditMap) {
      continue;
    }
    const editorsState = [];
    const { rowIndex, rowPinned } = rowNode;
    for (const column of rowEditMap.keys()) {
      const editValue = rowEditMap.get(column);
      if (!editValue) {
        continue;
      }
      const { editorValue, pendingValue, sourceValue } = editValue;
      const newValue = (_b2 = editorValue != null ? editorValue : pendingValue === UNEDITED ? void 0 : pendingValue) != null ? _b2 : sourceValue;
      editorsState.push({
        column,
        colId: column.getColId(),
        rowIndex,
        rowPinned,
        oldValue: sourceValue,
        newValue
      });
    }
    const errorMessages = (_c = getFullRowEditValidationErrors == null ? void 0 : getFullRowEditValidationErrors({ editorsState })) != null ? _c : [];
    if (errorMessages.length > 0) {
      rowValidationModel.setRowValidation(
        {
          rowNode
        },
        { errorMessages }
      );
    }
  }
  return rowValidationModel;
};
function _createCellEvent(beans, domEvent, eventType, { rowNode, column }, value) {
  const event = _addGridCommonParams(beans.gos, {
    type: eventType,
    node: rowNode,
    data: rowNode.data,
    value,
    column,
    colDef: column.getColDef(),
    rowPinned: rowNode.rowPinned,
    event: domEvent,
    rowIndex: rowNode.rowIndex
  });
  return event;
}
function _isDeleteKey(key, alwaysReturnFalseOnBackspace = false) {
  if (key === KeyCode.DELETE) {
    return true;
  }
  if (!alwaysReturnFalseOnBackspace && key === KeyCode.BACKSPACE) {
    return _isMacOsUserAgent();
  }
  return false;
}
var CellKeyboardListenerFeature = class extends BeanStub {
  constructor(cellCtrl, beans, rowNode, rowCtrl) {
    super();
    this.cellCtrl = cellCtrl;
    this.rowNode = rowNode;
    this.rowCtrl = rowCtrl;
    this.beans = beans;
  }
  init() {
    this.eGui = this.cellCtrl.eGui;
  }
  onKeyDown(event) {
    const key = event.key;
    switch (key) {
      case KeyCode.ENTER:
        this.onEnterKeyDown(event);
        break;
      case KeyCode.F2:
        this.onF2KeyDown(event);
        break;
      case KeyCode.ESCAPE:
        this.onEscapeKeyDown(event);
        break;
      case KeyCode.TAB:
        this.onTabKeyDown(event);
        break;
      case KeyCode.BACKSPACE:
      case KeyCode.DELETE:
        this.onBackspaceOrDeleteKeyDown(key, event);
        break;
      case KeyCode.DOWN:
      case KeyCode.UP:
      case KeyCode.RIGHT:
      case KeyCode.LEFT:
        this.onNavigationKeyDown(event, key);
        break;
    }
  }
  onNavigationKeyDown(event, key) {
    var _a4, _b2;
    const { cellCtrl, beans } = this;
    if ((_a4 = beans.editSvc) == null ? void 0 : _a4.isEditing(cellCtrl, { withOpenEditor: true })) {
      return;
    }
    if (event.shiftKey && cellCtrl.isRangeSelectionEnabled()) {
      this.onShiftRangeSelect(event);
    } else {
      const currentCellPosition = cellCtrl.getFocusedCellPosition();
      (_b2 = beans.navigation) == null ? void 0 : _b2.navigateToNextCell(event, key, currentCellPosition, true);
    }
    event.preventDefault();
  }
  onShiftRangeSelect(event) {
    const { rangeSvc, navigation } = this.beans;
    if (!rangeSvc) {
      return;
    }
    const endCell = rangeSvc.extendLatestRangeInDirection(event);
    if (!endCell) {
      return;
    }
    if (event.key === KeyCode.LEFT || event.key === KeyCode.RIGHT) {
      navigation == null ? void 0 : navigation.ensureColumnVisible(endCell.column);
    } else {
      navigation == null ? void 0 : navigation.ensureRowVisible(endCell.rowIndex);
    }
  }
  onTabKeyDown(event) {
    var _a4;
    (_a4 = this.beans.navigation) == null ? void 0 : _a4.onTabKeyDown(this.cellCtrl, event);
  }
  onBackspaceOrDeleteKeyDown(key, event) {
    var _a4;
    const { cellCtrl, beans, rowNode } = this;
    const { gos, rangeSvc, eventSvc, editSvc } = beans;
    eventSvc.dispatchEvent({ type: "keyShortcutChangedCellStart" });
    if (_isDeleteKey(key, gos.get("enableCellEditingOnBackspace")) && !(editSvc == null ? void 0 : editSvc.isEditing(cellCtrl, { withOpenEditor: true }))) {
      if (rangeSvc && _isCellSelectionEnabled(gos)) {
        rangeSvc.clearCellRangeCellValues({ dispatchWrapperEvents: true, wrapperEventSource: "deleteKey" });
      } else if (cellCtrl.isCellEditable()) {
        const { column } = cellCtrl;
        const emptyValue = this.beans.valueSvc.getDeleteValue(column, rowNode);
        rowNode.setDataValue(column, emptyValue, "cellClear");
      }
    } else if (!(editSvc == null ? void 0 : editSvc.isEditing(cellCtrl, { withOpenEditor: true }))) {
      (_a4 = beans.editSvc) == null ? void 0 : _a4.startEditing(cellCtrl, { startedEdit: true, event });
    }
    eventSvc.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
  }
  onEnterKeyDown(event) {
    var _a4;
    const { cellCtrl, beans } = this;
    const { editSvc, navigation } = beans;
    const cellEditing = editSvc == null ? void 0 : editSvc.isEditing(cellCtrl, { withOpenEditor: true });
    const rowNode = cellCtrl.rowNode;
    const rowEditing = editSvc == null ? void 0 : editSvc.isRowEditing(rowNode, { withOpenEditor: true });
    const startEditingAction = (cellCtrl2) => {
      const started = editSvc == null ? void 0 : editSvc.startEditing(cellCtrl2, {
        startedEdit: true,
        event,
        source: "edit"
      });
      if (started) {
        event.preventDefault();
      }
    };
    if (cellEditing || rowEditing) {
      if (this.isCtrlEnter(event)) {
        editSvc == null ? void 0 : editSvc.applyBulkEdit(cellCtrl, ((_a4 = beans == null ? void 0 : beans.rangeSvc) == null ? void 0 : _a4.getCellRanges()) || []);
        return;
      }
      _populateModelValidationErrors(beans);
      if ((editSvc == null ? void 0 : editSvc.checkNavWithValidation(void 0, event)) === "block-stop") {
        return;
      }
      if (editSvc == null ? void 0 : editSvc.isEditing(cellCtrl, { withOpenEditor: true })) {
        editSvc == null ? void 0 : editSvc.stopEditing(cellCtrl, {
          event,
          source: "edit"
        });
      } else if (rowEditing && !cellCtrl.isCellEditable()) {
        editSvc == null ? void 0 : editSvc.stopEditing({ rowNode }, { event, source: "edit" });
      } else {
        startEditingAction(cellCtrl);
      }
    } else {
      if (beans.gos.get("enterNavigatesVertically")) {
        const key = event.shiftKey ? KeyCode.UP : KeyCode.DOWN;
        navigation == null ? void 0 : navigation.navigateToNextCell(null, key, cellCtrl.cellPosition, false);
      } else {
        if (editSvc == null ? void 0 : editSvc.hasValidationErrors()) {
          return;
        }
        if (editSvc == null ? void 0 : editSvc.hasValidationErrors(cellCtrl)) {
          editSvc.revertSingleCellEdit(cellCtrl, true);
        }
        startEditingAction(cellCtrl);
      }
    }
  }
  isCtrlEnter(e) {
    return (e.ctrlKey || e.metaKey) && e.key === KeyCode.ENTER;
  }
  onF2KeyDown(event) {
    const {
      cellCtrl,
      beans: { editSvc }
    } = this;
    const editing = editSvc == null ? void 0 : editSvc.isEditing();
    if (editing) {
      _populateModelValidationErrors(this.beans);
      if ((editSvc == null ? void 0 : editSvc.checkNavWithValidation(void 0, event)) === "block-stop") {
        return;
      }
    }
    editSvc == null ? void 0 : editSvc.startEditing(cellCtrl, { startedEdit: true, event });
  }
  onEscapeKeyDown(event) {
    const {
      cellCtrl,
      beans: { editSvc }
    } = this;
    if ((editSvc == null ? void 0 : editSvc.checkNavWithValidation(cellCtrl, event)) === "block-stop") {
      editSvc.revertSingleCellEdit(cellCtrl);
    }
    editSvc == null ? void 0 : editSvc.stopEditing(cellCtrl, {
      event,
      cancel: true
    });
  }
  processCharacter(event) {
    var _a4;
    const eventTarget = event.target;
    const eventOnChildComponent = eventTarget !== this.eGui;
    const {
      beans: { editSvc },
      cellCtrl
    } = this;
    if (eventOnChildComponent) {
      return;
    }
    if (editSvc == null ? void 0 : editSvc.isEditing(cellCtrl, { withOpenEditor: true })) {
      return;
    }
    const key = event.key;
    if (key === KeyCode.SPACE) {
      this.onSpaceKeyDown(event);
    } else if (editSvc == null ? void 0 : editSvc.isCellEditable(cellCtrl, "ui")) {
      if ((editSvc == null ? void 0 : editSvc.hasValidationErrors()) && !(editSvc == null ? void 0 : editSvc.hasValidationErrors(cellCtrl))) {
        return;
      }
      editSvc == null ? void 0 : editSvc.startEditing(cellCtrl, { startedEdit: true, event, source: "api" });
      const compDetails = cellCtrl.editCompDetails;
      const shouldPreventDefault = !((_a4 = compDetails == null ? void 0 : compDetails.params) == null ? void 0 : _a4.suppressPreventDefault);
      if (shouldPreventDefault) {
        event.preventDefault();
      }
    }
  }
  onSpaceKeyDown(event) {
    var _a4;
    const { gos, editSvc } = this.beans;
    const { rowNode } = this.cellCtrl;
    if (!(editSvc == null ? void 0 : editSvc.isEditing(this.cellCtrl, { withOpenEditor: true })) && _isRowSelection(gos)) {
      (_a4 = this.beans.selectionSvc) == null ? void 0 : _a4.handleSelectionEvent(event, rowNode, "spaceKey");
    }
    event.preventDefault();
  }
};
var CellMouseListenerFeature = class extends BeanStub {
  constructor(cellCtrl, beans, column) {
    super();
    this.cellCtrl = cellCtrl;
    this.column = column;
    this.beans = beans;
  }
  onMouseEvent(eventName, mouseEvent) {
    if (_isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    switch (eventName) {
      case "click":
        this.onCellClicked(mouseEvent);
        break;
      case "mousedown":
      case "touchstart":
        this.onMouseDown(mouseEvent);
        break;
      case "dblclick":
        this.onCellDoubleClicked(mouseEvent);
        break;
      case "mouseout":
        this.onMouseOut(mouseEvent);
        break;
      case "mouseover":
        this.onMouseOver(mouseEvent);
        break;
    }
  }
  onCellClicked(event) {
    var _a4, _b2, _c;
    if ((_a4 = this.beans.touchSvc) == null ? void 0 : _a4.handleCellDoubleClick(this, event)) {
      return;
    }
    const { eventSvc, rangeSvc, editSvc, editModelSvc, frameworkOverrides, gos } = this.beans;
    const isMultiKey = event.ctrlKey || event.metaKey;
    const { cellCtrl } = this;
    const { column, cellPosition, rowNode } = cellCtrl;
    const suppressMouseEvent2 = _suppressCellMouseEvent(gos, column, rowNode, event);
    if (rangeSvc && isMultiKey && !suppressMouseEvent2) {
      if (rangeSvc.getCellRangeCount(cellPosition) > 1) {
        rangeSvc.intersectLastRange(true);
      }
    }
    const cellClickedEvent = cellCtrl.createEvent(event, "cellClicked");
    cellClickedEvent.isEventHandlingSuppressed = suppressMouseEvent2;
    eventSvc.dispatchEvent(cellClickedEvent);
    const colDef = column.getColDef();
    if (colDef.onCellClicked) {
      window.setTimeout(() => {
        frameworkOverrides.wrapOutgoing(() => {
          colDef.onCellClicked(cellClickedEvent);
        });
      }, 0);
    }
    if (suppressMouseEvent2) {
      return;
    }
    if ((editModelSvc == null ? void 0 : editModelSvc.getState(cellCtrl)) !== "editing") {
      const editing = editSvc == null ? void 0 : editSvc.isEditing();
      const cellValidations = (_b2 = editModelSvc == null ? void 0 : editModelSvc.getCellValidationModel().getCellValidationMap().size) != null ? _b2 : 0;
      const rowValidations = (_c = editModelSvc == null ? void 0 : editModelSvc.getRowValidationModel().getRowValidationMap().size) != null ? _c : 0;
      if (editing && (cellValidations > 0 || rowValidations > 0)) {
        return;
      }
      if (editSvc == null ? void 0 : editSvc.shouldStartEditing(cellCtrl, event)) {
        editSvc == null ? void 0 : editSvc.startEditing(cellCtrl, { event });
      } else if (editSvc == null ? void 0 : editSvc.shouldStopEditing(cellCtrl, event)) {
        if (this.beans.gos.get("editType") === "fullRow") {
          editSvc == null ? void 0 : editSvc.stopEditing(cellCtrl, {
            event,
            source: "edit"
          });
        } else {
          editSvc == null ? void 0 : editSvc.stopEditing(void 0, {
            event,
            source: "edit"
          });
        }
      }
    }
  }
  onCellDoubleClicked(event) {
    var _a4, _b2;
    const { column, beans, cellCtrl } = this;
    const { eventSvc, frameworkOverrides, editSvc, editModelSvc, gos } = beans;
    const suppressMouseEvent2 = _suppressCellMouseEvent(gos, cellCtrl.column, cellCtrl.rowNode, event);
    const colDef = column.getColDef();
    const cellDoubleClickedEvent = cellCtrl.createEvent(
      event,
      "cellDoubleClicked"
    );
    cellDoubleClickedEvent.isEventHandlingSuppressed = suppressMouseEvent2;
    eventSvc.dispatchEvent(cellDoubleClickedEvent);
    if (typeof colDef.onCellDoubleClicked === "function") {
      window.setTimeout(() => {
        frameworkOverrides.wrapOutgoing(() => {
          colDef.onCellDoubleClicked(cellDoubleClickedEvent);
        });
      }, 0);
    }
    if (suppressMouseEvent2) {
      return;
    }
    if ((editSvc == null ? void 0 : editSvc.shouldStartEditing(cellCtrl, event)) && (editModelSvc == null ? void 0 : editModelSvc.getState(cellCtrl)) !== "editing") {
      const editing = editSvc == null ? void 0 : editSvc.isEditing();
      const cellValidations = (_a4 = editModelSvc == null ? void 0 : editModelSvc.getCellValidationModel().getCellValidationMap().size) != null ? _a4 : 0;
      const rowValidations = (_b2 = editModelSvc == null ? void 0 : editModelSvc.getRowValidationModel().getRowValidationMap().size) != null ? _b2 : 0;
      if (editing && (cellValidations > 0 || rowValidations > 0)) {
        return;
      }
      editSvc == null ? void 0 : editSvc.startEditing(cellCtrl, { event });
    }
  }
  onMouseDown(mouseEvent) {
    const { ctrlKey, metaKey, shiftKey } = mouseEvent;
    const target = mouseEvent.target;
    const { cellCtrl, beans } = this;
    const { eventSvc, rangeSvc, rowNumbersSvc, focusSvc, gos, editSvc } = beans;
    const { column, rowNode, cellPosition } = cellCtrl;
    const suppressMouseEvent2 = _suppressCellMouseEvent(gos, column, rowNode, mouseEvent);
    const fireMouseDownEvent = () => {
      const cellMouseDownEvent = cellCtrl.createEvent(mouseEvent, "cellMouseDown");
      cellMouseDownEvent.isEventHandlingSuppressed = suppressMouseEvent2;
      eventSvc.dispatchEvent(cellMouseDownEvent);
    };
    if (suppressMouseEvent2) {
      fireMouseDownEvent();
      return;
    }
    if (this.isRightClickInExistingRange(mouseEvent)) {
      return;
    }
    const hasRanges = rangeSvc && !rangeSvc.isEmpty();
    const containsWidget = this.containsWidget(target);
    const isRowNumberColumn = isRowNumberCol(column);
    if (rowNumbersSvc && isRowNumberColumn && !rowNumbersSvc.handleMouseDownOnCell(cellPosition, mouseEvent)) {
      if (rangeSvc) {
        mouseEvent.preventDefault();
      }
      mouseEvent.stopImmediatePropagation();
      return;
    }
    if (!shiftKey || !hasRanges) {
      const editing = editSvc == null ? void 0 : editSvc.isEditing(cellCtrl);
      const isEnableCellTextSelection = gos.get("enableCellTextSelection");
      const shouldFocus = isEnableCellTextSelection && mouseEvent.defaultPrevented;
      const forceBrowserFocus = (_isBrowserSafari() || shouldFocus) && !editing && !_isFocusableFormField(target) && !containsWidget;
      cellCtrl.focusCell(forceBrowserFocus, mouseEvent);
    }
    if (shiftKey && hasRanges && !focusSvc.isCellFocused(cellPosition)) {
      mouseEvent.preventDefault();
      const focusedCell = focusSvc.getFocusedCell();
      if (focusedCell) {
        const { column: column2, rowIndex, rowPinned } = focusedCell;
        if (editSvc == null ? void 0 : editSvc.isEditing(focusedCell)) {
          editSvc == null ? void 0 : editSvc.stopEditing(focusedCell);
        }
        focusSvc.setFocusedCell({
          column: column2,
          rowIndex,
          rowPinned,
          forceBrowserFocus: true,
          preventScrollOnBrowserFocus: true,
          sourceEvent: mouseEvent
        });
      }
    }
    if (containsWidget) {
      return;
    }
    if (rangeSvc) {
      if (isRowNumberColumn) {
        mouseEvent.preventDefault();
      }
      const hasRightClickedOnRowNumber = _interpretAsRightClick(beans, mouseEvent) && isRowNumberColumn;
      if (shiftKey) {
        rangeSvc.extendLatestRangeToCell(cellPosition);
      } else if (!hasRightClickedOnRowNumber) {
        const isMultiKey = ctrlKey || metaKey;
        rangeSvc.setRangeToCell(cellPosition, isMultiKey);
      }
    }
    fireMouseDownEvent();
  }
  isRightClickInExistingRange(mouseEvent) {
    const { rangeSvc } = this.beans;
    if (rangeSvc) {
      const cellInRange = rangeSvc.isCellInAnyRange(this.cellCtrl.cellPosition);
      const isRightClick = _interpretAsRightClick(this.beans, mouseEvent);
      if (cellInRange && isRightClick) {
        return true;
      }
    }
    return false;
  }
  containsWidget(target) {
    return _isElementChildOfClass(target, "ag-selection-checkbox", 3) || _isElementChildOfClass(target, "ag-drag-handle", 3);
  }
  onMouseOut(mouseEvent) {
    if (this.mouseStayingInsideCell(mouseEvent)) {
      return;
    }
    const { eventSvc, colHover } = this.beans;
    eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, "cellMouseOut"));
    colHover == null ? void 0 : colHover.clearMouseOver();
  }
  onMouseOver(mouseEvent) {
    if (this.mouseStayingInsideCell(mouseEvent)) {
      return;
    }
    const { eventSvc, colHover } = this.beans;
    eventSvc.dispatchEvent(this.cellCtrl.createEvent(mouseEvent, "cellMouseOver"));
    colHover == null ? void 0 : colHover.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget) {
      return false;
    }
    const eCell = this.cellCtrl.eGui;
    const cellContainsTarget = eCell.contains(e.target);
    const cellContainsRelatedTarget = eCell.contains(e.relatedTarget);
    return cellContainsTarget && cellContainsRelatedTarget;
  }
};
var CellPositionFeature = class extends BeanStub {
  constructor(cellCtrl, beans) {
    super();
    this.cellCtrl = cellCtrl;
    this.beans = beans;
    this.column = cellCtrl.column;
    this.rowNode = cellCtrl.rowNode;
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode);
    this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
  }
  init() {
    this.eSetLeft = this.cellCtrl.getRootElement();
    this.eContent = this.cellCtrl.eGui;
    const cellSpan = this.cellCtrl.getCellSpan();
    if (!cellSpan) {
      this.setupColSpan();
      this.setupRowSpan();
    }
    this.onLeftChanged();
    this.onWidthChanged();
    if (!cellSpan) {
      this._legacyApplyRowSpan();
    }
    if (cellSpan) {
      const refreshSpanHeight = this.refreshSpanHeight.bind(this, cellSpan);
      refreshSpanHeight();
      this.addManagedListeners(this.beans.eventSvc, {
        paginationChanged: refreshSpanHeight,
        recalculateRowBounds: refreshSpanHeight,
        pinnedHeightChanged: refreshSpanHeight
      });
    }
  }
  refreshSpanHeight(cellSpan) {
    const spanHeight = cellSpan.getCellHeight();
    if (spanHeight != null) {
      this.eContent.style.height = `${spanHeight}px`;
    }
  }
  onNewColumnsLoaded() {
    const rowSpan = this.column.getRowSpan(this.rowNode);
    if (this.rowSpan === rowSpan) {
      return;
    }
    this.rowSpan = rowSpan;
    this._legacyApplyRowSpan(true);
  }
  onDisplayColumnsChanged() {
    const colsSpanning = this.getColSpanningList();
    if (!_areEqual(this.colsSpanning, colsSpanning)) {
      this.colsSpanning = colsSpanning;
      this.onWidthChanged();
      this.onLeftChanged();
    }
  }
  setupColSpan() {
    if (this.column.getColDef().colSpan == null) {
      return;
    }
    this.colsSpanning = this.getColSpanningList();
    this.addManagedListeners(this.beans.eventSvc, {
      // because we are col spanning, a reorder of the cols can change what cols we are spanning over
      displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
      // because we are spanning over multiple cols, we check for width any time any cols width changes.
      // this is expensive - really we should be explicitly checking only the cols we are spanning over
      // instead of every col, however it would be tricky code to track the cols we are spanning over, so
      // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
      displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
    });
  }
  onWidthChanged() {
    if (!this.eContent) {
      return;
    }
    const width = this.getCellWidth();
    this.eContent.style.width = `${width}px`;
  }
  getCellWidth() {
    if (!this.colsSpanning) {
      return this.column.getActualWidth();
    }
    return this.colsSpanning.reduce((width, col) => width + col.getActualWidth(), 0);
  }
  getColSpanningList() {
    const { column, rowNode } = this;
    const colSpan = column.getColSpan(rowNode);
    const colsSpanning = [];
    if (colSpan === 1) {
      colsSpanning.push(column);
    } else {
      let pointer = column;
      const pinned = column.getPinned();
      for (let i = 0; pointer && i < colSpan; i++) {
        colsSpanning.push(pointer);
        pointer = this.beans.visibleCols.getColAfter(pointer);
        if (!pointer || _missing(pointer)) {
          break;
        }
        if (pinned !== pointer.getPinned()) {
          break;
        }
      }
    }
    return colsSpanning;
  }
  onLeftChanged() {
    if (!this.eSetLeft) {
      return;
    }
    const left = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eSetLeft.style.left = left + "px";
  }
  getCellLeft() {
    let mostLeftCol;
    if (this.beans.gos.get("enableRtl") && this.colsSpanning) {
      mostLeftCol = _last(this.colsSpanning);
    } else {
      mostLeftCol = this.column;
    }
    return mostLeftCol.getLeft();
  }
  modifyLeftForPrintLayout(leftPosition) {
    if (!this.cellCtrl.printLayout || this.column.getPinned() === "left") {
      return leftPosition;
    }
    const { visibleCols } = this.beans;
    const leftWidth = visibleCols.getColsLeftWidth();
    if (this.column.getPinned() === "right") {
      const bodyWidth = visibleCols.bodyWidth;
      return leftWidth + bodyWidth + (leftPosition || 0);
    }
    return leftWidth + (leftPosition || 0);
  }
  _legacyApplyRowSpan(force) {
    if (this.rowSpan === 1 && !force) {
      return;
    }
    const singleRowHeight = _getRowHeightAsNumber(this.beans);
    const totalRowHeight = singleRowHeight * this.rowSpan;
    this.eContent.style.height = `${totalRowHeight}px`;
    this.eContent.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
};
var CSS_CELL = "ag-cell";
var CSS_AUTO_HEIGHT = "ag-cell-auto-height";
var CSS_NORMAL_HEIGHT = "ag-cell-normal-height";
var CSS_CELL_FOCUS = "ag-cell-focus";
var CSS_CELL_FIRST_RIGHT_PINNED = "ag-cell-first-right-pinned";
var CSS_CELL_LAST_LEFT_PINNED = "ag-cell-last-left-pinned";
var CSS_CELL_NOT_INLINE_EDITING = "ag-cell-not-inline-editing";
var CSS_CELL_WRAP_TEXT = "ag-cell-wrap-text";
var instanceIdSequence4 = 0;
var CellCtrl = class extends BeanStub {
  constructor(column, rowNode, beans, rowCtrl) {
    super();
    this.column = column;
    this.rowNode = rowNode;
    this.rowCtrl = rowCtrl;
    this.rangeFeature = void 0;
    this.rowResizeFeature = void 0;
    this.positionFeature = void 0;
    this.customStyleFeature = void 0;
    this.editStyleFeature = void 0;
    this.mouseListener = void 0;
    this.keyboardListener = void 0;
    this.suppressRefreshCell = false;
    this.onCompAttachedFuncs = [];
    this.onEditorAttachedFuncs = [];
    this.focusEventWhileNotReady = null;
    this.hasBeenFocused = false;
    this.hasEdit = false;
    this.tooltipFeature = void 0;
    this.editorTooltipFeature = void 0;
    this.beans = beans;
    this.gos = beans.gos;
    this.editSvc = beans.editSvc;
    this.hasEdit = !!beans.editSvc;
    const { colId } = column;
    this.instanceId = colId + "-" + instanceIdSequence4++;
    this.createCellPosition();
    this.updateAndFormatValue(false);
  }
  addFeatures() {
    var _a4, _b2;
    const { beans } = this;
    this.positionFeature = new CellPositionFeature(this, beans);
    this.customStyleFeature = (_a4 = beans.cellStyles) == null ? void 0 : _a4.createCellCustomStyleFeature(this, beans);
    this.editStyleFeature = (_b2 = beans.editSvc) == null ? void 0 : _b2.createCellStyleFeature(this, beans);
    this.mouseListener = new CellMouseListenerFeature(this, beans, this.column);
    this.keyboardListener = new CellKeyboardListenerFeature(this, beans, this.rowNode, this.rowCtrl);
    this.enableTooltipFeature();
    const { rangeSvc } = beans;
    const cellSelectionEnabled = rangeSvc && _isCellSelectionEnabled(beans.gos);
    if (cellSelectionEnabled) {
      this.rangeFeature = rangeSvc.createCellRangeFeature(beans, this);
    }
    if (isRowNumberCol(this.column)) {
      this.rowResizeFeature = this.beans.rowNumbersSvc.createRowNumbersRowResizerFeature(beans, this);
    }
  }
  isCellSpanning() {
    return false;
  }
  getCellSpan() {
    return void 0;
  }
  removeFeatures() {
    const context = this.beans.context;
    this.positionFeature = context.destroyBean(this.positionFeature);
    this.editorTooltipFeature = context.destroyBean(this.editorTooltipFeature);
    this.customStyleFeature = context.destroyBean(this.customStyleFeature);
    this.editStyleFeature = context.destroyBean(this.editStyleFeature);
    this.mouseListener = context.destroyBean(this.mouseListener);
    this.keyboardListener = context.destroyBean(this.keyboardListener);
    this.rangeFeature = context.destroyBean(this.rangeFeature);
    this.rowResizeFeature = context.destroyBean(this.rowResizeFeature);
    this.disableTooltipFeature();
  }
  enableTooltipFeature(value, shouldDisplayTooltip) {
    var _a4;
    this.tooltipFeature = (_a4 = this.beans.tooltipSvc) == null ? void 0 : _a4.enableCellTooltipFeature(this, value, shouldDisplayTooltip);
  }
  disableTooltipFeature() {
    this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature);
  }
  enableEditorTooltipFeature(editor) {
    var _a4;
    if (this.editorTooltipFeature) {
      this.disableEditorTooltipFeature();
    }
    this.editorTooltipFeature = (_a4 = this.beans.tooltipSvc) == null ? void 0 : _a4.setupCellEditorTooltip(this, editor);
    _populateModelValidationErrors(this.beans);
  }
  disableEditorTooltipFeature() {
    this.editorTooltipFeature = this.beans.context.destroyBean(this.editorTooltipFeature);
  }
  setComp(comp, eCell, _eWrapper, eCellWrapper, printLayout, startEditing, compBean) {
    var _a4, _b2, _c, _d, _e, _f, _g, _h, _i;
    this.comp = comp;
    this.eGui = eCell;
    this.printLayout = printLayout;
    compBean != null ? compBean : compBean = this;
    this.addDomData(compBean);
    this.addFeatures();
    compBean.addDestroyFunc(() => this.removeFeatures());
    this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus"));
    this.setupFocus();
    this.applyStaticCssClasses();
    this.setWrapText();
    this.onFirstRightPinnedChanged();
    this.onLastLeftPinnedChanged();
    this.onColumnHover();
    this.setupControlComps();
    this.setupAutoHeight(eCellWrapper, compBean);
    this.refreshFirstAndLastStyles();
    this.refreshAriaColIndex();
    (_a4 = this.positionFeature) == null ? void 0 : _a4.init();
    (_b2 = this.customStyleFeature) == null ? void 0 : _b2.setComp(comp);
    (_c = this.editStyleFeature) == null ? void 0 : _c.setComp(comp);
    (_d = this.tooltipFeature) == null ? void 0 : _d.refreshTooltip();
    (_e = this.keyboardListener) == null ? void 0 : _e.init();
    (_f = this.rangeFeature) == null ? void 0 : _f.setComp(comp);
    (_g = this.rowResizeFeature) == null ? void 0 : _g.refreshRowResizer();
    if (startEditing && this.isCellEditable() || this.hasEdit && ((_h = this.editSvc) == null ? void 0 : _h.isEditing(this, { withOpenEditor: true }))) {
      (_i = this.editSvc) == null ? void 0 : _i.startEditing(this, {
        startedEdit: false,
        source: "api",
        silent: true,
        continueEditing: true
      });
    } else {
      this.showValue(false, true);
    }
    if (this.onCompAttachedFuncs.length) {
      this.onCompAttachedFuncs.forEach((func) => func());
      this.onCompAttachedFuncs = [];
    }
  }
  setupAutoHeight(eCellWrapper, compBean) {
    var _a4, _b2;
    this.isAutoHeight = (_b2 = (_a4 = this.beans.rowAutoHeight) == null ? void 0 : _a4.setupCellAutoHeight(this, eCellWrapper, compBean)) != null ? _b2 : false;
  }
  getCellAriaRole() {
    var _a4;
    return (_a4 = this.column.getColDef().cellAriaRole) != null ? _a4 : "gridcell";
  }
  isCellRenderer() {
    const colDef = this.column.getColDef();
    return colDef.cellRenderer != null || colDef.cellRendererSelector != null;
  }
  getValueToDisplay() {
    var _a4;
    return (_a4 = this.valueFormatted) != null ? _a4 : this.value;
  }
  getDeferLoadingCellRenderer() {
    var _a4, _b2;
    const { beans, column } = this;
    const { userCompFactory, ctrlsSvc, eventSvc } = beans;
    const colDef = column.getColDef();
    const params = this.createCellRendererParams();
    params.deferRender = true;
    const loadingDetails = _getLoadingCellRendererDetails(userCompFactory, colDef, params);
    if ((_b2 = (_a4 = ctrlsSvc.getGridBodyCtrl()) == null ? void 0 : _a4.scrollFeature) == null ? void 0 : _b2.isScrolling()) {
      let resolver;
      const onReady = new AgPromise((resolve) => {
        resolver = resolve;
      });
      this.addManagedListeners(eventSvc, {
        bodyScrollEnd: () => resolver()
      });
      return { loadingComp: loadingDetails, onReady };
    }
    return { loadingComp: loadingDetails, onReady: AgPromise.resolve() };
  }
  showValue(forceNewCellRendererInstance, skipRangeHandleRefresh) {
    var _a4, _b2, _c, _d;
    const { beans, column, rowNode, rangeFeature } = this;
    const { userCompFactory } = beans;
    let valueToDisplay = this.getValueToDisplay();
    let compDetails;
    const isSsrmLoading = rowNode.stub && ((_a4 = rowNode.groupData) == null ? void 0 : _a4[column.getId()]) == null;
    const colDef = column.getColDef();
    if (isSsrmLoading || this.isCellRenderer()) {
      const params = this.createCellRendererParams();
      if (!isSsrmLoading || isRowNumberCol(column)) {
        compDetails = _getCellRendererDetails(userCompFactory, colDef, params);
      } else {
        compDetails = _getLoadingCellRendererDetails(userCompFactory, colDef, params);
      }
    }
    if (!compDetails && !isSsrmLoading && ((_b2 = beans.findSvc) == null ? void 0 : _b2.isMatch(rowNode, column))) {
      const params = this.createCellRendererParams();
      compDetails = _getCellRendererDetails(
        userCompFactory,
        { ...column.getColDef(), cellRenderer: "agFindCellRenderer" },
        params
      );
    }
    if (this.hasEdit && this.editSvc.isBatchEditing() && this.editSvc.isRowEditing(rowNode, { checkSiblings: true })) {
      const result = this.editSvc.prepDetailsDuringBatch(this, { compDetails, valueToDisplay });
      if (result) {
        if (result.compDetails) {
          compDetails = result.compDetails;
        } else if (result.valueToDisplay) {
          valueToDisplay = result.valueToDisplay;
        }
      }
    }
    this.comp.setRenderDetails(compDetails, valueToDisplay, forceNewCellRendererInstance);
    (_c = this.customRowDragComp) == null ? void 0 : _c.refreshVisibility();
    if (!skipRangeHandleRefresh && rangeFeature) {
      _requestAnimationFrame(beans, () => rangeFeature == null ? void 0 : rangeFeature.refreshHandle());
    }
    (_d = this.rowResizeFeature) == null ? void 0 : _d.refreshRowResizer();
  }
  setupControlComps() {
    const colDef = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(this.isCheckboxSelection(colDef), true);
    this.includeRowDrag = this.isIncludeControl(colDef.rowDrag);
    this.includeDndSource = this.isIncludeControl(colDef.dndSource);
    this.comp.setIncludeSelection(this.includeSelection);
    this.comp.setIncludeDndSource(this.includeDndSource);
    this.comp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
  }
  /**
   * Wrapper providing general conditions under which control elements (e.g. checkboxes and drag handles)
   * are rendered for a particular cell.
   * @param value Whether to render the control in the specific context of the caller
   * @param allowManuallyPinned Whether manually pinned rows are permitted this form of control element
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  isIncludeControl(value, allowManuallyPinned = false) {
    const rowUnpinned = this.rowNode.rowPinned == null;
    return (rowUnpinned || allowManuallyPinned && _isManualPinnedRow(this.rowNode)) && !!value;
  }
  isCheckboxSelection(colDef) {
    const { rowSelection, groupDisplayType } = this.beans.gridOptions;
    const checkboxLocation = _getCheckboxLocation(rowSelection);
    const isSelectionColumn = isColumnSelectionCol(this.column);
    if (groupDisplayType === "custom" && checkboxLocation !== "selectionColumn" && isSelectionColumn) {
      return false;
    }
    return colDef.checkboxSelection || isSelectionColumn && typeof rowSelection === "object" && _getCheckboxes(rowSelection);
  }
  refreshShouldDestroy() {
    const colDef = this.column.getColDef();
    const selectionChanged = this.includeSelection != this.isIncludeControl(this.isCheckboxSelection(colDef), true);
    const rowDragChanged = this.includeRowDrag != this.isIncludeControl(colDef.rowDrag);
    const dndSourceChanged = this.includeDndSource != this.isIncludeControl(colDef.dndSource);
    const autoHeightChanged = this.isAutoHeight != this.column.isAutoHeight();
    return selectionChanged || rowDragChanged || dndSourceChanged || autoHeightChanged;
  }
  onPopupEditorClosed() {
    const { editSvc } = this.beans;
    if (!(editSvc == null ? void 0 : editSvc.isEditing(this, { withOpenEditor: true }))) {
      return;
    }
    editSvc == null ? void 0 : editSvc.stopEditing(this, { source: (editSvc == null ? void 0 : editSvc.isBatchEditing()) ? "ui" : "api" });
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(cancel = false) {
    var _a4;
    const { editSvc } = this.beans;
    return (_a4 = editSvc == null ? void 0 : editSvc.stopEditing(this, { cancel, source: (editSvc == null ? void 0 : editSvc.isBatchEditing()) ? "ui" : "api" })) != null ? _a4 : false;
  }
  createCellRendererParams() {
    const {
      value,
      valueFormatted,
      column,
      rowNode,
      comp,
      eGui,
      beans: { valueSvc, gos, editSvc }
    } = this;
    const res = _addGridCommonParams(gos, {
      value,
      valueFormatted,
      getValue: () => valueSvc.getValueForDisplay(column, rowNode).value,
      setValue: (value2) => (editSvc == null ? void 0 : editSvc.setDataValue({ rowNode, column }, value2)) || rowNode.setDataValue(column, value2),
      formatValue: this.formatValue.bind(this),
      data: rowNode.data,
      node: rowNode,
      pinned: column.getPinned(),
      colDef: column.getColDef(),
      column,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: eGui,
      eParentOfValue: comp.getParentOfValue(),
      registerRowDragger: (rowDraggerElement, dragStartPixels, value2, suppressVisibilityChange) => this.registerRowDragger(rowDraggerElement, dragStartPixels, suppressVisibilityChange),
      setTooltip: (value2, shouldDisplayTooltip) => {
        var _a4;
        gos.assertModuleRegistered("Tooltip", 3);
        if (this.tooltipFeature) {
          this.disableTooltipFeature();
        }
        this.enableTooltipFeature(value2, shouldDisplayTooltip);
        (_a4 = this.tooltipFeature) == null ? void 0 : _a4.refreshTooltip();
      }
    });
    return res;
  }
  onCellChanged(event) {
    const eventImpactsThisCell = event.column === this.column;
    if (eventImpactsThisCell) {
      this.refreshCell({});
    }
  }
  refreshOrDestroyCell(params) {
    var _a4;
    if (this.refreshShouldDestroy()) {
      (_a4 = this.rowCtrl) == null ? void 0 : _a4.recreateCell(this);
    } else {
      this.refreshCell(params);
    }
    if (this.hasEdit && this.editCompDetails) {
      const { editSvc, comp } = this;
      if (!(comp == null ? void 0 : comp.getCellEditor()) && editSvc.isEditing(this, { withOpenEditor: true })) {
        editSvc.startEditing(this, { startedEdit: false, source: "api", silent: true });
      }
    }
  }
  // + stop editing {force: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell({ force, suppressFlash, newData } = {}) {
    var _a4, _b2, _c, _d, _e, _f, _g, _h;
    if (this.suppressRefreshCell) {
      return;
    }
    const colDef = this.column.getColDef();
    const noValueProvided = colDef.field == null && colDef.valueGetter == null && colDef.showRowGroup == null;
    const forceRefresh = force || noValueProvided || newData;
    const isCellCompReady = !!this.comp;
    const valuesDifferent = this.updateAndFormatValue(isCellCompReady);
    const dataNeedsUpdating = forceRefresh || valuesDifferent;
    if (!isCellCompReady) {
      return;
    }
    if (dataNeedsUpdating) {
      this.showValue(!!newData, false);
      const processingFilterChange = (_a4 = this.beans.filterManager) == null ? void 0 : _a4.isSuppressFlashingCellsBecauseFiltering();
      const flashCell = !suppressFlash && !processingFilterChange && colDef.enableCellChangeFlash;
      if (flashCell) {
        (_b2 = this.beans.cellFlashSvc) == null ? void 0 : _b2.flashCell(this);
      }
      (_d = (_c = this.editStyleFeature) == null ? void 0 : _c.applyCellStyles) == null ? void 0 : _d.call(_c);
      (_e = this.customStyleFeature) == null ? void 0 : _e.applyUserStyles();
      (_f = this.customStyleFeature) == null ? void 0 : _f.applyClassesFromColDef();
    }
    (_g = this.tooltipFeature) == null ? void 0 : _g.refreshTooltip();
    (_h = this.customStyleFeature) == null ? void 0 : _h.applyCellClassRules();
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  formatValue(value) {
    var _a4;
    return (_a4 = this.callValueFormatter(value)) != null ? _a4 : value;
  }
  callValueFormatter(value) {
    return this.beans.valueSvc.formatValue(this.column, this.rowNode, value);
  }
  updateAndFormatValue(compareValues) {
    const oldValue = this.value;
    const oldValueFormatted = this.valueFormatted;
    const { value, valueFormatted } = this.beans.valueSvc.getValueForDisplay(this.column, this.rowNode, true);
    this.value = value;
    this.valueFormatted = valueFormatted;
    if (compareValues) {
      return !this.valuesAreEqual(oldValue, this.value) || this.valueFormatted != oldValueFormatted;
    }
    return true;
  }
  valuesAreEqual(val1, val2) {
    const colDef = this.column.getColDef();
    return colDef.equals ? colDef.equals(val1, val2) : val1 === val2;
  }
  addDomData(compBean) {
    const element = this.eGui;
    _setDomData(this.beans.gos, element, DOM_DATA_KEY_CELL_CTRL, this);
    compBean.addDestroyFunc(() => _setDomData(this.beans.gos, element, DOM_DATA_KEY_CELL_CTRL, null));
  }
  createEvent(domEvent, eventType) {
    const { rowNode, column, value, beans } = this;
    return _createCellEvent(beans, domEvent, eventType, { rowNode, column }, value);
  }
  processCharacter(event) {
    var _a4;
    (_a4 = this.keyboardListener) == null ? void 0 : _a4.processCharacter(event);
  }
  onKeyDown(event) {
    var _a4;
    (_a4 = this.keyboardListener) == null ? void 0 : _a4.onKeyDown(event);
  }
  onMouseEvent(eventName, mouseEvent) {
    var _a4;
    (_a4 = this.mouseListener) == null ? void 0 : _a4.onMouseEvent(eventName, mouseEvent);
  }
  getColSpanningList() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.positionFeature) == null ? void 0 : _a4.getColSpanningList()) != null ? _b2 : [];
  }
  onLeftChanged() {
    var _a4;
    if (!this.comp) {
      return;
    }
    (_a4 = this.positionFeature) == null ? void 0 : _a4.onLeftChanged();
  }
  onDisplayedColumnsChanged() {
    if (!this.eGui) {
      return;
    }
    this.refreshAriaColIndex();
    this.refreshFirstAndLastStyles();
  }
  refreshFirstAndLastStyles() {
    const { comp, column, beans } = this;
    refreshFirstAndLastStyles(comp, column, beans.visibleCols);
  }
  refreshAriaColIndex() {
    const colIdx = this.beans.visibleCols.getAriaColIndex(this.column);
    _setAriaColIndex(this.eGui, colIdx);
  }
  onWidthChanged() {
    var _a4;
    return (_a4 = this.positionFeature) == null ? void 0 : _a4.onWidthChanged();
  }
  getRowPosition() {
    const { rowIndex, rowPinned } = this.cellPosition;
    return {
      rowIndex,
      rowPinned
    };
  }
  updateRangeBordersIfRangeCount() {
    var _a4;
    if (!this.comp) {
      return;
    }
    (_a4 = this.rangeFeature) == null ? void 0 : _a4.updateRangeBordersIfRangeCount();
  }
  onCellSelectionChanged() {
    var _a4;
    if (!this.comp) {
      return;
    }
    (_a4 = this.rangeFeature) == null ? void 0 : _a4.onCellSelectionChanged();
  }
  isRangeSelectionEnabled() {
    return this.rangeFeature != null;
  }
  focusCell(forceBrowserFocus = false, sourceEvent) {
    var _a4;
    const allowedTarget = (_a4 = this.editSvc) == null ? void 0 : _a4.allowedFocusTargetOnValidation(this);
    if (allowedTarget && allowedTarget !== this) {
      return;
    }
    this.beans.focusSvc.setFocusedCell({
      ...this.getFocusedCellPosition(),
      forceBrowserFocus,
      sourceEvent
    });
  }
  /**
   * Restores focus to the cell, if it should have it
   * @param waitForRender if the cell has just setComp, it may not be rendered yet, so we wait for the next render
   */
  restoreFocus(waitForRender = false) {
    const {
      beans: { editSvc, focusSvc },
      comp
    } = this;
    if (!comp || (editSvc == null ? void 0 : editSvc.isEditing(this)) || !this.isCellFocused() || !focusSvc.shouldTakeFocus()) {
      return;
    }
    const focus = () => {
      if (!this.isAlive()) {
        return;
      }
      const focusableElement = comp.getFocusableElement();
      if (this.isCellFocused()) {
        focusableElement.focus({ preventScroll: true });
      }
    };
    if (waitForRender) {
      setTimeout(focus, 0);
      return;
    }
    focus();
  }
  onRowIndexChanged() {
    var _a4, _b2;
    this.createCellPosition();
    this.onCellFocused();
    this.restoreFocus();
    (_a4 = this.rangeFeature) == null ? void 0 : _a4.onCellSelectionChanged();
    (_b2 = this.rowResizeFeature) == null ? void 0 : _b2.refreshRowResizer();
  }
  onSuppressCellFocusChanged(suppressCellFocus) {
    const element = this.eGui;
    if (!element) {
      return;
    }
    if (isRowNumberCol(this.column)) {
      suppressCellFocus = true;
    }
    _addOrRemoveAttribute(element, "tabindex", suppressCellFocus ? void 0 : -1);
  }
  onFirstRightPinnedChanged() {
    if (!this.comp) {
      return;
    }
    const firstRightPinned = this.column.isFirstRightPinned();
    this.comp.toggleCss(CSS_CELL_FIRST_RIGHT_PINNED, firstRightPinned);
  }
  onLastLeftPinnedChanged() {
    if (!this.comp) {
      return;
    }
    const lastLeftPinned = this.column.isLastLeftPinned();
    this.comp.toggleCss(CSS_CELL_LAST_LEFT_PINNED, lastLeftPinned);
  }
  /**
   * Returns whether cell is focused by the focusSvc, overridden by spannedCellCtrl
   */
  checkCellFocused() {
    return this.beans.focusSvc.isCellFocused(this.cellPosition);
  }
  isCellFocused() {
    const isFocused = this.checkCellFocused();
    this.hasBeenFocused || (this.hasBeenFocused = isFocused);
    return isFocused;
  }
  setupFocus() {
    var _a4;
    this.restoreFocus(true);
    this.onCellFocused((_a4 = this.focusEventWhileNotReady) != null ? _a4 : void 0);
  }
  onCellFocused(event) {
    var _a4, _b2;
    const { beans } = this;
    if (_isCellFocusSuppressed(beans)) {
      return;
    }
    if (!this.comp) {
      if (event) {
        this.focusEventWhileNotReady = event;
      }
      return;
    }
    const cellFocused = this.isCellFocused();
    const editing = (_b2 = (_a4 = beans.editSvc) == null ? void 0 : _a4.isEditing(this)) != null ? _b2 : false;
    this.comp.toggleCss(CSS_CELL_FOCUS, cellFocused);
    if (cellFocused && event && event.forceBrowserFocus) {
      let focusEl = this.comp.getFocusableElement();
      if (editing) {
        const focusableEls = _findFocusableElements(focusEl, null, true);
        if (focusableEls.length) {
          focusEl = focusableEls[0];
        }
      }
      focusEl.focus({ preventScroll: !!event.preventScrollOnBrowserFocus });
    }
    if (cellFocused) {
      this.rowCtrl.announceDescription();
    }
  }
  createCellPosition() {
    const { rowIndex, rowPinned } = this.rowNode;
    this.cellPosition = {
      rowIndex,
      rowPinned: _makeNull(rowPinned),
      column: this.column
    };
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    const { comp } = this;
    comp.toggleCss(CSS_CELL, true);
    comp.toggleCss(CSS_CELL_NOT_INLINE_EDITING, true);
    const autoHeight = this.column.isAutoHeight() == true;
    comp.toggleCss(CSS_AUTO_HEIGHT, autoHeight);
    comp.toggleCss(CSS_NORMAL_HEIGHT, !autoHeight);
  }
  onColumnHover() {
    var _a4;
    (_a4 = this.beans.colHover) == null ? void 0 : _a4.onCellColumnHover(this.column, this.comp);
  }
  onColDefChanged() {
    var _a4, _b2;
    if (!this.comp) {
      return;
    }
    if (this.column.isTooltipEnabled()) {
      this.disableTooltipFeature();
      this.enableTooltipFeature();
    } else {
      this.disableTooltipFeature();
    }
    this.setWrapText();
    if ((_a4 = this.editSvc) == null ? void 0 : _a4.isEditing(this)) {
      (_b2 = this.editSvc) == null ? void 0 : _b2.handleColDefChanged(this);
    } else {
      this.refreshOrDestroyCell({ force: true, suppressFlash: true });
    }
  }
  setWrapText() {
    const value = this.column.getColDef().wrapText == true;
    this.comp.toggleCss(CSS_CELL_WRAP_TEXT, value);
  }
  dispatchCellContextMenuEvent(event) {
    const colDef = this.column.getColDef();
    const cellContextMenuEvent = this.createEvent(event, "cellContextMenu");
    const { beans } = this;
    beans.eventSvc.dispatchEvent(cellContextMenuEvent);
    if (colDef.onCellContextMenu) {
      window.setTimeout(() => {
        beans.frameworkOverrides.wrapOutgoing(() => {
          colDef.onCellContextMenu(cellContextMenuEvent);
        });
      }, 0);
    }
  }
  getCellRenderer() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.comp) == null ? void 0 : _a4.getCellRenderer()) != null ? _b2 : null;
  }
  destroy() {
    this.onCompAttachedFuncs = [];
    this.onEditorAttachedFuncs = [];
    if (this.isCellFocused() && this.hasBrowserFocus()) {
      this.beans.focusSvc.attemptToRecoverFocus();
    }
    super.destroy();
  }
  hasBrowserFocus() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.eGui) == null ? void 0 : _a4.contains(_getActiveDomElement(this.beans))) != null ? _b2 : false;
  }
  createSelectionCheckbox() {
    var _a4;
    const cbSelectionComponent = (_a4 = this.beans.selectionSvc) == null ? void 0 : _a4.createCheckboxSelectionComponent();
    if (!cbSelectionComponent) {
      return void 0;
    }
    this.beans.context.createBean(cbSelectionComponent);
    cbSelectionComponent.init({ rowNode: this.rowNode, column: this.column });
    return cbSelectionComponent;
  }
  createDndSource() {
    const dndSourceComp = this.beans.registry.createDynamicBean(
      "dndSourceComp",
      false,
      this.rowNode,
      this.column,
      this.eGui
    );
    if (dndSourceComp) {
      this.beans.context.createBean(dndSourceComp);
    }
    return dndSourceComp;
  }
  registerRowDragger(customElement, dragStartPixels, alwaysVisible) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(customElement, dragStartPixels);
      return;
    }
    const newComp = this.createRowDragComp(customElement, dragStartPixels, alwaysVisible);
    if (newComp) {
      this.customRowDragComp = newComp;
      this.addDestroyFunc(() => {
        this.beans.context.destroyBean(newComp);
        this.customRowDragComp = null;
      });
      newComp.refreshVisibility();
    }
  }
  createRowDragComp(customElement, dragStartPixels, alwaysVisible) {
    var _a4;
    const rowDragComp = (_a4 = this.beans.rowDragSvc) == null ? void 0 : _a4.createRowDragCompForCell(
      this.rowNode,
      this.column,
      () => this.value,
      customElement,
      dragStartPixels,
      alwaysVisible
    );
    if (!rowDragComp) {
      return void 0;
    }
    this.beans.context.createBean(rowDragComp);
    return rowDragComp;
  }
  cellEditorAttached() {
    this.onEditorAttachedFuncs.forEach((func) => func());
    this.onEditorAttachedFuncs = [];
  }
  setFocusedCellPosition(_cellPosition) {
  }
  getFocusedCellPosition() {
    return this.cellPosition;
  }
  // used by spannedCellCtrl
  refreshAriaRowIndex() {
  }
  /**
   * Returns the root element of the cell, could be a span container rather than the cell element.
   * @returns The root element of the cell.
   */
  getRootElement() {
    return this.eGui;
  }
};
function calculateRowLevel(rowNode) {
  if (rowNode.group) {
    return rowNode.level;
  }
  const parent = rowNode.parent;
  return parent ? parent.level + 1 : 0;
}
var instanceIdSequence5 = 0;
var RowCtrl = class extends BeanStub {
  constructor(rowNode, beans, animateIn, useAnimationFrameForCreate, printLayout) {
    var _a4, _b2, _c;
    super();
    this.rowNode = rowNode;
    this.useAnimationFrameForCreate = useAnimationFrameForCreate;
    this.printLayout = printLayout;
    this.allRowGuis = [];
    this.active = true;
    this.centerCellCtrls = { list: [], map: {} };
    this.leftCellCtrls = { list: [], map: {} };
    this.rightCellCtrls = { list: [], map: {} };
    this.slideInAnimation = {
      left: false,
      center: false,
      right: false,
      fullWidth: false
    };
    this.fadeInAnimation = {
      left: false,
      center: false,
      right: false,
      fullWidth: false
    };
    this.rowDragComps = [];
    this.lastMouseDownOnDragger = false;
    this.emptyStyle = {};
    this.updateColumnListsPending = false;
    this.rowId = null;
    this.businessKey = null;
    this.beans = beans;
    this.gos = beans.gos;
    this.paginationPage = (_b2 = (_a4 = beans.pagination) == null ? void 0 : _a4.getCurrentPage()) != null ? _b2 : 0;
    this.suppressRowTransform = this.gos.get("suppressRowTransform");
    this.instanceId = rowNode.id + "-" + instanceIdSequence5++;
    this.rowId = _escapeString(rowNode.id);
    this.initRowBusinessKey();
    this.rowFocused = beans.focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    this.rowLevel = calculateRowLevel(this.rowNode);
    this.setRowType();
    this.setAnimateFlags(animateIn);
    this.rowStyles = this.processStylesFromGridOptions();
    this.rowEditStyleFeature = (_c = beans.editSvc) == null ? void 0 : _c.createRowStyleFeature(this, beans);
    this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode");
    this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc !== "function") {
      return;
    }
    const businessKey = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKey = _escapeString(businessKey);
  }
  updateGui(containerType, gui) {
    if (containerType === "left") {
      this.leftGui = gui;
    } else if (containerType === "right") {
      this.rightGui = gui;
    } else if (containerType === "fullWidth") {
      this.fullWidthGui = gui;
    } else {
      this.centerGui = gui;
    }
  }
  setComp(rowComp, element, containerType, compBean) {
    var _a4, _b2;
    const { context, focusSvc } = this.beans;
    compBean = setupCompBean(this, context, compBean);
    const gui = { rowComp, element, containerType, compBean };
    this.allRowGuis.push(gui);
    this.updateGui(containerType, gui);
    this.initialiseRowComp(gui);
    const rowNode = this.rowNode;
    const isSsrmLoadingRow = this.rowType === "FullWidthLoading" || rowNode.stub;
    const isIrmLoadingRow = !rowNode.data && this.beans.rowModel.getType() === "infinite";
    if (!isSsrmLoadingRow && !isIrmLoadingRow && !rowNode.rowPinned) {
      this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
    }
    const focusableElement = (_a4 = this.fullWidthGui) == null ? void 0 : _a4.element;
    if (focusableElement) {
      const editing = (_b2 = this.beans.editSvc) == null ? void 0 : _b2.isEditing(this);
      if (!editing && focusSvc.isRowFocused(rowNode.rowIndex, rowNode.rowPinned) && focusSvc.shouldTakeFocus()) {
        setTimeout(() => focusableElement.focus({ preventScroll: true }), 0);
      }
    }
  }
  unsetComp(containerType) {
    this.allRowGuis = this.allRowGuis.filter((rowGui) => rowGui.containerType !== containerType);
    this.updateGui(containerType, void 0);
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(cached) {
    const displayValue = cached ? "none" : "";
    this.allRowGuis.forEach((rg) => rg.element.style.display = displayValue);
  }
  initialiseRowComp(gui) {
    const gos = this.gos;
    this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus"));
    this.listenOnDomOrder(gui);
    this.onRowHeightChanged(gui);
    this.updateRowIndexes(gui);
    this.setFocusedClasses(gui);
    this.setStylesFromGridOptions(false, gui);
    if (_isRowSelection(gos) && this.rowNode.selectable) {
      this.onRowSelected(gui);
    }
    this.updateColumnLists(!this.useAnimationFrameForCreate);
    const comp = gui.rowComp;
    const initialRowClasses = this.getInitialRowClasses(gui.containerType);
    initialRowClasses.forEach((name) => comp.toggleCss(name, true));
    this.executeSlideAndFadeAnimations(gui);
    if (this.rowNode.group) {
      _setAriaExpanded(gui.element, this.rowNode.expanded == true);
    }
    this.setRowCompRowId(comp);
    this.setRowCompRowBusinessKey(comp);
    _setDomData(gos, gui.element, DOM_DATA_KEY_ROW_CTRL, this);
    gui.compBean.addDestroyFunc(() => _setDomData(gos, gui.element, DOM_DATA_KEY_ROW_CTRL, null));
    if (this.useAnimationFrameForCreate) {
      this.beans.animationFrameSvc.createTask(
        this.addHoverFunctionality.bind(this, gui),
        this.rowNode.rowIndex,
        "p2",
        false
      );
    } else {
      this.addHoverFunctionality(gui);
    }
    if (this.isFullWidth()) {
      this.setupFullWidth(gui);
    }
    if (gos.get("rowDragEntireRow")) {
      this.addRowDraggerToRow(gui);
    }
    if (this.useAnimationFrameForCreate) {
      this.beans.animationFrameSvc.addDestroyTask(() => {
        if (!this.isAlive()) {
          return;
        }
        gui.rowComp.toggleCss("ag-after-created", true);
      });
    }
    this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(comp) {
    if (this.businessKey == null) {
      return;
    }
    comp.setRowBusinessKey(this.businessKey);
  }
  setRowCompRowId(comp) {
    const rowId = _escapeString(this.rowNode.id);
    this.rowId = rowId;
    if (rowId == null) {
      return;
    }
    comp.setRowId(rowId);
  }
  executeSlideAndFadeAnimations(gui) {
    const { containerType } = gui;
    const shouldSlide = this.slideInAnimation[containerType];
    if (shouldSlide) {
      _batchCall(() => {
        this.onTopChanged();
      });
      this.slideInAnimation[containerType] = false;
    }
    const shouldFade = this.fadeInAnimation[containerType];
    if (shouldFade) {
      _batchCall(() => {
        gui.rowComp.toggleCss("ag-opacity-zero", false);
      });
      this.fadeInAnimation[containerType] = false;
    }
  }
  addRowDraggerToRow(gui) {
    var _a4;
    const rowDragComp = (_a4 = this.beans.rowDragSvc) == null ? void 0 : _a4.createRowDragCompForRow(this.rowNode, gui.element);
    if (!rowDragComp) {
      return;
    }
    const rowDragBean = this.createBean(rowDragComp, this.beans.context);
    this.rowDragComps.push(rowDragBean);
    gui.compBean.addDestroyFunc(() => {
      this.rowDragComps = this.rowDragComps.filter((r) => r !== rowDragBean);
      this.rowEditStyleFeature = this.destroyBean(this.rowEditStyleFeature, this.beans.context);
      this.destroyBean(rowDragBean, this.beans.context);
    });
  }
  setupFullWidth(gui) {
    const pinned = this.getPinnedForContainer(gui.containerType);
    const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
    gui.rowComp.showFullWidth(compDetails);
  }
  getFullWidthCellRenderers() {
    var _a4, _b2;
    if (this.gos.get("embedFullWidthRows")) {
      return this.allRowGuis.map((gui) => {
        var _a5;
        return (_a5 = gui == null ? void 0 : gui.rowComp) == null ? void 0 : _a5.getFullWidthCellRenderer();
      });
    }
    return [(_b2 = (_a4 = this.fullWidthGui) == null ? void 0 : _a4.rowComp) == null ? void 0 : _b2.getFullWidthCellRenderer()];
  }
  executeProcessRowPostCreateFunc() {
    const func = this.gos.getCallback("processRowPostCreate");
    if (!func || !this.areAllContainersReady()) {
      return;
    }
    const params = {
      // areAllContainersReady asserts that centerGui is not null
      eRow: this.centerGui.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    func(params);
  }
  areAllContainersReady() {
    const {
      leftGui,
      centerGui,
      rightGui,
      beans: { visibleCols }
    } = this;
    const isLeftReady = !!leftGui || !visibleCols.isPinningLeft();
    const isCenterReady = !!centerGui;
    const isRightReady = !!rightGui || !visibleCols.isPinningRight();
    return isLeftReady && isCenterReady && isRightReady;
  }
  isNodeFullWidthCell() {
    if (this.rowNode.detail) {
      return true;
    }
    const isFullWidthCellFunc = this.beans.gos.getCallback("isFullWidthRow");
    return isFullWidthCellFunc ? isFullWidthCellFunc({ rowNode: this.rowNode }) : false;
  }
  setRowType() {
    const isStub = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow") && !this.gos.get("groupHideOpenParents");
    const isFullWidthCell = this.isNodeFullWidthCell();
    const isDetailCell = this.gos.get("masterDetail") && this.rowNode.detail;
    const pivotMode = this.beans.colModel.isPivotMode();
    const isFullWidthGroup = _isFullWidthGroupRow(this.gos, this.rowNode, pivotMode);
    if (isStub) {
      this.rowType = "FullWidthLoading";
    } else if (isDetailCell) {
      this.rowType = "FullWidthDetail";
    } else if (isFullWidthCell) {
      this.rowType = "FullWidth";
    } else if (isFullWidthGroup) {
      this.rowType = "FullWidthGroup";
    } else {
      this.rowType = "Normal";
    }
  }
  updateColumnLists(suppressAnimationFrame = false, useFlushSync = false) {
    if (this.isFullWidth()) {
      return;
    }
    const { animationFrameSvc } = this.beans;
    const noAnimation = !(animationFrameSvc == null ? void 0 : animationFrameSvc.active) || suppressAnimationFrame || this.printLayout;
    if (noAnimation) {
      this.updateColumnListsImpl(useFlushSync);
      return;
    }
    if (this.updateColumnListsPending) {
      return;
    }
    animationFrameSvc.createTask(
      () => {
        if (!this.active) {
          return;
        }
        this.updateColumnListsImpl(true);
      },
      this.rowNode.rowIndex,
      "p1",
      false
    );
    this.updateColumnListsPending = true;
  }
  /**
   * Overridden by SpannedRowCtrl
   */
  getNewCellCtrl(col) {
    var _a4;
    const isCellSpan = (_a4 = this.beans.rowSpanSvc) == null ? void 0 : _a4.isCellSpanning(col, this.rowNode);
    if (isCellSpan) {
      return void 0;
    }
    return new CellCtrl(col, this.rowNode, this.beans, this);
  }
  /**
   * Overridden by SpannedRowCtrl, if span context changes cell needs rebuilt
   */
  isCorrectCtrlForSpan(cell) {
    var _a4;
    return !((_a4 = this.beans.rowSpanSvc) == null ? void 0 : _a4.isCellSpanning(cell.column, this.rowNode));
  }
  createCellCtrls(prev, cols, pinned = null) {
    const res = {
      list: [],
      map: {}
    };
    const addCell = (colInstanceId, cellCtrl, index) => {
      if (index != null) {
        res.list.splice(index, 0, cellCtrl);
      } else {
        res.list.push(cellCtrl);
      }
      res.map[colInstanceId] = cellCtrl;
    };
    const colsFromPrev = [];
    for (const col of cols) {
      const colInstanceId = col.getInstanceId();
      let cellCtrl = prev.map[colInstanceId];
      if (cellCtrl && !this.isCorrectCtrlForSpan(cellCtrl)) {
        cellCtrl.destroy();
        cellCtrl = void 0;
      }
      if (!cellCtrl) {
        cellCtrl = this.getNewCellCtrl(col);
      }
      if (!cellCtrl) {
        continue;
      }
      addCell(colInstanceId, cellCtrl);
    }
    for (const prevCellCtrl of prev.list) {
      const colInstanceId = prevCellCtrl.column.getInstanceId();
      const cellInResult = res.map[colInstanceId] != null;
      if (cellInResult) {
        continue;
      }
      const keepCell = !this.isCellEligibleToBeRemoved(prevCellCtrl, pinned);
      if (keepCell) {
        colsFromPrev.push([colInstanceId, prevCellCtrl]);
      } else {
        prevCellCtrl.destroy();
      }
    }
    if (colsFromPrev.length) {
      for (const [colInstanceId, cellCtrl] of colsFromPrev) {
        const index = res.list.findIndex((ctrl) => ctrl.column.getLeft() > cellCtrl.column.getLeft());
        const normalisedIndex = index === -1 ? void 0 : Math.max(index - 1, 0);
        addCell(colInstanceId, cellCtrl, normalisedIndex);
      }
    }
    const { focusSvc, visibleCols } = this.beans;
    const focusedCell = focusSvc.getFocusedCell();
    if (focusedCell && focusedCell.column.getPinned() == pinned) {
      const focusedColInstanceId = focusedCell.column.getInstanceId();
      const focusedCellCtrl = res.map[focusedColInstanceId];
      if (!focusedCellCtrl && visibleCols.allCols.includes(focusedCell.column)) {
        const cellCtrl = this.createFocusedCellCtrl();
        if (cellCtrl) {
          const index = res.list.findIndex((ctrl) => ctrl.column.getLeft() > cellCtrl.column.getLeft());
          const normalisedIndex = index === -1 ? void 0 : Math.max(index - 1, 0);
          addCell(focusedColInstanceId, cellCtrl, normalisedIndex);
        }
      }
    }
    return res;
  }
  /**
   * Creates a new cell ctrl for the focused cell, if this is the correct row ctrl.
   * @returns a CellCtrl for the focused cell, if required.
   */
  createFocusedCellCtrl() {
    const { focusSvc, rowSpanSvc } = this.beans;
    const focusedCell = focusSvc.getFocusedCell();
    if (!focusedCell) {
      return void 0;
    }
    const focusedSpan = rowSpanSvc == null ? void 0 : rowSpanSvc.getCellSpan(focusedCell.column, this.rowNode);
    if (focusedSpan) {
      if (focusedSpan.firstNode !== this.rowNode || !focusedSpan.doesSpanContain(focusedCell)) {
        return void 0;
      }
    } else {
      if (!focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned)) {
        return void 0;
      }
    }
    return this.getNewCellCtrl(focusedCell.column);
  }
  updateColumnListsImpl(useFlushSync) {
    this.updateColumnListsPending = false;
    this.createAllCellCtrls();
    this.setCellCtrls(useFlushSync);
  }
  setCellCtrls(useFlushSync) {
    this.allRowGuis.forEach((item) => {
      const cellControls = this.getCellCtrlsForContainer(item.containerType);
      item.rowComp.setCellCtrls(cellControls, useFlushSync);
    });
  }
  getCellCtrlsForContainer(containerType) {
    switch (containerType) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
    }
  }
  createAllCellCtrls() {
    const colViewport = this.beans.colViewport;
    const presentedColsService = this.beans.visibleCols;
    if (this.printLayout) {
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, presentedColsService.allCols);
      this.leftCellCtrls = { list: [], map: {} };
      this.rightCellCtrls = { list: [], map: {} };
    } else {
      const centerCols = colViewport.getColsWithinViewport(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, centerCols);
      const leftCols = presentedColsService.getLeftColsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, leftCols, "left");
      const rightCols = presentedColsService.getRightColsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, rightCols, "right");
    }
  }
  isCellEligibleToBeRemoved(cellCtrl, nextContainerPinned) {
    const REMOVE_CELL = true;
    const KEEP_CELL = false;
    const { column } = cellCtrl;
    if (column.getPinned() != nextContainerPinned) {
      return REMOVE_CELL;
    }
    if (!this.isCorrectCtrlForSpan(cellCtrl)) {
      return REMOVE_CELL;
    }
    const { visibleCols, editSvc } = this.beans;
    const editing = editSvc == null ? void 0 : editSvc.isEditing(cellCtrl);
    const focused = cellCtrl.isCellFocused();
    const mightWantToKeepCell = editing || focused;
    if (mightWantToKeepCell) {
      const displayedColumns = visibleCols.allCols;
      const cellStillDisplayed = displayedColumns.indexOf(column) >= 0;
      return cellStillDisplayed ? KEEP_CELL : REMOVE_CELL;
    }
    return REMOVE_CELL;
  }
  getDomOrder() {
    const isEnsureDomOrder = this.gos.get("ensureDomOrder");
    return isEnsureDomOrder || _isDomLayout(this.gos, "print");
  }
  listenOnDomOrder(gui) {
    const listener = () => {
      gui.rowComp.setDomOrder(this.getDomOrder());
    };
    gui.compBean.addManagedPropertyListeners(["domLayout", "ensureDomOrder"], listener);
  }
  setAnimateFlags(animateIn) {
    if (this.rowNode.sticky || !animateIn) {
      return;
    }
    const oldRowTopExists = _exists(this.rowNode.oldRowTop);
    const { visibleCols } = this.beans;
    const pinningLeft = visibleCols.isPinningLeft();
    const pinningRight = visibleCols.isPinningRight();
    if (oldRowTopExists) {
      const { slideInAnimation } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        slideInAnimation.fullWidth = true;
        return;
      }
      slideInAnimation.center = true;
      slideInAnimation.left = pinningLeft;
      slideInAnimation.right = pinningRight;
    } else {
      const { fadeInAnimation } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        fadeInAnimation.fullWidth = true;
        return;
      }
      fadeInAnimation.center = true;
      fadeInAnimation.left = pinningLeft;
      fadeInAnimation.right = pinningRight;
    }
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const tryRefresh = (gui, pinned) => {
      if (!gui) {
        return true;
      }
      return gui.rowComp.refreshFullWidth(() => {
        const compDetails = this.createFullWidthCompDetails(gui.element, pinned);
        return compDetails.params;
      });
    };
    const fullWidthSuccess = tryRefresh(this.fullWidthGui, null);
    const centerSuccess = tryRefresh(this.centerGui, null);
    const leftSuccess = tryRefresh(this.leftGui, "left");
    const rightSuccess = tryRefresh(this.rightGui, "right");
    const allFullWidthRowsRefreshed = fullWidthSuccess && centerSuccess && leftSuccess && rightSuccess;
    return allFullWidthRowsRefreshed;
  }
  addListeners() {
    var _a4;
    const { beans, gos, rowNode } = this;
    const { expansionSvc, eventSvc, context, rowSpanSvc } = beans;
    this.addManagedListeners(this.rowNode, {
      heightChanged: () => this.onRowHeightChanged(),
      rowSelected: () => this.onRowSelected(),
      rowIndexChanged: this.onRowIndexChanged.bind(this),
      topChanged: this.onTopChanged.bind(this),
      ...(_a4 = expansionSvc == null ? void 0 : expansionSvc.getRowExpandedListeners(this)) != null ? _a4 : {}
    });
    if (rowNode.detail) {
      this.addManagedListeners(rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) });
    }
    this.addManagedListeners(rowNode, {
      dataChanged: this.onRowNodeDataChanged.bind(this),
      cellChanged: this.postProcessCss.bind(this),
      rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
      draggingChanged: this.postProcessRowDragging.bind(this),
      uiLevelChanged: this.onUiLevelChanged.bind(this),
      rowPinned: this.onRowPinned.bind(this)
    });
    this.addManagedListeners(eventSvc, {
      paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
      heightScaleChanged: this.onTopChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
      cellFocused: this.onCellFocusChanged.bind(this),
      cellFocusCleared: this.onCellFocusChanged.bind(this),
      paginationChanged: this.onPaginationChanged.bind(this),
      modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
      columnMoved: () => this.updateColumnLists()
    });
    if (rowSpanSvc) {
      this.addManagedListeners(rowSpanSvc, {
        spannedCellsUpdated: ({ pinned }) => {
          if (pinned && !rowNode.rowPinned) {
            return;
          }
          this.updateColumnLists();
        }
      });
    }
    this.addDestroyFunc(() => {
      this.rowDragComps = this.destroyBeans(this.rowDragComps, context);
      this.tooltipFeature = this.destroyBean(this.tooltipFeature, context);
      this.rowEditStyleFeature = this.destroyBean(this.rowEditStyleFeature, context);
    });
    this.addManagedPropertyListeners(
      ["rowStyle", "getRowStyle", "rowClass", "getRowClass", "rowClassRules"],
      this.postProcessCss.bind(this)
    );
    this.addManagedPropertyListener("rowDragEntireRow", () => {
      const useRowDragEntireRow = gos.get("rowDragEntireRow");
      if (useRowDragEntireRow) {
        this.allRowGuis.forEach((gui) => {
          this.addRowDraggerToRow(gui);
        });
        return;
      }
      this.rowDragComps = this.destroyBeans(this.rowDragComps, context);
    });
    this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListeners(this.rowNode, {
      rowIndexChanged: () => this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onRowIndexChanged()),
      cellChanged: (event) => this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellChanged(event))
    });
  }
  /** Should only ever be triggered on source rows (i.e. not on pinned siblings) */
  onRowPinned() {
    for (const gui of this.allRowGuis) {
      gui.rowComp.toggleCss("ag-row-pinned-source", !!this.rowNode.pinnedSibling);
    }
  }
  onRowNodeDataChanged(event) {
    this.refreshRow({
      suppressFlash: !event.update,
      newData: !event.update
    });
  }
  refreshRow(params) {
    const fullWidthChanged = this.isFullWidth() !== !!this.isNodeFullWidthCell();
    if (fullWidthChanged) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      const refresh = this.refreshFullWidth();
      if (!refresh) {
        this.beans.rowRenderer.redrawRow(this.rowNode);
      }
      return;
    }
    this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.refreshCell(params));
    this.allRowGuis.forEach((gui) => {
      this.setRowCompRowId(gui.rowComp);
      this.updateRowBusinessKey();
      this.setRowCompRowBusinessKey(gui.rowComp);
    });
    this.onRowSelected();
    this.postProcessCss();
  }
  postProcessCss() {
    var _a4;
    this.setStylesFromGridOptions(true);
    this.postProcessClassesFromGridOptions();
    this.postProcessRowClassRules();
    (_a4 = this.rowEditStyleFeature) == null ? void 0 : _a4.applyRowStyles();
    this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const rowDropHighlightSvc = this.beans.rowDropHighlightSvc;
    const highlighted = (rowDropHighlightSvc == null ? void 0 : rowDropHighlightSvc.row) === this.rowNode ? rowDropHighlightSvc.position : "none";
    const aboveOn = highlighted === "above";
    const insideOn = highlighted === "inside";
    const belowOn = highlighted === "below";
    const treeData = this.gos.get("treeData");
    const indented = treeData && (belowOn || aboveOn);
    const uiLevel = this.rowNode.uiLevel.toString();
    this.allRowGuis.forEach((gui) => {
      const rowComp = gui.rowComp;
      rowComp.toggleCss("ag-row-highlight-above", aboveOn);
      rowComp.toggleCss("ag-row-highlight-inside", insideOn);
      rowComp.toggleCss("ag-row-highlight-below", belowOn);
      rowComp.toggleCss("ag-row-highlight-indent", indented);
      if (indented) {
        gui.element.style.setProperty("--ag-row-highlight-level", uiLevel);
      } else {
        gui.element.style.removeProperty("--ag-row-highlight-level");
      }
    });
  }
  postProcessRowDragging() {
    const dragging = this.rowNode.dragging;
    this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss("ag-row-dragging", dragging));
  }
  onDisplayedColumnsChanged() {
    var _a4;
    this.updateColumnLists(true);
    (_a4 = this.beans.rowAutoHeight) == null ? void 0 : _a4.requestCheckAutoHeight();
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(false, true);
  }
  getRowPosition() {
    return {
      rowPinned: _makeNull(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  onKeyboardNavigate(keyboardEvent) {
    var _a4;
    const groupInfo = this.findFullWidthInfoForEvent(keyboardEvent);
    if (!groupInfo) {
      return;
    }
    const { rowGui, column } = groupInfo;
    const currentFullWidthContainer = rowGui.element;
    const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
    if (!isFullWidthContainerFocused) {
      return;
    }
    const node = this.rowNode;
    const { focusSvc, navigation } = this.beans;
    const lastFocusedCell = focusSvc.getFocusedCell();
    const cellPosition = {
      rowIndex: node.rowIndex,
      rowPinned: node.rowPinned,
      column: (_a4 = lastFocusedCell == null ? void 0 : lastFocusedCell.column) != null ? _a4 : column
    };
    navigation == null ? void 0 : navigation.navigateToNextCell(keyboardEvent, keyboardEvent.key, cellPosition, true);
    keyboardEvent.preventDefault();
  }
  onTabKeyDown(keyboardEvent) {
    var _a4;
    if (keyboardEvent.defaultPrevented || _isStopPropagationForAgGrid(keyboardEvent)) {
      return;
    }
    const currentFullWidthComp = this.allRowGuis.find(
      (c) => c.element.contains(keyboardEvent.target)
    );
    const currentFullWidthContainer = currentFullWidthComp ? currentFullWidthComp.element : null;
    const isFullWidthContainerFocused = currentFullWidthContainer === keyboardEvent.target;
    const activeEl = _getActiveDomElement(this.beans);
    let isDetailGridCellFocused = false;
    if (currentFullWidthContainer && activeEl) {
      isDetailGridCellFocused = currentFullWidthContainer.contains(activeEl) && activeEl.classList.contains("ag-cell");
    }
    let nextEl = null;
    if (!isFullWidthContainerFocused && !isDetailGridCellFocused) {
      nextEl = _findNextFocusableElement(this.beans, currentFullWidthContainer, false, keyboardEvent.shiftKey);
    }
    if (this.isFullWidth() && isFullWidthContainerFocused || !nextEl) {
      (_a4 = this.beans.navigation) == null ? void 0 : _a4.onTabKeyDown(this, keyboardEvent);
    }
  }
  getFullWidthElement() {
    if (this.fullWidthGui) {
      return this.fullWidthGui.element;
    }
    return null;
  }
  getRowYPosition() {
    var _a4;
    const displayedEl = (_a4 = this.allRowGuis.find((el) => _isVisible(el.element))) == null ? void 0 : _a4.element;
    if (displayedEl) {
      return displayedEl.getBoundingClientRect().top;
    }
    return 0;
  }
  onSuppressCellFocusChanged(suppressCellFocus) {
    const tabIndex = this.isFullWidth() && suppressCellFocus ? void 0 : this.gos.get("tabIndex");
    this.allRowGuis.forEach((gui) => {
      _addOrRemoveAttribute(gui.element, "tabindex", tabIndex);
    });
  }
  onFullWidthRowFocused(event) {
    var _a4, _b2, _c;
    const node = this.rowNode;
    const isFocused = !event ? false : this.isFullWidth() && event.rowIndex === node.rowIndex && event.rowPinned == node.rowPinned;
    let element;
    if (this.fullWidthGui) {
      element = this.fullWidthGui.element;
    } else {
      const column = this.beans.colModel.getCol(event == null ? void 0 : event.column);
      const pinned = column == null ? void 0 : column.pinned;
      if (pinned) {
        element = pinned === "right" ? (_a4 = this.rightGui) == null ? void 0 : _a4.element : (_b2 = this.leftGui) == null ? void 0 : _b2.element;
      } else {
        element = (_c = this.centerGui) == null ? void 0 : _c.element;
      }
    }
    if (!element) {
      return;
    }
    element.classList.toggle("ag-full-width-focus", isFocused);
    if (isFocused && (event == null ? void 0 : event.forceBrowserFocus)) {
      element.focus({ preventScroll: true });
    }
  }
  recreateCell(cellCtrl) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, cellCtrl);
    this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, cellCtrl);
    this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, cellCtrl);
    cellCtrl.destroy();
    this.updateColumnLists();
  }
  removeCellCtrl(prev, cellCtrlToRemove) {
    const res = {
      list: [],
      map: {}
    };
    prev.list.forEach((cellCtrl) => {
      if (cellCtrl === cellCtrlToRemove) {
        return;
      }
      res.list.push(cellCtrl);
      res.map[cellCtrl.column.getInstanceId()] = cellCtrl;
    });
    return res;
  }
  onMouseEvent(eventName, mouseEvent) {
    switch (eventName) {
      case "dblclick":
        this.onRowDblClick(mouseEvent);
        break;
      case "click":
        this.onRowClick(mouseEvent);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(mouseEvent);
        break;
    }
  }
  createRowEvent(type, domEvent) {
    const { rowNode } = this;
    return _addGridCommonParams(this.gos, {
      type,
      node: rowNode,
      data: rowNode.data,
      rowIndex: rowNode.rowIndex,
      rowPinned: rowNode.rowPinned,
      event: domEvent
    });
  }
  createRowEventWithSource(type, domEvent) {
    const event = this.createRowEvent(type, domEvent);
    event.source = this;
    return event;
  }
  onRowDblClick(mouseEvent) {
    if (_isStopPropagationForAgGrid(mouseEvent)) {
      return;
    }
    const rowEvent = this.createRowEventWithSource("rowDoubleClicked", mouseEvent);
    rowEvent.isEventHandlingSuppressed = this.isSuppressMouseEvent(mouseEvent);
    this.beans.eventSvc.dispatchEvent(rowEvent);
  }
  findFullWidthInfoForEvent(event) {
    if (!event) {
      return;
    }
    const rowGui = this.findFullWidthRowGui(event.target);
    const column = this.getColumnForFullWidth(rowGui);
    if (!rowGui || !column) {
      return;
    }
    return { rowGui, column };
  }
  findFullWidthRowGui(target) {
    return this.allRowGuis.find((c) => c.element.contains(target));
  }
  getColumnForFullWidth(fullWidthRowGui) {
    const { visibleCols } = this.beans;
    switch (fullWidthRowGui == null ? void 0 : fullWidthRowGui.containerType) {
      case "center":
        return visibleCols.centerCols[0];
      case "left":
        return visibleCols.leftCols[0];
      case "right":
        return visibleCols.rightCols[0];
      default:
        return visibleCols.allCols[0];
    }
  }
  onRowMouseDown(mouseEvent) {
    this.lastMouseDownOnDragger = _isElementChildOfClass(mouseEvent.target, "ag-row-drag", 3);
    if (!this.isFullWidth() || this.isSuppressMouseEvent(mouseEvent)) {
      return;
    }
    const { rangeSvc, focusSvc } = this.beans;
    rangeSvc == null ? void 0 : rangeSvc.removeAllCellRanges();
    const groupInfo = this.findFullWidthInfoForEvent(mouseEvent);
    if (!groupInfo) {
      return;
    }
    const { rowGui, column } = groupInfo;
    const element = rowGui.element;
    const target = mouseEvent.target;
    const node = this.rowNode;
    let forceBrowserFocus = mouseEvent.defaultPrevented || _isBrowserSafari();
    if (element && element.contains(target) && _isFocusableFormField(target)) {
      forceBrowserFocus = false;
    }
    focusSvc.setFocusedCell({
      rowIndex: node.rowIndex,
      column,
      rowPinned: node.rowPinned,
      forceBrowserFocus
    });
  }
  isSuppressMouseEvent(mouseEvent) {
    const { gos, rowNode } = this;
    if (this.isFullWidth()) {
      const fullWidthRowGui = this.findFullWidthRowGui(mouseEvent.target);
      return _suppressFullWidthMouseEvent(
        gos,
        fullWidthRowGui == null ? void 0 : fullWidthRowGui.rowComp.getFullWidthCellRendererParams(),
        rowNode,
        mouseEvent
      );
    }
    const cellCtrl = _getCellCtrlForEventTarget(gos, mouseEvent.target);
    return cellCtrl != null && _suppressCellMouseEvent(gos, cellCtrl.column, rowNode, mouseEvent);
  }
  onRowClick(mouseEvent) {
    const stop = _isStopPropagationForAgGrid(mouseEvent) || this.lastMouseDownOnDragger;
    if (stop) {
      return;
    }
    const isSuppressMouseEvent = this.isSuppressMouseEvent(mouseEvent);
    const { eventSvc, selectionSvc } = this.beans;
    const rowEvent = this.createRowEventWithSource("rowClicked", mouseEvent);
    rowEvent.isEventHandlingSuppressed = isSuppressMouseEvent;
    eventSvc.dispatchEvent(rowEvent);
    if (isSuppressMouseEvent) {
      return;
    }
    selectionSvc == null ? void 0 : selectionSvc.handleSelectionEvent(mouseEvent, this.rowNode, "rowClicked");
  }
  setupDetailRowAutoHeight(eDetailGui) {
    var _a4;
    if (this.rowType !== "FullWidthDetail") {
      return;
    }
    (_a4 = this.beans.masterDetailSvc) == null ? void 0 : _a4.setupDetailRowAutoHeight(this, eDetailGui);
  }
  createFullWidthCompDetails(eRow, pinned) {
    const { gos, rowNode } = this;
    const params = _addGridCommonParams(gos, {
      fullWidth: true,
      data: rowNode.data,
      node: rowNode,
      value: rowNode.key,
      valueFormatted: rowNode.key,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: eRow,
      eParentOfValue: eRow,
      pinned,
      addRenderedRowListener: this.addEventListener.bind(this),
      // This is not on the type of ICellRendererParams
      registerRowDragger: (rowDraggerElement, dragStartPixels, value, rowDragEntireRow) => this.addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value, rowDragEntireRow),
      setTooltip: (value, shouldDisplayTooltip) => {
        gos.assertModuleRegistered("Tooltip", 3);
        this.setupFullWidthRowTooltip(value, shouldDisplayTooltip);
      }
    });
    const compFactory = this.beans.userCompFactory;
    switch (this.rowType) {
      case "FullWidthDetail":
        return _getFullWidthDetailCellRendererDetails(compFactory, params);
      case "FullWidthGroup": {
        const { value, valueFormatted } = this.beans.valueSvc.getValueForDisplay(void 0, this.rowNode, true);
        params.value = value;
        params.valueFormatted = valueFormatted;
        return _getFullWidthGroupCellRendererDetails(compFactory, params);
      }
      case "FullWidthLoading":
        return _getFullWidthLoadingCellRendererDetails(compFactory, params);
      default:
        return _getFullWidthCellRendererDetails(compFactory, params);
    }
  }
  setupFullWidthRowTooltip(value, shouldDisplayTooltip) {
    var _a4;
    if (!this.fullWidthGui) {
      return;
    }
    this.tooltipFeature = (_a4 = this.beans.tooltipSvc) == null ? void 0 : _a4.setupFullWidthRowTooltip(
      this.tooltipFeature,
      this,
      value,
      shouldDisplayTooltip
    );
  }
  addFullWidthRowDragging(rowDraggerElement, dragStartPixels, value = "", alwaysVisible) {
    const { rowDragSvc, context } = this.beans;
    if (!rowDragSvc || !this.isFullWidth()) {
      return;
    }
    const rowDragComp = rowDragSvc.createRowDragComp(
      () => value,
      this.rowNode,
      void 0,
      rowDraggerElement,
      dragStartPixels,
      alwaysVisible
    );
    this.createBean(rowDragComp, context);
    this.addDestroyFunc(() => {
      this.destroyBean(rowDragComp, context);
    });
  }
  onUiLevelChanged() {
    const newLevel = calculateRowLevel(this.rowNode);
    if (this.rowLevel != newLevel) {
      const classToAdd = "ag-row-level-" + newLevel;
      const classToRemove = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((gui) => {
        gui.rowComp.toggleCss(classToAdd, true);
        gui.rowComp.toggleCss(classToRemove, false);
      });
    }
    this.rowLevel = newLevel;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const newFirst = this.isFirstRowOnPage();
    const newLast = this.isLastRowOnPage();
    if (this.firstRowOnPage !== newFirst) {
      this.firstRowOnPage = newFirst;
      this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss("ag-row-first", newFirst));
    }
    if (this.lastRowOnPage !== newLast) {
      this.lastRowOnPage = newLast;
      this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss("ag-row-last", newLast));
    }
  }
  getAllCellCtrls() {
    if (this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0) {
      return this.centerCellCtrls.list;
    }
    const res = [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
    return res;
  }
  postProcessClassesFromGridOptions() {
    var _a4;
    const cssClasses = [];
    (_a4 = this.beans.rowStyleSvc) == null ? void 0 : _a4.processClassesFromGridOptions(cssClasses, this.rowNode);
    if (!cssClasses.length) {
      return;
    }
    cssClasses.forEach((classStr) => {
      this.allRowGuis.forEach((c) => c.rowComp.toggleCss(classStr, true));
    });
  }
  postProcessRowClassRules() {
    var _a4;
    (_a4 = this.beans.rowStyleSvc) == null ? void 0 : _a4.processRowClassRules(
      this.rowNode,
      (className) => {
        this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss(className, true));
      },
      (className) => {
        this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss(className, false));
      }
    );
  }
  setStylesFromGridOptions(updateStyles, gui) {
    if (updateStyles) {
      this.rowStyles = this.processStylesFromGridOptions();
    }
    this.forEachGui(gui, (gui2) => gui2.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(rowContainerType) {
    if (rowContainerType === "left" || rowContainerType === "right") {
      return rowContainerType;
    }
    return null;
  }
  getInitialRowClasses(rowContainerType) {
    var _a4, _b2;
    const pinned = this.getPinnedForContainer(rowContainerType);
    const fullWidthRow = this.isFullWidth();
    const { rowNode, beans } = this;
    const classes = [];
    classes.push("ag-row");
    classes.push(this.rowFocused ? "ag-row-focus" : "ag-row-no-focus");
    if (this.fadeInAnimation[rowContainerType]) {
      classes.push("ag-opacity-zero");
    }
    classes.push(rowNode.rowIndex % 2 === 0 ? "ag-row-even" : "ag-row-odd");
    if (rowNode.isRowPinned()) {
      classes.push("ag-row-pinned");
      if ((_a4 = beans.pinnedRowModel) == null ? void 0 : _a4.isManual()) {
        classes.push("ag-row-pinned-manual");
      }
    }
    if (!rowNode.isRowPinned() && rowNode.pinnedSibling) {
      classes.push("ag-row-pinned-source");
    }
    if (rowNode.isSelected()) {
      classes.push("ag-row-selected");
    }
    if (rowNode.footer) {
      classes.push("ag-row-footer");
    }
    classes.push("ag-row-level-" + this.rowLevel);
    if (rowNode.stub) {
      classes.push("ag-row-loading");
    }
    if (fullWidthRow) {
      classes.push("ag-full-width-row");
    }
    (_b2 = beans.expansionSvc) == null ? void 0 : _b2.addExpandedCss(classes, rowNode);
    if (rowNode.dragging) {
      classes.push("ag-row-dragging");
    }
    const { rowStyleSvc } = beans;
    if (rowStyleSvc) {
      rowStyleSvc.processClassesFromGridOptions(classes, rowNode);
      rowStyleSvc.preProcessRowClassRules(classes, rowNode);
    }
    classes.push(this.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute");
    if (this.isFirstRowOnPage()) {
      classes.push("ag-row-first");
    }
    if (this.isLastRowOnPage()) {
      classes.push("ag-row-last");
    }
    if (fullWidthRow) {
      if (pinned === "left") {
        classes.push("ag-cell-last-left-pinned");
      }
      if (pinned === "right") {
        classes.push("ag-cell-first-right-pinned");
      }
    }
    return classes;
  }
  processStylesFromGridOptions() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.beans.rowStyleSvc) == null ? void 0 : _a4.processStylesFromGridOptions(this.rowNode)) != null ? _b2 : this.emptyStyle;
  }
  onRowSelected(gui) {
    var _a4;
    (_a4 = this.beans.selectionSvc) == null ? void 0 : _a4.onRowCtrlSelected(
      this,
      (gui2) => {
        if (gui2 === this.centerGui || gui2 === this.fullWidthGui) {
          this.announceDescription();
        }
      },
      gui
    );
  }
  announceDescription() {
    var _a4;
    (_a4 = this.beans.selectionSvc) == null ? void 0 : _a4.announceAriaRowSelection(this.rowNode);
  }
  addHoverFunctionality(eGui) {
    if (!this.active) {
      return;
    }
    const { element, compBean } = eGui;
    const { rowNode, beans, gos } = this;
    compBean.addManagedListeners(element, {
      // We use pointer events here instead of mouse events, as pointer events
      // are more reliable for hover detection, especially with touch devices
      // or hybrid touch + mouse devices.
      pointerenter: (e) => {
        if (e.pointerType === "mouse") {
          rowNode.dispatchRowEvent("mouseEnter");
        }
      },
      pointerleave: (e) => {
        if (e.pointerType === "mouse") {
          rowNode.dispatchRowEvent("mouseLeave");
        }
      }
    });
    compBean.addManagedListeners(rowNode, {
      mouseEnter: () => {
        var _a4;
        if (!((_a4 = beans.dragSvc) == null ? void 0 : _a4.dragging) && !gos.get("suppressRowHoverHighlight")) {
          element.classList.add("ag-row-hover");
          rowNode.setHovered(true);
        }
      },
      mouseLeave: () => {
        this.resetHoveredStatus(element);
      }
    });
  }
  resetHoveredStatus(el) {
    const elements = el ? [el] : this.allRowGuis.map((gui) => gui.element);
    for (const element of elements) {
      element.classList.remove("ag-row-hover");
    }
    this.rowNode.setHovered(false);
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(rowTop) {
    const range = this.beans.ctrlsSvc.getScrollFeature().getApproximateVScollPosition();
    const minPixel = this.applyPaginationOffset(range.top, true) - 100;
    const maxPixel = this.applyPaginationOffset(range.bottom, true) + 100;
    return Math.min(Math.max(minPixel, rowTop), maxPixel);
  }
  forEachGui(gui, callback) {
    if (gui) {
      callback(gui);
    } else {
      this.allRowGuis.forEach(callback);
    }
  }
  isRowRendered() {
    return this.allRowGuis.length > 0;
  }
  onRowHeightChanged(gui) {
    if (this.rowNode.rowHeight == null) {
      return;
    }
    const rowHeight = this.rowNode.rowHeight;
    const defaultRowHeight = this.beans.environment.getDefaultRowHeight();
    const isHeightFromFunc = _isGetRowHeightFunction(this.gos);
    const heightFromFunc = isHeightFromFunc ? _getRowHeightForNode(this.beans, this.rowNode).height : void 0;
    const lineHeight = heightFromFunc ? `${Math.min(defaultRowHeight, heightFromFunc) - 2}px` : void 0;
    this.forEachGui(gui, (gui2) => {
      gui2.element.style.height = `${rowHeight}px`;
      if (lineHeight) {
        gui2.element.style.setProperty("--ag-line-height", lineHeight);
      }
    });
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass(suppressAnimation = false) {
    var _a4;
    this.active = false;
    const { rowNode } = this;
    if (!suppressAnimation && _isAnimateRows(this.gos) && !rowNode.sticky) {
      const rowStillVisibleJustNotInViewport = rowNode.rowTop != null;
      if (rowStillVisibleJustNotInViewport) {
        const rowTop = this.roundRowTopToBounds(rowNode.rowTop);
        this.setRowTop(rowTop);
      } else {
        this.allRowGuis.forEach((gui) => gui.rowComp.toggleCss("ag-opacity-zero", true));
      }
    }
    if ((_a4 = this.fullWidthGui) == null ? void 0 : _a4.element.contains(_getActiveDomElement(this.beans))) {
      this.beans.focusSvc.attemptToRecoverFocus();
    }
    rowNode.setHovered(false);
    const event = this.createRowEvent("virtualRowRemoved");
    this.dispatchLocalEvent(event);
    this.beans.eventSvc.dispatchEvent(event);
    super.destroy();
  }
  destroySecondPass() {
    this.allRowGuis.length = 0;
    const destroyCellCtrls = (ctrls) => {
      ctrls.list.forEach((c) => c.destroy());
      return { list: [], map: {} };
    };
    this.centerCellCtrls = destroyCellCtrls(this.centerCellCtrls);
    this.leftCellCtrls = destroyCellCtrls(this.leftCellCtrls);
    this.rightCellCtrls = destroyCellCtrls(this.rightCellCtrls);
  }
  setFocusedClasses(gui) {
    this.forEachGui(gui, (gui2) => {
      gui2.rowComp.toggleCss("ag-row-focus", this.rowFocused);
      gui2.rowComp.toggleCss("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const { focusSvc } = this.beans;
    const rowFocused = focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    if (rowFocused !== this.rowFocused) {
      this.rowFocused = rowFocused;
      this.setFocusedClasses();
    }
  }
  onPaginationChanged() {
    var _a4, _b2;
    const currentPage = (_b2 = (_a4 = this.beans.pagination) == null ? void 0 : _a4.getCurrentPage()) != null ? _b2 : 0;
    if (this.paginationPage !== currentPage) {
      this.paginationPage = currentPage;
      this.onTopChanged();
    }
    this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(topPx, reverse = false) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky) {
      return topPx;
    }
    const pixelOffset = this.beans.pageBounds.getPixelOffset();
    const multiplier = reverse ? 1 : -1;
    return topPx + pixelOffset * multiplier;
  }
  setRowTop(pixels) {
    if (this.printLayout) {
      return;
    }
    if (_exists(pixels)) {
      const afterPaginationPixels = this.applyPaginationOffset(pixels);
      const skipScaling = this.rowNode.isRowPinned() || this.rowNode.sticky;
      const afterScalingPixels = skipScaling ? afterPaginationPixels : this.beans.rowContainerHeight.getRealPixelPosition(afterPaginationPixels);
      const topPx = `${afterScalingPixels}px`;
      this.setRowTopStyle(topPx);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(rowContainerType) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(rowContainerType) : void 0;
  }
  getInitialTransform(rowContainerType) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(rowContainerType)})`;
  }
  getInitialRowTopShared(rowContainerType) {
    if (this.printLayout) {
      return "";
    }
    const rowNode = this.rowNode;
    let rowTop;
    if (rowNode.sticky) {
      rowTop = rowNode.stickyRowTop;
    } else {
      const pixels = this.slideInAnimation[rowContainerType] ? this.roundRowTopToBounds(rowNode.oldRowTop) : rowNode.rowTop;
      const afterPaginationPixels = this.applyPaginationOffset(pixels);
      rowTop = rowNode.isRowPinned() ? afterPaginationPixels : this.beans.rowContainerHeight.getRealPixelPosition(afterPaginationPixels);
    }
    return rowTop + "px";
  }
  setRowTopStyle(topPx) {
    this.allRowGuis.forEach(
      (gui) => this.suppressRowTransform ? gui.rowComp.setTop(topPx) : gui.rowComp.setTransform(`translateY(${topPx})`)
    );
  }
  getCellCtrl(column, skipColSpanSearch = false) {
    let res = null;
    this.getAllCellCtrls().forEach((cellCtrl) => {
      if (cellCtrl.column == column) {
        res = cellCtrl;
      }
    });
    if (res != null || skipColSpanSearch) {
      return res;
    }
    this.getAllCellCtrls().forEach((cellCtrl) => {
      if ((cellCtrl == null ? void 0 : cellCtrl.getColSpanningList().indexOf(column)) >= 0) {
        res = cellCtrl;
      }
    });
    return res;
  }
  onRowIndexChanged() {
    if (this.rowNode.rowIndex != null) {
      this.onCellFocusChanged();
      this.updateRowIndexes();
      this.postProcessCss();
    }
  }
  updateRowIndexes(gui) {
    var _a4, _b2, _c, _d;
    const rowIndexStr = this.rowNode.getRowIndexString();
    if (rowIndexStr === null) {
      return;
    }
    const headerRowCount = ((_b2 = (_a4 = this.beans.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : _a4.getRowCount()) != null ? _b2 : 0) + ((_d = (_c = this.beans.filterManager) == null ? void 0 : _c.getHeaderRowCount()) != null ? _d : 0);
    const rowIsEven = this.rowNode.rowIndex % 2 === 0;
    const ariaRowIndex = headerRowCount + this.rowNode.rowIndex + 1;
    this.forEachGui(gui, (c) => {
      c.rowComp.setRowIndex(rowIndexStr);
      c.rowComp.toggleCss("ag-row-even", rowIsEven);
      c.rowComp.toggleCss("ag-row-odd", !rowIsEven);
      _setAriaRowIndex(c.element, ariaRowIndex);
    });
  }
};
var NavigationService = class extends BeanStub {
  constructor() {
    super();
    this.beanName = "navigation";
    this.onPageDown = _throttle(this.onPageDown, 100);
    this.onPageUp = _throttle(this.onPageUp, 100);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCon = p.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(event, fromFullWidth = false) {
    const key = event.key;
    const alt = event.altKey;
    const ctrl = event.ctrlKey || event.metaKey;
    const rangeServiceShouldHandleShift = !!this.beans.rangeSvc && event.shiftKey;
    const currentCell = _getCellPositionForEvent(this.gos, event);
    let processed = false;
    switch (key) {
      case KeyCode.PAGE_HOME:
      case KeyCode.PAGE_END:
        if (!ctrl && !alt) {
          this.onHomeOrEndKey(key);
          processed = true;
        }
        break;
      case KeyCode.LEFT:
      case KeyCode.RIGHT:
      case KeyCode.UP:
      case KeyCode.DOWN:
        if (!currentCell) {
          return false;
        }
        if (ctrl && !alt && !rangeServiceShouldHandleShift) {
          this.onCtrlUpDownLeftRight(key, currentCell);
          processed = true;
        }
        break;
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
        if (!ctrl && !alt) {
          processed = this.handlePageUpDown(key, currentCell, fromFullWidth);
        }
        break;
    }
    if (processed) {
      event.preventDefault();
    }
    return processed;
  }
  handlePageUpDown(key, currentCell, fromFullWidth) {
    if (fromFullWidth) {
      currentCell = this.beans.focusSvc.getFocusedCell();
    }
    if (!currentCell) {
      return false;
    }
    if (key === KeyCode.PAGE_UP) {
      this.onPageUp(currentCell);
    } else {
      this.onPageDown(currentCell);
    }
    return true;
  }
  navigateTo({
    scrollIndex,
    scrollType,
    scrollColumn,
    focusIndex,
    focusColumn,
    isAsync,
    rowPinned
  }) {
    const { scrollFeature } = this.gridBodyCon;
    if (_exists(scrollColumn) && !scrollColumn.isPinned()) {
      scrollFeature.ensureColumnVisible(scrollColumn);
    }
    if (_exists(scrollIndex)) {
      scrollFeature.ensureIndexVisible(scrollIndex, scrollType);
    }
    if (!isAsync) {
      scrollFeature.ensureIndexVisible(focusIndex);
    }
    const { focusSvc, rangeSvc } = this.beans;
    focusSvc.setFocusedCell({
      rowIndex: focusIndex,
      column: focusColumn,
      rowPinned,
      forceBrowserFocus: true
    });
    rangeSvc == null ? void 0 : rangeSvc.setRangeToCell({ rowIndex: focusIndex, rowPinned, column: focusColumn });
  }
  // this method is throttled, see the `constructor`
  onPageDown(gridCell) {
    const beans = this.beans;
    const scrollPosition = getVScroll(beans);
    const pixelsInOnePage = this.getViewportHeight();
    const { pageBounds, rowModel, rowAutoHeight } = beans;
    const pagingPixelOffset = pageBounds.getPixelOffset();
    const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;
    const currentPageBottomRow = rowModel.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);
    if (rowAutoHeight == null ? void 0 : rowAutoHeight.active) {
      this.navigateToNextPageWithAutoHeight(gridCell, currentPageBottomRow);
    } else {
      this.navigateToNextPage(gridCell, currentPageBottomRow);
    }
  }
  // this method is throttled, see the `constructor`
  onPageUp(gridCell) {
    const beans = this.beans;
    const scrollPosition = getVScroll(beans);
    const { pageBounds, rowModel, rowAutoHeight } = beans;
    const pagingPixelOffset = pageBounds.getPixelOffset();
    const currentPageTopPixel = scrollPosition.top;
    const currentPageTopRow = rowModel.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);
    if (rowAutoHeight == null ? void 0 : rowAutoHeight.active) {
      this.navigateToNextPageWithAutoHeight(gridCell, currentPageTopRow, true);
    } else {
      this.navigateToNextPage(gridCell, currentPageTopRow, true);
    }
  }
  navigateToNextPage(gridCell, scrollIndex, up = false) {
    const { pageBounds, rowModel } = this.beans;
    const pixelsInOnePage = this.getViewportHeight();
    const firstRow = pageBounds.getFirstRow();
    const lastRow = pageBounds.getLastRow();
    const pagingPixelOffset = pageBounds.getPixelOffset();
    const currentRowNode = rowModel.getRow(gridCell.rowIndex);
    const rowPixelDiff = up ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
      (currentRowNode == null ? void 0 : currentRowNode.rowHeight) - pixelsInOnePage - pagingPixelOffset
    ) : pixelsInOnePage - pagingPixelOffset;
    const nextCellPixel = (currentRowNode == null ? void 0 : currentRowNode.rowTop) + rowPixelDiff;
    let focusIndex = rowModel.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);
    if (focusIndex === gridCell.rowIndex) {
      const diff = up ? -1 : 1;
      scrollIndex = focusIndex = gridCell.rowIndex + diff;
    }
    let scrollType;
    if (up) {
      scrollType = "bottom";
      if (focusIndex < firstRow) {
        focusIndex = firstRow;
      }
      if (scrollIndex < firstRow) {
        scrollIndex = firstRow;
      }
    } else {
      scrollType = "top";
      if (focusIndex > lastRow) {
        focusIndex = lastRow;
      }
      if (scrollIndex > lastRow) {
        scrollIndex = lastRow;
      }
    }
    if (this.isRowTallerThanView(rowModel.getRow(focusIndex))) {
      scrollIndex = focusIndex;
      scrollType = "top";
    }
    this.navigateTo({
      scrollIndex,
      scrollType,
      scrollColumn: null,
      focusIndex,
      focusColumn: gridCell.column
    });
  }
  navigateToNextPageWithAutoHeight(gridCell, scrollIndex, up = false) {
    this.navigateTo({
      scrollIndex,
      scrollType: up ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: scrollIndex,
      focusColumn: gridCell.column
    });
    setTimeout(() => {
      const focusIndex = this.getNextFocusIndexForAutoHeight(gridCell, up);
      this.navigateTo({
        scrollIndex,
        scrollType: up ? "bottom" : "top",
        scrollColumn: null,
        focusIndex,
        focusColumn: gridCell.column,
        isAsync: true
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(gridCell, up = false) {
    var _a4;
    const step = up ? -1 : 1;
    const pixelsInOnePage = this.getViewportHeight();
    const { pageBounds, rowModel } = this.beans;
    const lastRowIndex = pageBounds.getLastRow();
    let pixelSum = 0;
    let currentIndex = gridCell.rowIndex;
    while (currentIndex >= 0 && currentIndex <= lastRowIndex) {
      const currentCell = rowModel.getRow(currentIndex);
      if (currentCell) {
        const currentCellHeight = (_a4 = currentCell.rowHeight) != null ? _a4 : 0;
        if (pixelSum + currentCellHeight > pixelsInOnePage) {
          break;
        }
        pixelSum += currentCellHeight;
      }
      currentIndex += step;
    }
    return Math.max(0, Math.min(currentIndex, lastRowIndex));
  }
  getViewportHeight() {
    const beans = this.beans;
    const scrollPosition = getVScroll(beans);
    const scrollbarWidth = this.beans.scrollVisibleSvc.getScrollbarWidth();
    let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;
    if (beans.ctrlsSvc.get("center").isHorizontalScrollShowing()) {
      pixelsInOnePage -= scrollbarWidth;
    }
    return pixelsInOnePage;
  }
  isRowTallerThanView(rowNode) {
    if (!rowNode) {
      return false;
    }
    const rowHeight = rowNode.rowHeight;
    if (typeof rowHeight !== "number") {
      return false;
    }
    return rowHeight > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(key, gridCell) {
    const cellToFocus = this.beans.cellNavigation.getNextCellToFocus(key, gridCell, true);
    const normalisedPosition = this.getNormalisedPosition(cellToFocus);
    const { rowIndex, rowPinned, column } = normalisedPosition != null ? normalisedPosition : cellToFocus;
    const col = column;
    this.navigateTo({
      scrollIndex: rowIndex,
      scrollType: null,
      scrollColumn: col,
      focusIndex: rowIndex,
      focusColumn: col,
      rowPinned
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(key) {
    const homeKey = key === KeyCode.PAGE_HOME;
    const { visibleCols, pageBounds, rowModel } = this.beans;
    const allColumns = visibleCols.allCols;
    const scrollIndex = homeKey ? pageBounds.getFirstRow() : pageBounds.getLastRow();
    const rowNode = rowModel.getRow(scrollIndex);
    if (!rowNode) {
      return;
    }
    const columnToSelect = (homeKey ? allColumns : [...allColumns].reverse()).find(
      (col) => !col.isSuppressNavigable(rowNode)
    );
    if (!columnToSelect) {
      return;
    }
    this.navigateTo({
      scrollIndex,
      scrollType: null,
      scrollColumn: columnToSelect,
      focusIndex: scrollIndex,
      focusColumn: columnToSelect
    });
  }
  // result of keyboard event
  onTabKeyDown(previous, keyboardEvent) {
    const backwards = keyboardEvent.shiftKey;
    const movedToNextCell = this.tabToNextCellCommon(previous, backwards, keyboardEvent);
    const beans = this.beans;
    const { ctrlsSvc, pageBounds, focusSvc, gos } = beans;
    if (movedToNextCell !== false) {
      if (movedToNextCell) {
        keyboardEvent.preventDefault();
      } else if (movedToNextCell === null) {
        ctrlsSvc.get("gridCtrl").allowFocusForNextCoreContainer(backwards);
      }
      return;
    }
    if (backwards) {
      const { rowIndex, rowPinned } = previous.getRowPosition();
      const firstRow = rowPinned ? rowIndex === 0 : rowIndex === pageBounds.getFirstRow();
      if (firstRow) {
        if (gos.get("headerHeight") === 0 || _isHeaderFocusSuppressed(beans)) {
          _focusNextGridCoreContainer(beans, true, true);
        } else {
          keyboardEvent.preventDefault();
          focusSvc.focusPreviousFromFirstCell(keyboardEvent);
        }
      }
    } else {
      if (previous instanceof CellCtrl) {
        previous.focusCell(true);
      }
      if (!backwards && focusSvc.focusOverlay(false) || _focusNextGridCoreContainer(beans, backwards)) {
        keyboardEvent.preventDefault();
      }
    }
  }
  // comes from API
  tabToNextCell(backwards, event) {
    const beans = this.beans;
    const { focusSvc, rowRenderer } = beans;
    const focusedCell = focusSvc.getFocusedCell();
    if (!focusedCell) {
      return false;
    }
    let cellOrRow = _getCellByPosition(beans, focusedCell);
    if (!cellOrRow) {
      cellOrRow = rowRenderer.getRowByPosition(focusedCell);
      if (!cellOrRow || !cellOrRow.isFullWidth()) {
        return false;
      }
    }
    return !!this.tabToNextCellCommon(cellOrRow, backwards, event, "api");
  }
  tabToNextCellCommon(previous, backwards, event, source = "ui") {
    var _a4;
    const { editSvc, focusSvc } = this.beans;
    let res = void 0;
    const cellCtrl = previous instanceof CellCtrl ? previous : (_a4 = previous.getAllCellCtrls()) == null ? void 0 : _a4[0];
    if (editSvc == null ? void 0 : editSvc.isEditing()) {
      res = editSvc == null ? void 0 : editSvc.moveToNextCell(cellCtrl, backwards, event, source);
    } else {
      res = this.moveToNextCellNotEditing(previous, backwards, event);
    }
    if (res === null) {
      return res;
    }
    return res || !!focusSvc.focusedHeader;
  }
  // returns null if no navigation should be performed
  moveToNextCellNotEditing(previousCell, backwards, event) {
    const displayedColumns = this.beans.visibleCols.allCols;
    let cellPos;
    if (previousCell instanceof RowCtrl) {
      cellPos = {
        ...previousCell.getRowPosition(),
        column: backwards ? displayedColumns[0] : _last(displayedColumns)
      };
      if (this.gos.get("embedFullWidthRows") && event) {
        const focusedContainer = previousCell.findFullWidthInfoForEvent(event);
        if (focusedContainer) {
          cellPos.column = focusedContainer.column;
        }
      }
    } else {
      cellPos = previousCell.getFocusedCellPosition();
    }
    const nextCell = this.findNextCellToFocusOn(cellPos, { backwards, startEditing: false });
    if (nextCell === false) {
      return null;
    }
    if (nextCell instanceof CellCtrl) {
      nextCell.focusCell(true);
    } else if (nextCell) {
      return this.tryToFocusFullWidthRow(nextCell, backwards);
    }
    return _exists(nextCell);
  }
  /**
   * called by the cell, when tab is pressed while editing.
   * @returns RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */
  findNextCellToFocusOn(previousPosition, { backwards, startEditing, skipToNextEditableCell }) {
    let nextPosition = previousPosition;
    const beans = this.beans;
    const { cellNavigation, gos, focusSvc, rowRenderer, rangeSvc } = beans;
    while (true) {
      if (previousPosition !== nextPosition) {
        previousPosition = nextPosition;
      }
      if (!backwards) {
        nextPosition = this.getLastCellOfColSpan(nextPosition);
      }
      nextPosition = cellNavigation.getNextTabbedCell(nextPosition, backwards);
      const userFunc = gos.getCallback("tabToNextCell");
      if (_exists(userFunc)) {
        const params = {
          backwards,
          editing: startEditing,
          previousCellPosition: previousPosition,
          nextCellPosition: nextPosition ? nextPosition : null
        };
        const userResult = userFunc(params);
        if (userResult === true) {
          nextPosition = previousPosition;
        } else if (userResult === false) {
          return false;
        } else {
          nextPosition = {
            rowIndex: userResult.rowIndex,
            column: userResult.column,
            rowPinned: userResult.rowPinned
          };
        }
      }
      if (!nextPosition) {
        return null;
      }
      if (nextPosition.rowIndex < 0) {
        const headerLen = getFocusHeaderRowCount(beans);
        focusSvc.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: headerLen + nextPosition.rowIndex,
            column: nextPosition.column
          },
          fromCell: true
        });
        return null;
      }
      const fullRowEdit = gos.get("editType") === "fullRow";
      if (startEditing && (!fullRowEdit || skipToNextEditableCell)) {
        const cellIsEditable = this.isCellEditable(nextPosition);
        if (!cellIsEditable) {
          continue;
        }
      }
      this.ensureCellVisible(nextPosition);
      const nextCell = _getCellByPosition(beans, nextPosition);
      if (!nextCell) {
        const row = rowRenderer.getRowByPosition(nextPosition);
        if (!row || !row.isFullWidth() || startEditing) {
          continue;
        }
        return { ...row.getRowPosition(), column: nextPosition == null ? void 0 : nextPosition.column };
      }
      if (cellNavigation.isSuppressNavigable(nextCell.column, nextCell.rowNode)) {
        continue;
      }
      nextCell.setFocusedCellPosition(nextPosition);
      rangeSvc == null ? void 0 : rangeSvc.setRangeToCell(nextPosition);
      return nextCell;
    }
  }
  isCellEditable(cell) {
    const rowNode = this.lookupRowNodeForCell(cell);
    if (rowNode) {
      return cell.column.isCellEditable(rowNode);
    }
    return false;
  }
  lookupRowNodeForCell({ rowIndex, rowPinned }) {
    const { pinnedRowModel, rowModel } = this.beans;
    if (rowPinned === "top") {
      return pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedTopRow(rowIndex);
    }
    if (rowPinned === "bottom") {
      return pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedBottomRow(rowIndex);
    }
    return rowModel.getRow(rowIndex);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(event, key, currentCell, allowUserOverride) {
    let nextCell = currentCell;
    let hitEdgeOfGrid = false;
    const beans = this.beans;
    const { cellNavigation, focusSvc, gos } = beans;
    while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {
      if (gos.get("enableRtl")) {
        if (key === KeyCode.LEFT) {
          nextCell = this.getLastCellOfColSpan(nextCell);
        }
      } else if (key === KeyCode.RIGHT) {
        nextCell = this.getLastCellOfColSpan(nextCell);
      }
      nextCell = cellNavigation.getNextCellToFocus(key, nextCell);
      hitEdgeOfGrid = _missing(nextCell);
    }
    if (hitEdgeOfGrid && event && event.key === KeyCode.UP) {
      nextCell = {
        rowIndex: -1,
        rowPinned: null,
        column: currentCell.column
      };
    }
    if (allowUserOverride) {
      const userFunc = gos.getCallback("navigateToNextCell");
      if (_exists(userFunc)) {
        const params = {
          key,
          previousCellPosition: currentCell,
          nextCellPosition: nextCell ? nextCell : null,
          event
        };
        const userCell = userFunc(params);
        if (_exists(userCell)) {
          nextCell = {
            rowPinned: userCell.rowPinned,
            rowIndex: userCell.rowIndex,
            column: userCell.column
          };
        } else {
          nextCell = null;
        }
      }
    }
    if (!nextCell) {
      return;
    }
    if (nextCell.rowIndex < 0) {
      const headerLen = getFocusHeaderRowCount(beans);
      focusSvc.focusHeaderPosition({
        headerPosition: { headerRowIndex: headerLen + nextCell.rowIndex, column: currentCell.column },
        event: event || void 0,
        fromCell: true
      });
      return;
    }
    const normalisedPosition = this.getNormalisedPosition(nextCell);
    if (normalisedPosition) {
      this.focusPosition(normalisedPosition);
    } else {
      this.tryToFocusFullWidthRow(nextCell);
    }
  }
  getNormalisedPosition(cellPosition) {
    var _a4;
    const isSpannedCell = !!((_a4 = this.beans.spannedRowRenderer) == null ? void 0 : _a4.getCellByPosition(cellPosition));
    if (isSpannedCell) {
      return cellPosition;
    }
    this.ensureCellVisible(cellPosition);
    const cellCtrl = _getCellByPosition(this.beans, cellPosition);
    if (!cellCtrl) {
      return null;
    }
    cellPosition = cellCtrl.getFocusedCellPosition();
    this.ensureCellVisible(cellPosition);
    return cellPosition;
  }
  tryToFocusFullWidthRow(position, backwards) {
    const { visibleCols, rowRenderer, focusSvc, eventSvc } = this.beans;
    const displayedColumns = visibleCols.allCols;
    const rowComp = rowRenderer.getRowByPosition(position);
    if (!rowComp || !rowComp.isFullWidth()) {
      return false;
    }
    const currentCellFocused = focusSvc.getFocusedCell();
    const cellPosition = {
      rowIndex: position.rowIndex,
      rowPinned: position.rowPinned,
      column: position.column || (backwards ? _last(displayedColumns) : displayedColumns[0])
    };
    this.focusPosition(cellPosition);
    const fromBelow = backwards == null ? currentCellFocused != null && _isRowBefore(cellPosition, currentCellFocused) : backwards;
    eventSvc.dispatchEvent({
      type: "fullWidthRowFocused",
      rowIndex: cellPosition.rowIndex,
      rowPinned: cellPosition.rowPinned,
      column: cellPosition.column,
      isFullWidthCell: true,
      fromBelow
    });
    return true;
  }
  focusPosition(cellPosition) {
    const { focusSvc, rangeSvc } = this.beans;
    focusSvc.setFocusedCell({
      rowIndex: cellPosition.rowIndex,
      column: cellPosition.column,
      rowPinned: cellPosition.rowPinned,
      forceBrowserFocus: true
    });
    rangeSvc == null ? void 0 : rangeSvc.setRangeToCell(cellPosition);
  }
  isValidNavigateCell(cell) {
    const rowNode = _getRowNode(this.beans, cell);
    return !!rowNode;
  }
  getLastCellOfColSpan(cell) {
    const cellCtrl = _getCellByPosition(this.beans, cell);
    if (!cellCtrl) {
      return cell;
    }
    const colSpanningList = cellCtrl.getColSpanningList();
    if (colSpanningList.length === 1) {
      return cell;
    }
    return {
      rowIndex: cell.rowIndex,
      column: _last(colSpanningList),
      rowPinned: cell.rowPinned
    };
  }
  ensureCellVisible(gridCell) {
    const isGroupStickyEnabled = _isGroupRowsSticky(this.gos);
    const rowNode = this.beans.rowModel.getRow(gridCell.rowIndex);
    const skipScrollToRow = isGroupStickyEnabled && (rowNode == null ? void 0 : rowNode.sticky);
    const { scrollFeature } = this.gridBodyCon;
    if (!skipScrollToRow && _missing(gridCell.rowPinned)) {
      scrollFeature.ensureIndexVisible(gridCell.rowIndex);
    }
    if (!gridCell.column.isPinned()) {
      scrollFeature.ensureColumnVisible(gridCell.column);
    }
  }
  ensureColumnVisible(column) {
    const scrollFeature = this.gridBodyCon.scrollFeature;
    if (!column.isPinned()) {
      scrollFeature.ensureColumnVisible(column);
    }
  }
  ensureRowVisible(rowIndex) {
    const scrollFeature = this.gridBodyCon.scrollFeature;
    scrollFeature.ensureIndexVisible(rowIndex);
  }
};
function getVScroll(beans) {
  return beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
var KeyboardNavigationModule = {
  moduleName: "KeyboardNavigation",
  version: VERSION,
  beans: [NavigationService, CellNavigationService, HeaderNavigationService],
  apiFunctions: {
    getFocusedCell,
    clearFocusedCell,
    setFocusedCell,
    setFocusedHeader,
    tabToNextCell,
    tabToPreviousCell
  }
};
var PageBoundsListener = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "pageBoundsListener";
  }
  postConstruct() {
    this.addManagedEventListeners({
      modelUpdated: this.onModelUpdated.bind(this),
      recalculateRowBounds: this.calculatePages.bind(this)
    });
    this.onModelUpdated();
  }
  onModelUpdated(modelUpdatedEvent) {
    var _a4, _b2, _c, _d, _e;
    this.calculatePages();
    this.eventSvc.dispatchEvent({
      type: "paginationChanged",
      animate: (_a4 = modelUpdatedEvent == null ? void 0 : modelUpdatedEvent.animate) != null ? _a4 : false,
      newData: (_b2 = modelUpdatedEvent == null ? void 0 : modelUpdatedEvent.newData) != null ? _b2 : false,
      newPage: (_c = modelUpdatedEvent == null ? void 0 : modelUpdatedEvent.newPage) != null ? _c : false,
      newPageSize: (_d = modelUpdatedEvent == null ? void 0 : modelUpdatedEvent.newPageSize) != null ? _d : false,
      keepRenderedRows: (_e = modelUpdatedEvent == null ? void 0 : modelUpdatedEvent.keepRenderedRows) != null ? _e : false
    });
  }
  calculatePages() {
    const { pageBounds, pagination, rowModel } = this.beans;
    if (pagination) {
      pagination.calculatePages();
    } else {
      pageBounds.calculateBounds(0, rowModel.getRowCount() - 1);
    }
  }
};
var PageBoundsService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "pageBounds";
    this.pixelOffset = 0;
  }
  getFirstRow() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.topRowBounds) == null ? void 0 : _a4.rowIndex) != null ? _b2 : -1;
  }
  getLastRow() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.bottomRowBounds) == null ? void 0 : _a4.rowIndex) != null ? _b2 : -1;
  }
  getCurrentPageHeight() {
    const { topRowBounds, bottomRowBounds } = this;
    if (!topRowBounds || !bottomRowBounds) {
      return 0;
    }
    return Math.max(bottomRowBounds.rowTop + bottomRowBounds.rowHeight - topRowBounds.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    var _a4;
    const { topRowBounds, bottomRowBounds } = this;
    const pageFirstPixel = (_a4 = topRowBounds == null ? void 0 : topRowBounds.rowTop) != null ? _a4 : 0;
    const pageLastPixel = bottomRowBounds ? bottomRowBounds.rowTop + bottomRowBounds.rowHeight : 0;
    return { pageFirstPixel, pageLastPixel };
  }
  calculateBounds(topDisplayedRowIndex, bottomDisplayedRowIndex) {
    const { rowModel } = this.beans;
    const topRowBounds = rowModel.getRowBounds(topDisplayedRowIndex);
    if (topRowBounds) {
      topRowBounds.rowIndex = topDisplayedRowIndex;
    }
    this.topRowBounds = topRowBounds;
    const bottomRowBounds = rowModel.getRowBounds(bottomDisplayedRowIndex);
    if (bottomRowBounds) {
      bottomRowBounds.rowIndex = bottomDisplayedRowIndex;
    }
    this.bottomRowBounds = bottomRowBounds;
    this.calculatePixelOffset();
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  calculatePixelOffset() {
    var _a4, _b2;
    const value = (_b2 = (_a4 = this.topRowBounds) == null ? void 0 : _a4.rowTop) != null ? _b2 : 0;
    if (this.pixelOffset === value) {
      return;
    }
    this.pixelOffset = value;
    this.eventSvc.dispatchEvent({ type: "paginationPixelOffsetChanged" });
  }
};
var pinnedColumnModuleCSS = (
  /*css*/
  `.ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top{min-width:0;overflow:hidden;position:relative}.ag-pinned-left-sticky-top,.ag-pinned-right-sticky-top{height:100%;overflow:hidden;position:relative}.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{height:100%;overflow:hidden;width:100%}.ag-pinned-left-header,.ag-pinned-right-header{display:inline-block;height:100%;overflow:hidden;position:relative}.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible){.ag-horizontal-left-spacer:not(.ag-scroller-corner){border-right:var(--ag-pinned-column-border)}.ag-horizontal-right-spacer:not(.ag-scroller-corner){border-left:var(--ag-pinned-column-border)}}.ag-pinned-right-header{border-left:var(--ag-pinned-column-border)}.ag-pinned-left-header{border-right:var(--ag-pinned-column-border)}.ag-cell.ag-cell-first-right-pinned:not(.ag-cell-range-left,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-left:var(--ag-pinned-column-border)}.ag-cell.ag-cell-last-left-pinned:not(.ag-cell-range-right,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-right:var(--ag-pinned-column-border)}.ag-pinned-left-header .ag-header-cell-resize:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}.ag-pinned-right-header .ag-header-cell-resize:after{left:50%}.ag-pinned-left-header .ag-header-cell-resize{right:-3px}.ag-pinned-right-header .ag-header-cell-resize{left:-3px}`
);
var SetPinnedWidthFeature = class extends BeanStub {
  constructor(isLeft, elements) {
    super();
    this.isLeft = isLeft;
    this.elements = elements;
    this.getWidth = isLeft ? () => this.beans.pinnedCols.leftWidth : () => this.beans.pinnedCols.rightWidth;
  }
  postConstruct() {
    this.addManagedEventListeners({
      [`${this.isLeft ? "left" : "right"}PinnedWidthChanged`]: this.onPinnedWidthChanged.bind(this)
    });
  }
  onPinnedWidthChanged() {
    const width = this.getWidth();
    const displayed = width > 0;
    for (const element of this.elements) {
      if (element) {
        _setDisplayed(element, displayed);
        _setFixedWidth(element, width);
      }
    }
  }
};
var PinnedColumnService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "pinnedCols";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCtrl = p.gridBodyCtrl;
    });
    const listener = this.checkContainerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: listener,
      displayedColumnsWidthChanged: listener
    });
    this.addManagedPropertyListener("domLayout", listener);
  }
  checkContainerWidths() {
    const { gos, visibleCols, eventSvc } = this.beans;
    const printLayout = _isDomLayout(gos, "print");
    const newLeftWidth = printLayout ? 0 : visibleCols.getColsLeftWidth();
    const newRightWidth = printLayout ? 0 : visibleCols.getDisplayedColumnsRightWidth();
    if (newLeftWidth != this.leftWidth) {
      this.leftWidth = newLeftWidth;
      eventSvc.dispatchEvent({ type: "leftPinnedWidthChanged" });
    }
    if (newRightWidth != this.rightWidth) {
      this.rightWidth = newRightWidth;
      eventSvc.dispatchEvent({ type: "rightPinnedWidthChanged" });
    }
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const eBodyViewport = this.gridBodyCtrl.eBodyViewport;
    const bodyWidth = _getInnerWidth(eBodyViewport);
    if (bodyWidth <= 50) {
      return;
    }
    const processedColumnsToRemove = this.getPinnedColumnsOverflowingViewport(bodyWidth - 50);
    const processUnpinnedColumns = this.gos.getCallback("processUnpinnedColumns");
    const { columns, hasLockedPinned } = processedColumnsToRemove;
    let columnsToRemove = columns;
    if (!columnsToRemove.length && !hasLockedPinned) {
      return;
    }
    if (processUnpinnedColumns) {
      const params = {
        columns: columnsToRemove,
        viewportWidth: bodyWidth
      };
      columnsToRemove = processUnpinnedColumns(params);
    }
    if (!columnsToRemove || !columnsToRemove.length) {
      return;
    }
    columnsToRemove = columnsToRemove.filter((col) => !isRowNumberCol(col));
    this.setColsPinned(columnsToRemove, null, "viewportSizeFeature");
  }
  createPinnedWidthFeature(isLeft, ...elements) {
    return new SetPinnedWidthFeature(isLeft, elements);
  }
  setColsPinned(keys, pinned, source) {
    const { colModel, colAnimation, visibleCols, gos } = this.beans;
    if (!colModel.cols) {
      return;
    }
    if (!(keys == null ? void 0 : keys.length)) {
      return;
    }
    if (_isDomLayout(gos, "print")) {
      _warn(37);
      return;
    }
    colAnimation == null ? void 0 : colAnimation.start();
    let actualPinned;
    if (pinned === true || pinned === "left") {
      actualPinned = "left";
    } else if (pinned === "right") {
      actualPinned = "right";
    } else {
      actualPinned = null;
    }
    const updatedCols = [];
    keys.forEach((key) => {
      if (!key) {
        return;
      }
      const column = colModel.getCol(key);
      if (!column) {
        return;
      }
      if (column.getPinned() !== actualPinned) {
        this.setColPinned(column, actualPinned);
        updatedCols.push(column);
      }
    });
    if (updatedCols.length) {
      visibleCols.refresh(source);
      dispatchColumnPinnedEvent(this.eventSvc, updatedCols, source);
    }
    colAnimation == null ? void 0 : colAnimation.finish();
  }
  initCol(column) {
    const { pinned, initialPinned } = column.colDef;
    if (pinned !== void 0) {
      this.setColPinned(column, pinned);
    } else {
      this.setColPinned(column, initialPinned);
    }
  }
  setColPinned(column, pinned) {
    if (pinned === true || pinned === "left") {
      column.pinned = "left";
    } else if (pinned === "right") {
      column.pinned = "right";
    } else {
      column.pinned = null;
    }
    column.dispatchStateUpdatedEvent("pinned");
  }
  setupHeaderPinnedWidth(ctrl) {
    const { scrollVisibleSvc } = this.beans;
    if (ctrl.pinned == null) {
      return;
    }
    const pinningLeft = ctrl.pinned === "left";
    const pinningRight = ctrl.pinned === "right";
    ctrl.hidden = true;
    const listener = () => {
      const width = pinningLeft ? this.leftWidth : this.rightWidth;
      if (width == null) {
        return;
      }
      const hidden = width == 0;
      const hiddenChanged = ctrl.hidden !== hidden;
      const isRtl = this.gos.get("enableRtl");
      const scrollbarWidth = scrollVisibleSvc.getScrollbarWidth();
      const addPaddingForScrollbar = scrollVisibleSvc.verticalScrollShowing && (isRtl && pinningLeft || !isRtl && pinningRight);
      const widthWithPadding = addPaddingForScrollbar ? width + scrollbarWidth : width;
      ctrl.comp.setPinnedContainerWidth(`${widthWithPadding}px`);
      ctrl.comp.setDisplayed(!hidden);
      if (hiddenChanged) {
        ctrl.hidden = hidden;
        ctrl.refresh();
      }
    };
    ctrl.addManagedEventListeners({
      leftPinnedWidthChanged: listener,
      rightPinnedWidthChanged: listener,
      scrollVisibilityChanged: listener,
      scrollbarWidthChanged: listener
    });
  }
  getHeaderResizeDiff(diff, column) {
    const pinned = column.getPinned();
    if (pinned) {
      const { leftWidth, rightWidth } = this;
      const bodyWidth = _getInnerWidth(this.beans.ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
      if (leftWidth + rightWidth + diff > bodyWidth) {
        if (bodyWidth > leftWidth + rightWidth) {
          diff = bodyWidth - leftWidth - rightWidth;
        } else {
          return 0;
        }
      }
    }
    return diff;
  }
  getPinnedColumnsOverflowingViewport(viewportWidth) {
    var _a4, _b2;
    const pinnedRightWidth = (_a4 = this.rightWidth) != null ? _a4 : 0;
    const pinnedLeftWidth = (_b2 = this.leftWidth) != null ? _b2 : 0;
    const totalPinnedWidth = pinnedRightWidth + pinnedLeftWidth;
    let hasLockedPinned = false;
    if (totalPinnedWidth < viewportWidth) {
      return { columns: [], hasLockedPinned };
    }
    const { visibleCols } = this.beans;
    const pinnedLeftColumns = [...visibleCols.leftCols];
    const pinnedRightColumns = [...visibleCols.rightCols];
    let indexRight = 0;
    let indexLeft = 0;
    const totalWidthRemoved = 0;
    const columnsToRemove = [];
    let spaceNecessary = totalPinnedWidth - totalWidthRemoved - viewportWidth;
    while ((indexLeft < pinnedLeftColumns.length || indexRight < pinnedRightColumns.length) && spaceNecessary > 0) {
      if (indexRight < pinnedRightColumns.length) {
        const currentColumn = pinnedRightColumns[indexRight++];
        if (currentColumn.colDef.lockPinned) {
          hasLockedPinned = true;
          continue;
        }
        spaceNecessary -= currentColumn.getActualWidth();
        columnsToRemove.push(currentColumn);
      }
      if (indexLeft < pinnedLeftColumns.length && spaceNecessary > 0) {
        const currentColumn = pinnedLeftColumns[indexLeft++];
        if (currentColumn.colDef.lockPinned) {
          hasLockedPinned = true;
          continue;
        }
        spaceNecessary -= currentColumn.getActualWidth();
        columnsToRemove.push(currentColumn);
      }
    }
    return { columns: columnsToRemove, hasLockedPinned };
  }
};
var PinnedColumnModule = {
  moduleName: "PinnedColumn",
  version: VERSION,
  beans: [PinnedColumnService],
  css: [pinnedColumnModuleCSS]
};
var AriaAnnouncementService = class extends BeanStub {
  constructor() {
    super();
    this.beanName = "ariaAnnounce";
    this.descriptionContainer = null;
    this.pendingAnnouncements = /* @__PURE__ */ new Map();
    this.lastAnnouncement = "";
    this.updateAnnouncement = _debounce(this, this.updateAnnouncement.bind(this), 200);
  }
  postConstruct() {
    const beans = this.beans;
    const eDocument = _getDocument(beans);
    const div = this.descriptionContainer = eDocument.createElement("div");
    div.classList.add("ag-aria-description-container");
    _setAriaLive(div, "polite");
    _setAriaRelevant(div, "additions text");
    _setAriaAtomic(div, true);
    beans.eGridDiv.appendChild(div);
  }
  /**
   * @param key used for debouncing calls
   */
  announceValue(value, key) {
    this.pendingAnnouncements.set(key, value);
    this.updateAnnouncement();
  }
  updateAnnouncement() {
    if (!this.descriptionContainer) {
      return;
    }
    const value = Array.from(this.pendingAnnouncements.values()).join(". ");
    this.pendingAnnouncements.clear();
    this.descriptionContainer.textContent = "";
    setTimeout(() => {
      this.handleAnnouncementUpdate(value);
    }, 50);
  }
  handleAnnouncementUpdate(value) {
    if (!this.isAlive() || !this.descriptionContainer) {
      return;
    }
    let valueToAnnounce = value;
    if (valueToAnnounce == null || valueToAnnounce.replace(/[ .]/g, "") == "") {
      this.lastAnnouncement = "";
      return;
    }
    if (this.lastAnnouncement === valueToAnnounce) {
      valueToAnnounce = `${valueToAnnounce}\u200B`;
    }
    this.lastAnnouncement = valueToAnnounce;
    this.descriptionContainer.textContent = valueToAnnounce;
  }
  destroy() {
    var _a4;
    super.destroy();
    const { descriptionContainer } = this;
    if (descriptionContainer) {
      _clearElement(descriptionContainer);
      (_a4 = descriptionContainer.parentElement) == null ? void 0 : _a4.removeChild(descriptionContainer);
    }
    this.descriptionContainer = null;
    this.pendingAnnouncements.clear();
  }
};
var AriaModule = {
  moduleName: "Aria",
  version: VERSION,
  beans: [AriaAnnouncementService]
};
var columnDelayRenderCSS = (
  /*css*/
  `:where(.ag-delay-render){.ag-cell,.ag-header-cell,.ag-header-group-cell,.ag-row,.ag-spanned-cell-wrapper{visibility:hidden}}`
);
var HideClass = "ag-delay-render";
var ColumnDelayRenderService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "colDelayRenderSvc";
    this.hideRequested = false;
    this.alreadyRevealed = false;
    this.timesRetried = 0;
    this.requesters = /* @__PURE__ */ new Set();
  }
  hideColumns(key) {
    if (this.alreadyRevealed || this.requesters.has(key)) {
      return;
    }
    this.requesters.add(key);
    if (!this.hideRequested) {
      this.beans.ctrlsSvc.whenReady(this, (p) => {
        p.gridBodyCtrl.eGridBody.classList.add(HideClass);
      });
      this.hideRequested = true;
    }
  }
  revealColumns(key) {
    if (this.alreadyRevealed || !this.isAlive()) {
      return;
    }
    this.requesters.delete(key);
    if (this.requesters.size > 0) {
      return;
    }
    const { renderStatus, ctrlsSvc } = this.beans;
    if (renderStatus) {
      if (!renderStatus.areHeaderCellsRendered() && this.timesRetried < 5) {
        this.timesRetried++;
        setTimeout(() => this.revealColumns(key));
        return;
      }
      this.timesRetried = 0;
    }
    ctrlsSvc.getGridBodyCtrl().eGridBody.classList.remove(HideClass);
    this.alreadyRevealed = true;
  }
};
var ColumnDelayRenderModule = {
  moduleName: "ColumnDelayRender",
  version: VERSION,
  beans: [ColumnDelayRenderService],
  css: [columnDelayRenderCSS]
};
function showLoadingOverlay(beans) {
  var _a4;
  (_a4 = beans.overlays) == null ? void 0 : _a4.showLoadingOverlay();
}
function showNoRowsOverlay(beans) {
  var _a4;
  (_a4 = beans.overlays) == null ? void 0 : _a4.showNoRowsOverlay();
}
function hideOverlay(beans) {
  var _a4;
  (_a4 = beans.overlays) == null ? void 0 : _a4.hideOverlay();
}
var overlayWrapperComponentCSS = (
  /*css*/
  `.ag-overlay{inset:0;pointer-events:none;position:absolute;z-index:2}.ag-overlay-panel,.ag-overlay-wrapper{display:flex;height:100%;width:100%}.ag-overlay-wrapper{align-items:center;flex:none;justify-content:center;text-align:center}.ag-overlay-loading-wrapper{pointer-events:all}.ag-overlay-loading-center{background:var(--ag-background-color);border:solid var(--ag-border-width) var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-popup-shadow);padding:var(--ag-spacing)}`
);
var OverlayWrapperElement = {
  tag: "div",
  cls: "ag-overlay",
  role: "presentation",
  children: [
    {
      tag: "div",
      cls: "ag-overlay-panel",
      role: "presentation",
      children: [{ tag: "div", ref: "eOverlayWrapper", cls: "ag-overlay-wrapper", role: "presentation" }]
    }
  ]
};
var OverlayWrapperComponent = class extends Component {
  constructor() {
    super(OverlayWrapperElement);
    this.eOverlayWrapper = RefPlaceholder;
    this.activePromise = null;
    this.activeOverlay = null;
    this.updateListenerDestroyFunc = null;
    this.activeCssClass = null;
    this.elToFocusAfter = null;
    this.registerCSS(overlayWrapperComponentCSS);
  }
  handleKeyDown(e) {
    if (e.key !== KeyCode.TAB || e.defaultPrevented || _isStopPropagationForAgGrid(e)) {
      return;
    }
    const beans = this.beans;
    const nextEl = _findNextFocusableElement(beans, this.eOverlayWrapper, false, e.shiftKey);
    if (nextEl) {
      return;
    }
    let isFocused = false;
    if (e.shiftKey) {
      isFocused = beans.focusSvc.focusGridView({
        column: _last(beans.visibleCols.allCols),
        backwards: true,
        canFocusOverlay: false
      });
    } else {
      isFocused = _focusNextGridCoreContainer(beans, false);
    }
    if (isFocused) {
      e.preventDefault();
    }
  }
  updateLayoutClasses(cssClass, params) {
    const overlayWrapperClassList = this.eOverlayWrapper.classList;
    const { AUTO_HEIGHT, NORMAL, PRINT } = LayoutCssClasses;
    overlayWrapperClassList.toggle(AUTO_HEIGHT, params.autoHeight);
    overlayWrapperClassList.toggle(NORMAL, params.normal);
    overlayWrapperClassList.toggle(PRINT, params.print);
  }
  postConstruct() {
    this.createManagedBean(new LayoutFeature(this));
    this.setDisplayed(false, { skipAriaHidden: true });
    this.beans.overlays.setOverlayWrapperComp(this);
    this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
  }
  setWrapperTypeClass(overlayWrapperCssClass) {
    const overlayWrapperClassList = this.eOverlayWrapper.classList;
    if (this.activeCssClass) {
      overlayWrapperClassList.toggle(this.activeCssClass, false);
    }
    this.activeCssClass = overlayWrapperCssClass;
    overlayWrapperClassList.toggle(overlayWrapperCssClass, true);
  }
  showOverlay(overlayComponentPromise, overlayWrapperCssClass, exclusive, gridOption) {
    this.setWrapperTypeClass(overlayWrapperCssClass);
    this.destroyActiveOverlay();
    this.elToFocusAfter = null;
    this.activePromise = overlayComponentPromise;
    if (!overlayComponentPromise) {
      return;
    }
    this.setDisplayed(true, { skipAriaHidden: true });
    if (exclusive && this.isGridFocused()) {
      const activeElement = _getActiveDomElement(this.beans);
      if (activeElement && !_isNothingFocused(this.beans)) {
        this.elToFocusAfter = activeElement;
      }
    }
    overlayComponentPromise.then((comp) => {
      if (this.activePromise !== overlayComponentPromise) {
        if (this.activeOverlay !== comp) {
          this.destroyBean(comp);
          comp = null;
        }
        return;
      }
      this.activePromise = null;
      if (!comp) {
        return;
      }
      if (this.activeOverlay !== comp) {
        this.eOverlayWrapper.appendChild(comp.getGui());
        this.activeOverlay = comp;
        if (gridOption) {
          const component = comp;
          this.updateListenerDestroyFunc = this.addManagedPropertyListener(gridOption, ({ currentValue }) => {
            var _a4;
            (_a4 = component.refresh) == null ? void 0 : _a4.call(component, _addGridCommonParams(this.gos, { ...currentValue != null ? currentValue : {} }));
          });
        }
      }
      if (exclusive && this.isGridFocused()) {
        _focusInto(this.eOverlayWrapper);
      }
    });
  }
  updateOverlayWrapperPaddingTop(padding) {
    this.eOverlayWrapper.style.setProperty("padding-top", `${padding}px`);
  }
  destroyActiveOverlay() {
    var _a4;
    this.activePromise = null;
    const activeOverlay = this.activeOverlay;
    if (!activeOverlay) {
      return;
    }
    let elementToFocus = this.elToFocusAfter;
    this.activeOverlay = null;
    this.elToFocusAfter = null;
    if (elementToFocus && !this.isGridFocused()) {
      elementToFocus = null;
    }
    const updateListenerDestroyFunc = this.updateListenerDestroyFunc;
    if (updateListenerDestroyFunc) {
      updateListenerDestroyFunc();
      this.updateListenerDestroyFunc = null;
    }
    this.destroyBean(activeOverlay);
    _clearElement(this.eOverlayWrapper);
    (_a4 = elementToFocus == null ? void 0 : elementToFocus.focus) == null ? void 0 : _a4.call(elementToFocus, { preventScroll: true });
  }
  hideOverlay() {
    this.destroyActiveOverlay();
    this.setDisplayed(false, { skipAriaHidden: true });
  }
  isGridFocused() {
    const activeEl = _getActiveDomElement(this.beans);
    return !!activeEl && this.beans.eGridDiv.contains(activeEl);
  }
  destroy() {
    this.elToFocusAfter = null;
    this.destroyActiveOverlay();
    this.beans.overlays.setOverlayWrapperComp(void 0);
    super.destroy();
  }
};
var OverlayWrapperSelector = {
  selector: "AG-OVERLAY-WRAPPER",
  component: OverlayWrapperComponent
};
var OverlayService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "overlays";
    this.state = 0;
    this.showInitialOverlay = true;
    this.wrapperPadding = 0;
  }
  postConstruct() {
    this.isClientSide = _isClientSideRowModel(this.gos);
    this.isServerSide = !this.isClientSide && _isServerSideRowModel(this.gos);
    const updateOverlayVisibility = () => this.updateOverlayVisibility();
    this.addManagedEventListeners({
      newColumnsLoaded: updateOverlayVisibility,
      rowDataUpdated: updateOverlayVisibility,
      gridSizeChanged: this.refreshWrapperPadding.bind(this),
      rowCountReady: () => {
        this.showInitialOverlay = false;
        this.updateOverlayVisibility();
      }
    });
    this.addManagedPropertyListener("loading", updateOverlayVisibility);
  }
  setOverlayWrapperComp(overlayWrapperComp) {
    this.eWrapper = overlayWrapperComp;
    this.updateOverlayVisibility();
  }
  /** Returns true if the overlay is visible. */
  isVisible() {
    return this.state !== 0 && !!this.eWrapper;
  }
  /** Returns true if the overlay is visible and is exclusive (popup over the grid) */
  isExclusive() {
    return this.state === 1 && !!this.eWrapper;
  }
  showLoadingOverlay() {
    this.showInitialOverlay = false;
    const gos = this.gos;
    const loading = gos.get("loading");
    if (!loading && (loading !== void 0 || gos.get("suppressLoadingOverlay"))) {
      return;
    }
    this.doShowLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.showInitialOverlay = false;
    const gos = this.gos;
    if (gos.get("loading") || gos.get("suppressNoRowsOverlay")) {
      return;
    }
    this.doShowNoRowsOverlay();
  }
  hideOverlay() {
    this.showInitialOverlay = false;
    if (this.gos.get("loading")) {
      _warn(99);
      return;
    }
    this.doHideOverlay();
  }
  getOverlayWrapperSelector() {
    return OverlayWrapperSelector;
  }
  getOverlayWrapperCompClass() {
    return OverlayWrapperComponent;
  }
  updateOverlayVisibility() {
    if (!this.eWrapper) {
      this.state = 0;
      return;
    }
    const {
      state,
      isClientSide,
      isServerSide,
      beans: { gos, colModel, rowModel }
    } = this;
    let loading = this.gos.get("loading");
    if (loading !== void 0) {
      this.showInitialOverlay = false;
    }
    if (this.showInitialOverlay && loading === void 0 && !gos.get("suppressLoadingOverlay")) {
      loading = !gos.get("columnDefs") || !colModel.ready || !gos.get("rowData") && isClientSide;
    }
    if (loading) {
      if (state !== 1) {
        this.doShowLoadingOverlay();
      }
    } else {
      this.showInitialOverlay = false;
      if (isClientSide && rowModel.isEmpty() && !gos.get("suppressNoRowsOverlay")) {
        if (state !== 2) {
          this.doShowNoRowsOverlay();
        }
      } else if (state === 1 || !isServerSide && state !== 0) {
        this.doHideOverlay();
      }
    }
  }
  doShowLoadingOverlay() {
    if (!this.eWrapper) {
      return;
    }
    this.state = 1;
    this.showOverlay(
      _getLoadingOverlayCompDetails(this.beans.userCompFactory, _addGridCommonParams(this.gos, {})),
      "ag-overlay-loading-wrapper",
      "loadingOverlayComponentParams"
    );
    this.updateExclusive();
  }
  doShowNoRowsOverlay() {
    if (!this.eWrapper) {
      return;
    }
    this.state = 2;
    this.showOverlay(
      _getNoRowsOverlayCompDetails(this.beans.userCompFactory, _addGridCommonParams(this.gos, {})),
      "ag-overlay-no-rows-wrapper",
      "noRowsOverlayComponentParams"
    );
    this.updateExclusive();
  }
  doHideOverlay() {
    if (!this.eWrapper) {
      return;
    }
    this.state = 0;
    this.eWrapper.hideOverlay();
    this.updateExclusive();
  }
  showOverlay(compDetails, wrapperCssClass, gridOption) {
    var _a4, _b2;
    const promise = (_a4 = compDetails == null ? void 0 : compDetails.newAgStackInstance()) != null ? _a4 : null;
    (_b2 = this.eWrapper) == null ? void 0 : _b2.showOverlay(promise, wrapperCssClass, this.isExclusive(), gridOption);
    this.refreshWrapperPadding();
  }
  updateExclusive() {
    const wasExclusive = this.exclusive;
    this.exclusive = this.isExclusive();
    if (this.exclusive !== wasExclusive) {
      this.eventSvc.dispatchEvent({
        type: "overlayExclusiveChanged"
      });
    }
  }
  refreshWrapperPadding() {
    const eWrapper = this.eWrapper;
    if (!eWrapper) {
      return;
    }
    let newPadding = 0;
    if (this.state === 2) {
      const headerCtrl = this.beans.ctrlsSvc.get("gridHeaderCtrl");
      const headerHeight = (headerCtrl == null ? void 0 : headerCtrl.headerHeight) || 0;
      newPadding = headerHeight;
    } else if (this.wrapperPadding !== 0) {
      newPadding = 0;
    }
    if (this.wrapperPadding === newPadding) {
      return;
    }
    this.wrapperPadding = newPadding;
    eWrapper.updateOverlayWrapperPaddingTop(newPadding);
  }
};
var OverlayModule = {
  moduleName: "Overlay",
  version: VERSION,
  userComponents: {
    agLoadingOverlay: LoadingOverlayComponent2,
    agNoRowsOverlay: NoRowsOverlayComponent2
  },
  apiFunctions: {
    showLoadingOverlay,
    showNoRowsOverlay,
    hideOverlay
  },
  beans: [OverlayService]
};
var RowContainerHeightService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowContainerHeight";
    this.scrollY = 0;
    this.uiBodyHeight = 0;
  }
  postConstruct() {
    this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) });
    this.maxDivHeight = _getMaxDivHeight();
    _logIfDebug(this.gos, "RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
  }
  updateOffset() {
    if (!this.stretching) {
      return;
    }
    const newScrollY = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition().top;
    const newBodyHeight = this.getUiBodyHeight();
    const atLeastOneChanged = newScrollY !== this.scrollY || newBodyHeight !== this.uiBodyHeight;
    if (atLeastOneChanged) {
      this.scrollY = newScrollY;
      this.uiBodyHeight = newBodyHeight;
      this.calculateOffset();
    }
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight);
    this.pixelsToShave = this.modelHeight - this.uiContainerHeight;
    this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const scrollPercent = this.scrollY / this.maxScrollY;
    const divStretchOffset = scrollPercent * this.pixelsToShave;
    _logIfDebug(
      this.gos,
      `RowContainerHeightService - Div Stretch Offset = ${divStretchOffset} (${this.pixelsToShave} * ${scrollPercent})`
    );
    this.setDivStretchOffset(divStretchOffset);
  }
  setUiContainerHeight(height) {
    if (height !== this.uiContainerHeight) {
      this.uiContainerHeight = height;
      this.eventSvc.dispatchEvent({ type: "rowContainerHeightChanged" });
    }
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight);
    this.pixelsToShave = 0;
    this.setDivStretchOffset(0);
  }
  setDivStretchOffset(newOffset) {
    const newOffsetFloor = typeof newOffset === "number" ? Math.floor(newOffset) : null;
    if (this.divStretchOffset === newOffsetFloor) {
      return;
    }
    this.divStretchOffset = newOffsetFloor;
    this.eventSvc.dispatchEvent({ type: "heightScaleChanged" });
  }
  setModelHeight(modelHeight) {
    this.modelHeight = modelHeight;
    this.stretching = modelHeight != null && // null happens when in print layout
    this.maxDivHeight > 0 && modelHeight > this.maxDivHeight;
    if (this.stretching) {
      this.calculateOffset();
    } else {
      this.clearOffset();
    }
  }
  getRealPixelPosition(modelPixel) {
    return modelPixel - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const pos = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
    return pos.bottom - pos.top;
  }
  getScrollPositionForPixel(rowTop) {
    if (this.pixelsToShave <= 0) {
      return rowTop;
    }
    const modelMaxScroll = this.modelHeight - this.getUiBodyHeight();
    const scrollPercent = rowTop / modelMaxScroll;
    const scrollPixel = this.maxScrollY * scrollPercent;
    return scrollPixel;
  }
};
var ROW_ANIMATION_TIMEOUT = 400;
var RowRenderer = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowRenderer";
    this.destroyFuncsForColumnListeners = [];
    this.rowCtrlsByRowIndex = {};
    this.zombieRowCtrls = {};
    this.allRowCtrls = [];
    this.topRowCtrls = [];
    this.bottomRowCtrls = [];
    this.refreshInProgress = false;
    this.dataFirstRenderedFired = false;
    this.setupRangeSelectionListeners = () => {
      const onCellSelectionChanged = () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellSelectionChanged());
      };
      const onColumnMovedPinnedVisible = () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.updateRangeBordersIfRangeCount());
      };
      const addCellSelectionListeners = () => {
        this.eventSvc.addListener("cellSelectionChanged", onCellSelectionChanged);
        this.eventSvc.addListener("columnMoved", onColumnMovedPinnedVisible);
        this.eventSvc.addListener("columnPinned", onColumnMovedPinnedVisible);
        this.eventSvc.addListener("columnVisible", onColumnMovedPinnedVisible);
      };
      const removeCellSelectionListeners = () => {
        this.eventSvc.removeListener("cellSelectionChanged", onCellSelectionChanged);
        this.eventSvc.removeListener("columnMoved", onColumnMovedPinnedVisible);
        this.eventSvc.removeListener("columnPinned", onColumnMovedPinnedVisible);
        this.eventSvc.removeListener("columnVisible", onColumnMovedPinnedVisible);
      };
      this.addDestroyFunc(() => removeCellSelectionListeners());
      this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
        const isEnabled = _isCellSelectionEnabled(this.gos);
        if (isEnabled) {
          addCellSelectionListeners();
        } else {
          removeCellSelectionListeners();
        }
      });
      const cellSelectionEnabled = _isCellSelectionEnabled(this.gos);
      if (cellSelectionEnabled) {
        addCellSelectionListeners();
      }
    };
  }
  wireBeans(beans) {
    this.pageBounds = beans.pageBounds;
    this.colModel = beans.colModel;
    this.pinnedRowModel = beans.pinnedRowModel;
    this.rowModel = beans.rowModel;
    this.focusSvc = beans.focusSvc;
    this.rowContainerHeight = beans.rowContainerHeight;
    this.ctrlsSvc = beans.ctrlsSvc;
    this.editSvc = beans.editSvc;
  }
  postConstruct() {
    this.ctrlsSvc.whenReady(this, (p) => {
      this.gridBodyCtrl = p.gridBodyCtrl;
      this.initialise();
    });
  }
  initialise() {
    this.addManagedEventListeners({
      paginationChanged: this.onPageLoaded.bind(this),
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
      pinnedRowsChanged: this.onPinnedRowsChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      bodyScroll: this.onBodyScroll.bind(this),
      bodyHeightChanged: this.redraw.bind(this, {})
    });
    this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged());
    this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw());
    this.addManagedPropertyListener("suppressCellFocus", (e) => this.onSuppressCellFocusChanged(e.currentValue));
    this.addManagedPropertyListeners(
      [
        "groupSuppressBlankHeader",
        "getBusinessKeyForNode",
        "fullWidthCellRenderer",
        "fullWidthCellRendererParams",
        "suppressStickyTotalRow",
        "groupRowRenderer",
        "groupRowRendererParams",
        // maybe only needs to refresh FW rows...
        "loadingCellRenderer",
        "loadingCellRendererParams",
        "detailCellRenderer",
        "detailCellRendererParams",
        "enableRangeSelection",
        "enableCellTextSelection"
      ],
      () => this.redrawRows()
    );
    this.addManagedPropertyListener("cellSelection", ({ currentValue, previousValue }) => {
      if (!previousValue && currentValue || previousValue && !currentValue) {
        this.redrawRows();
      }
    });
    const { stickyRowSvc, gos, showRowGroupCols } = this.beans;
    if (showRowGroupCols) {
      this.addManagedPropertyListener("showOpenedGroup", () => {
        const columns = showRowGroupCols.getShowRowGroupCols();
        if (columns.length) {
          this.refreshCells({ columns, force: true });
        }
      });
    }
    if (stickyRowSvc) {
      this.stickyRowFeature = stickyRowSvc.createStickyRowFeature(
        this,
        this.createRowCon.bind(this),
        this.destroyRowCtrls.bind(this)
      );
    } else {
      const gridBodyCtrl = this.gridBodyCtrl;
      gridBodyCtrl.setStickyTopHeight(0);
      gridBodyCtrl.setStickyBottomHeight(0);
    }
    this.registerCellEventListeners();
    this.initialiseCache();
    this.printLayout = _isDomLayout(gos, "print");
    this.embedFullWidthRows = this.printLayout || gos.get("embedFullWidthRows");
    this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const countProp = this.getKeepDetailRowsCount();
      const count = countProp != null ? countProp : 3;
      this.cachedRowCtrls = new RowCtrlCache(count);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.stickyRowFeature) == null ? void 0 : _a4.stickyTopRowCtrls) != null ? _b2 : [];
  }
  getStickyBottomRowCtrls() {
    var _a4, _b2;
    return (_b2 = (_a4 = this.stickyRowFeature) == null ? void 0 : _a4.stickyBottomRowCtrls) != null ? _b2 : [];
  }
  updateAllRowCtrls() {
    var _a4, _b2;
    const liveList = Object.values(this.rowCtrlsByRowIndex);
    const zombieList = Object.values(this.zombieRowCtrls);
    const cachedList = (_b2 = (_a4 = this.cachedRowCtrls) == null ? void 0 : _a4.getEntries()) != null ? _b2 : [];
    if (zombieList.length > 0 || cachedList.length > 0) {
      this.allRowCtrls = [...liveList, ...zombieList, ...cachedList];
    } else {
      this.allRowCtrls = liveList;
    }
  }
  /**
   * Checks if the cell is rendered or not. Also returns true if row ctrl is present but has not rendered
   * cells yet.
   * @returns true if cellCtrl is present, or if the row is present but has not rendered rows yet
   */
  isCellBeingRendered(rowIndex, column) {
    var _a4;
    const rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
    if (!column || !rowCtrl) {
      return !!rowCtrl;
    }
    if (rowCtrl.isFullWidth()) {
      return true;
    }
    const spannedCell = (_a4 = this.beans.spannedRowRenderer) == null ? void 0 : _a4.getCellByPosition({ rowIndex, column, rowPinned: null });
    return !!spannedCell || !!rowCtrl.getCellCtrl(column) || !rowCtrl.isRowRendered();
  }
  /**
   * Notifies all row and cell controls of any change in focused cell.
   * @param event cell focused event
   */
  updateCellFocus(event) {
    this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onCellFocused(event));
    this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onFullWidthRowFocused(event));
  }
  /**
   * Called when a new cell is focused in the grid
   * - if the focused cell isn't rendered; re-draw rows to dry to render it
   * - subsequently updates all cell and row controls with the new focused cell
   * @param event cell focused event
   */
  onCellFocusChanged(event) {
    var _a4;
    if (event && event.rowIndex != null && !event.rowPinned) {
      const col = (_a4 = this.beans.colModel.getCol(event.column)) != null ? _a4 : void 0;
      if (!this.isCellBeingRendered(event.rowIndex, col)) {
        this.redraw();
      }
    }
    this.updateCellFocus(event);
  }
  onSuppressCellFocusChanged(suppressCellFocus) {
    this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onSuppressCellFocusChanged(suppressCellFocus));
    this.getFullWidthRowCtrls().forEach((rowCtrl) => rowCtrl.onSuppressCellFocusChanged(suppressCellFocus));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedEventListeners({
      cellFocused: (event) => this.onCellFocusChanged(event),
      cellFocusCleared: () => this.updateCellFocus(),
      flashCells: (event) => {
        const { cellFlashSvc } = this.beans;
        if (cellFlashSvc) {
          this.getAllCellCtrls().forEach((cellCtrl) => cellFlashSvc.onFlashCells(cellCtrl, event));
        }
      },
      columnHoverChanged: () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onColumnHover());
      },
      displayedColumnsChanged: () => {
        this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onDisplayedColumnsChanged());
      },
      displayedColumnsWidthChanged: () => {
        if (this.printLayout) {
          this.getAllCellCtrls().forEach((cellCtrl) => cellCtrl.onLeftChanged());
        }
      }
    });
    this.setupRangeSelectionListeners();
    this.refreshListenersToColumnsForCellComps();
    this.addManagedEventListeners({
      gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this)
    });
    this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((func) => func());
    this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners();
    const cols = this.colModel.getCols();
    cols.forEach((col) => {
      const forEachCellWithThisCol = (callback) => {
        this.getAllCellCtrls().forEach((cellCtrl) => {
          if (cellCtrl.column === col) {
            callback(cellCtrl);
          }
        });
      };
      const leftChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onLeftChanged());
      };
      const widthChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onWidthChanged());
      };
      const firstRightPinnedChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onFirstRightPinnedChanged());
      };
      const lastLeftPinnedChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onLastLeftPinnedChanged());
      };
      const colDefChangedListener = () => {
        forEachCellWithThisCol((cellCtrl) => cellCtrl.onColDefChanged());
      };
      col.__addEventListener("leftChanged", leftChangedListener);
      col.__addEventListener("widthChanged", widthChangedListener);
      col.__addEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
      col.__addEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
      col.__addEventListener("colDefChanged", colDefChangedListener);
      this.destroyFuncsForColumnListeners.push(() => {
        col.__removeEventListener("leftChanged", leftChangedListener);
        col.__removeEventListener("widthChanged", widthChangedListener);
        col.__removeEventListener("firstRightPinnedChanged", firstRightPinnedChangedListener);
        col.__removeEventListener("lastLeftPinnedChanged", lastLeftPinnedChangedListener);
        col.__removeEventListener("colDefChanged", colDefChangedListener);
      });
    });
  }
  onDomLayoutChanged() {
    const printLayout = _isDomLayout(this.gos, "print");
    const embedFullWidthRows = printLayout || this.gos.get("embedFullWidthRows");
    const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;
    this.printLayout = printLayout;
    this.embedFullWidthRows = embedFullWidthRows;
    if (destroyRows) {
      this.redrawAfterModelUpdate({ domLayoutChanged: true });
    }
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0;
    this.lastRenderedRow = -1;
    const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(rowIndexesToRemove);
  }
  onPageLoaded(event) {
    const params = {
      recycleRows: event.keepRenderedRows,
      animate: event.animate,
      newData: event.newData,
      newPage: event.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: true
    };
    this.redrawAfterModelUpdate(params);
  }
  /**
   * @param column AgColumn
   * @returns An array with HTMLElement for every cell of the column passed as param.
   * If the cell is spanning across multiple columns, it only returns the html element
   * if the column passed is the first column of the span (used for auto width calculation).
   */
  getAllCellsNotSpanningForColumn(column) {
    const res = [];
    this.getAllRowCtrls().forEach((rowCtrl) => {
      var _a4;
      const eCell = (_a4 = rowCtrl.getCellCtrl(column, true)) == null ? void 0 : _a4.eGui;
      if (eCell) {
        res.push(eCell);
      }
    });
    return res;
  }
  refreshFloatingRowComps(recycleRows = true) {
    this.refreshFloatingRows(this.topRowCtrls, "top", recycleRows);
    this.refreshFloatingRows(this.bottomRowCtrls, "bottom", recycleRows);
  }
  /**
   * Determines which row controllers need to be destroyed and re-created vs which ones can
   * be re-used.
   *
   * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
   *
   * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
   * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
   * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
   *
   * @param rowCtrls The list of existing row controllers
   * @param rowNodes The canonical list of row nodes that should have associated controllers
   */
  refreshFloatingRows(rowCtrls, floating, recycleRows) {
    var _a4;
    const { pinnedRowModel, beans, printLayout } = this;
    const rowCtrlMap = Object.fromEntries(rowCtrls.map((ctrl) => [ctrl.rowNode.id, ctrl]));
    pinnedRowModel == null ? void 0 : pinnedRowModel.forEachPinnedRow(floating, (node, i) => {
      const rowCtrl = rowCtrls[i];
      const rowCtrlDoesNotExist = rowCtrl && pinnedRowModel.getPinnedRowById(rowCtrl.rowNode.id, floating) === void 0;
      if (rowCtrlDoesNotExist) {
        rowCtrl.destroyFirstPass();
        rowCtrl.destroySecondPass();
      }
      if (node.id in rowCtrlMap && recycleRows) {
        rowCtrls[i] = rowCtrlMap[node.id];
        delete rowCtrlMap[node.id];
      } else {
        rowCtrls[i] = new RowCtrl(node, beans, false, false, printLayout);
      }
    });
    const rowNodeCount = (_a4 = floating === "top" ? pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedTopRowCount() : pinnedRowModel == null ? void 0 : pinnedRowModel.getPinnedBottomRowCount()) != null ? _a4 : 0;
    rowCtrls.length = rowNodeCount;
  }
  onPinnedRowDataChanged() {
    const params = {
      recycleRows: true
    };
    this.redrawAfterModelUpdate(params);
  }
  onPinnedRowsChanged() {
    this.redrawAfterModelUpdate({ recycleRows: true });
  }
  redrawRow(rowNode, suppressEvent = false) {
    var _a4, _b2;
    if (rowNode.sticky) {
      (_a4 = this.stickyRowFeature) == null ? void 0 : _a4.refreshStickyNode(rowNode);
    } else if ((_b2 = this.cachedRowCtrls) == null ? void 0 : _b2.has(rowNode)) {
      this.cachedRowCtrls.removeRow(rowNode);
      return;
    } else {
      const destroyAndRecreateCtrl = (dataStruct) => {
        const ctrl = dataStruct[rowNode.rowIndex];
        if (!ctrl) {
          return;
        }
        if (ctrl.rowNode !== rowNode) {
          return;
        }
        ctrl.destroyFirstPass();
        ctrl.destroySecondPass();
        dataStruct[rowNode.rowIndex] = this.createRowCon(rowNode, false, false);
      };
      switch (rowNode.rowPinned) {
        case "top":
          destroyAndRecreateCtrl(this.topRowCtrls);
          break;
        case "bottom":
          destroyAndRecreateCtrl(this.bottomRowCtrls);
          break;
        default:
          destroyAndRecreateCtrl(this.rowCtrlsByRowIndex);
          this.updateAllRowCtrls();
      }
    }
    if (!suppressEvent) {
      this.dispatchDisplayedRowsChanged(false);
    }
  }
  redrawRows(rowNodes) {
    const { editSvc } = this.beans;
    if (editSvc == null ? void 0 : editSvc.isEditing()) {
      if (editSvc.isBatchEditing()) {
        editSvc.cleanupEditors();
      } else {
        editSvc.stopEditing(void 0, { source: "api" });
      }
    }
    const partialRefresh = rowNodes != null;
    if (partialRefresh) {
      rowNodes == null ? void 0 : rowNodes.forEach((node) => this.redrawRow(node, true));
      this.dispatchDisplayedRowsChanged(false);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(params = {}) {
    var _a4;
    this.getLockOnRefresh();
    const focusedCell = (_a4 = this.beans.focusSvc) == null ? void 0 : _a4.getFocusCellToUseAfterRefresh();
    this.updateContainerHeights();
    this.scrollToTopIfNewData(params);
    const recycleRows = !params.domLayoutChanged && !!params.recycleRows;
    const animate = params.animate && _isAnimateRows(this.gos);
    const rowsToRecycle = recycleRows ? this.getRowsToRecycle() : null;
    if (!recycleRows) {
      this.removeAllRowComps();
    }
    this.workOutFirstAndLastRowsToRender();
    const { stickyRowFeature, gos } = this;
    if (stickyRowFeature) {
      stickyRowFeature.checkStickyRows();
      const extraHeight = stickyRowFeature.extraTopHeight + stickyRowFeature.extraBottomHeight;
      if (extraHeight) {
        this.updateContainerHeights(extraHeight);
      }
    }
    this.recycleRows(rowsToRecycle, animate);
    this.gridBodyCtrl.updateRowCount();
    if (!params.onlyBody) {
      this.refreshFloatingRowComps(gos.get("enableRowPinning") ? recycleRows : void 0);
    }
    this.dispatchDisplayedRowsChanged();
    if (focusedCell != null) {
      this.restoreFocusedCell(focusedCell);
    }
    this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(params) {
    var _a4;
    const scrollToTop = params.newData || params.newPage;
    const suppressScrollToTop = this.gos.get("suppressScrollOnNewData");
    if (scrollToTop && !suppressScrollToTop) {
      this.gridBodyCtrl.scrollFeature.scrollToTop();
      (_a4 = this.stickyRowFeature) == null ? void 0 : _a4.resetOffsets();
    }
  }
  updateContainerHeights(additionalHeight = 0) {
    const { rowContainerHeight } = this;
    if (this.printLayout) {
      rowContainerHeight.setModelHeight(null);
      return;
    }
    let containerHeight = this.pageBounds.getCurrentPageHeight();
    if (containerHeight === 0) {
      containerHeight = 1;
    }
    rowContainerHeight.setModelHeight(containerHeight + additionalHeight);
  }
  getLockOnRefresh() {
    var _a4, _b2;
    if (this.refreshInProgress) {
      throw new Error(_errMsg(252));
    }
    this.refreshInProgress = true;
    (_b2 = (_a4 = this.beans.frameworkOverrides).getLockOnRefresh) == null ? void 0 : _b2.call(_a4);
  }
  releaseLockOnRefresh() {
    var _a4, _b2;
    this.refreshInProgress = false;
    (_b2 = (_a4 = this.beans.frameworkOverrides).releaseLockOnRefresh) == null ? void 0 : _b2.call(_a4);
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(cellPosition) {
    if (!cellPosition) {
      return;
    }
    const focusSvc = this.beans.focusSvc;
    const cellToFocus = this.findPositionToFocus(cellPosition);
    if (!cellToFocus) {
      focusSvc.focusHeaderPosition({
        headerPosition: {
          headerRowIndex: getFocusHeaderRowCount(this.beans) - 1,
          column: cellPosition.column
        }
      });
      return;
    }
    if (cellPosition.rowIndex !== cellToFocus.rowIndex || cellPosition.rowPinned != cellToFocus.rowPinned) {
      focusSvc.setFocusedCell({
        ...cellToFocus,
        preventScrollOnBrowserFocus: true,
        forceBrowserFocus: true
      });
      return;
    }
    if (!focusSvc.doesRowOrCellHaveBrowserFocus()) {
      this.updateCellFocus(
        _addGridCommonParams(this.gos, {
          ...cellToFocus,
          forceBrowserFocus: true,
          preventScrollOnBrowserFocus: true,
          type: "cellFocused"
        })
      );
    }
  }
  findPositionToFocus(cellPosition) {
    const { pagination, pageBounds } = this.beans;
    let rowPosition = cellPosition;
    if (rowPosition.rowPinned == null && pagination && pageBounds && !pagination.isRowInPage(rowPosition.rowIndex)) {
      rowPosition = { rowPinned: null, rowIndex: pageBounds.getFirstRow() };
    }
    while (rowPosition) {
      if (rowPosition.rowPinned == null && pageBounds) {
        if (rowPosition.rowIndex < pageBounds.getFirstRow()) {
          rowPosition = _getRowAbove(this.beans, { rowPinned: null, rowIndex: 0 });
          if (!rowPosition) {
            return null;
          }
        } else if (rowPosition.rowIndex > pageBounds.getLastRow()) {
          rowPosition = { rowPinned: null, rowIndex: pageBounds.getLastRow() };
        }
      }
      const row = this.getRowByPosition(rowPosition);
      if (row == null ? void 0 : row.isAlive()) {
        return { ...row.getRowPosition(), column: cellPosition.column };
      }
      rowPosition = _getRowAbove(this.beans, rowPosition);
    }
    return null;
  }
  getAllCellCtrls() {
    const res = [];
    const rowCtrls = this.getAllRowCtrls();
    const rowCtrlsLength = rowCtrls.length;
    for (let i = 0; i < rowCtrlsLength; i++) {
      const cellCtrls = rowCtrls[i].getAllCellCtrls();
      const cellCtrlsLength = cellCtrls.length;
      for (let j = 0; j < cellCtrlsLength; j++) {
        res.push(cellCtrls[j]);
      }
    }
    return res;
  }
  getAllRowCtrls() {
    var _a4, _b2, _c;
    const { spannedRowRenderer } = this.beans;
    const stickyTopRowCtrls = this.getStickyTopRowCtrls();
    const stickyBottomRowCtrls = this.getStickyBottomRowCtrls();
    const res = [
      ...this.topRowCtrls,
      ...this.bottomRowCtrls,
      ...stickyTopRowCtrls,
      ...stickyBottomRowCtrls,
      ...(_a4 = spannedRowRenderer == null ? void 0 : spannedRowRenderer.getCtrls("top")) != null ? _a4 : [],
      ...(_b2 = spannedRowRenderer == null ? void 0 : spannedRowRenderer.getCtrls("bottom")) != null ? _b2 : [],
      ...(_c = spannedRowRenderer == null ? void 0 : spannedRowRenderer.getCtrls("center")) != null ? _c : [],
      ...Object.values(this.rowCtrlsByRowIndex)
    ];
    return res;
  }
  addRenderedRowListener(eventName, rowIndex, callback) {
    const rowComp = this.rowCtrlsByRowIndex[rowIndex];
    if (rowComp) {
      rowComp.addEventListener(eventName, callback);
    }
  }
  refreshCells({ rowNodes, columns, force, suppressFlash } = {}) {
    const refreshCellParams = {
      force,
      newData: false,
      suppressFlash
    };
    for (const cellCtrl of this.getCellCtrls(rowNodes, columns)) {
      cellCtrl.refreshOrDestroyCell(refreshCellParams);
    }
    this.refreshFullWidth(rowNodes);
  }
  refreshRows(params = {}) {
    this.getRowCtrls(params.rowNodes).forEach((rowCtrl) => rowCtrl.refreshRow(params));
    this.refreshFullWidth(params.rowNodes);
  }
  refreshFullWidth(rowNodes) {
    if (!rowNodes) {
      return;
    }
    let rowRedrawn = false;
    for (const rowCtrl of this.getRowCtrls(rowNodes)) {
      if (!rowCtrl.isFullWidth()) {
        continue;
      }
      const refreshed = rowCtrl.refreshFullWidth();
      if (!refreshed) {
        rowRedrawn = true;
        this.redrawRow(rowCtrl.rowNode, true);
      }
    }
    if (rowRedrawn) {
      this.dispatchDisplayedRowsChanged(false);
    }
  }
  /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */
  getRowCtrls(rowNodes) {
    const rowIdsMap = mapRowNodes(rowNodes);
    const allRowCtrls = this.getAllRowCtrls();
    if (!rowNodes || !rowIdsMap) {
      return allRowCtrls;
    }
    return allRowCtrls.filter((rowCtrl) => {
      const rowNode = rowCtrl.rowNode;
      return isRowInMap(rowNode, rowIdsMap);
    });
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(rowNodes, columns) {
    let colIdsMap;
    if (_exists(columns)) {
      colIdsMap = {};
      columns.forEach((colKey) => {
        const column = this.colModel.getCol(colKey);
        if (_exists(column)) {
          colIdsMap[column.getId()] = true;
        }
      });
    }
    const res = [];
    this.getRowCtrls(rowNodes).forEach((rowCtrl) => {
      rowCtrl.getAllCellCtrls().forEach((cellCtrl) => {
        const colId = cellCtrl.column.getId();
        const excludeColFromRefresh = colIdsMap && !colIdsMap[colId];
        if (excludeColFromRefresh) {
          return;
        }
        res.push(cellCtrl);
      });
    });
    return res;
  }
  destroy() {
    this.removeAllRowComps(true);
    super.destroy();
  }
  removeAllRowComps(suppressAnimation = false) {
    var _a4;
    const rowIndexesToRemove = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(rowIndexesToRemove, suppressAnimation);
    (_a4 = this.stickyRowFeature) == null ? void 0 : _a4.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const stubNodeIndexes = [];
    for (const index of Object.keys(this.rowCtrlsByRowIndex)) {
      const rowCtrl = this.rowCtrlsByRowIndex[index];
      const stubNode = rowCtrl.rowNode.id == null;
      if (stubNode) {
        stubNodeIndexes.push(index);
      }
    }
    this.removeRowCtrls(stubNodeIndexes);
    const ctrlsByIdMap = {};
    for (const rowCtrl of Object.values(this.rowCtrlsByRowIndex)) {
      const rowNode = rowCtrl.rowNode;
      ctrlsByIdMap[rowNode.id] = rowCtrl;
    }
    this.rowCtrlsByRowIndex = {};
    return ctrlsByIdMap;
  }
  // takes array of row indexes
  removeRowCtrls(rowsToRemove, suppressAnimation = false) {
    rowsToRemove.forEach((indexToRemove) => {
      const rowCtrl = this.rowCtrlsByRowIndex[indexToRemove];
      if (rowCtrl) {
        rowCtrl.destroyFirstPass(suppressAnimation);
        rowCtrl.destroySecondPass();
      }
      delete this.rowCtrlsByRowIndex[indexToRemove];
    });
  }
  onBodyScroll(e) {
    if (e.direction !== "vertical") {
      return;
    }
    this.redraw({ afterScroll: true });
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(params = {}) {
    const { focusSvc, animationFrameSvc } = this.beans;
    const { afterScroll } = params;
    let cellFocused;
    const stickyRowFeature = this.stickyRowFeature;
    if (stickyRowFeature) {
      cellFocused = (focusSvc == null ? void 0 : focusSvc.getFocusCellToUseAfterRefresh()) || void 0;
    }
    const oldFirstRow = this.firstRenderedRow;
    const oldLastRow = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let hasStickyRowChanges = false;
    if (stickyRowFeature) {
      hasStickyRowChanges = stickyRowFeature.checkStickyRows();
      const extraHeight = stickyRowFeature.extraTopHeight + stickyRowFeature.extraBottomHeight;
      if (extraHeight) {
        this.updateContainerHeights(extraHeight);
      }
    }
    const rangeChanged = this.firstRenderedRow !== oldFirstRow || this.lastRenderedRow !== oldLastRow;
    if (afterScroll && !hasStickyRowChanges && !rangeChanged) {
      return;
    }
    this.getLockOnRefresh();
    this.recycleRows(null, false, afterScroll);
    this.releaseLockOnRefresh();
    this.dispatchDisplayedRowsChanged(afterScroll && !hasStickyRowChanges);
    if (cellFocused != null) {
      const newFocusedCell = focusSvc == null ? void 0 : focusSvc.getFocusCellToUseAfterRefresh();
      if (cellFocused != null && newFocusedCell == null) {
        animationFrameSvc == null ? void 0 : animationFrameSvc.flushAllFrames();
        this.restoreFocusedCell(cellFocused);
      }
    }
  }
  removeRowCompsNotToDraw(indexesToDraw, suppressAnimation) {
    const indexesToDrawMap = {};
    indexesToDraw.forEach((index) => indexesToDrawMap[index] = true);
    const existingIndexes = Object.keys(this.rowCtrlsByRowIndex);
    const indexesNotToDraw = existingIndexes.filter((index) => !indexesToDrawMap[index]);
    this.removeRowCtrls(indexesNotToDraw, suppressAnimation);
  }
  calculateIndexesToDraw(rowsToRecycle) {
    var _a4, _b2;
    const indexesToDraw = [];
    for (let i = this.firstRenderedRow; i <= this.lastRenderedRow; i++) {
      indexesToDraw.push(i);
    }
    const pagination = this.beans.pagination;
    const focusedRowIndex = (_b2 = (_a4 = this.beans.focusSvc) == null ? void 0 : _a4.getFocusedCell()) == null ? void 0 : _b2.rowIndex;
    if (focusedRowIndex != null && (focusedRowIndex < this.firstRenderedRow || focusedRowIndex > this.lastRenderedRow) && (!pagination || pagination.isRowInPage(focusedRowIndex)) && focusedRowIndex < this.rowModel.getRowCount()) {
      indexesToDraw.push(focusedRowIndex);
    }
    const checkRowToDraw = (rowComp) => {
      const index = rowComp.rowNode.rowIndex;
      if (index == null || index === focusedRowIndex) {
        return;
      }
      if (index < this.firstRenderedRow || index > this.lastRenderedRow) {
        if (this.doNotUnVirtualiseRow(rowComp)) {
          indexesToDraw.push(index);
        }
      }
    };
    for (const rowCtrl of Object.values(this.rowCtrlsByRowIndex)) {
      checkRowToDraw(rowCtrl);
    }
    if (rowsToRecycle) {
      for (const rowCtrl of Object.values(rowsToRecycle)) {
        checkRowToDraw(rowCtrl);
      }
    }
    indexesToDraw.sort((a, b) => a - b);
    const ret = [];
    for (let i = 0; i < indexesToDraw.length; i++) {
      const currRow = indexesToDraw[i];
      const rowNode = this.rowModel.getRow(currRow);
      if (rowNode && !rowNode.sticky) {
        ret.push(currRow);
      }
    }
    return ret;
  }
  recycleRows(rowsToRecycle, animate = false, afterScroll = false) {
    const indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);
    if (this.printLayout || afterScroll) {
      animate = false;
    }
    this.removeRowCompsNotToDraw(indexesToDraw, !animate);
    const rowCtrls = [];
    indexesToDraw.forEach((rowIndex) => {
      const rowCtrl = this.createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll);
      if (_exists(rowCtrl)) {
        rowCtrls.push(rowCtrl);
      }
    });
    if (rowsToRecycle) {
      const { animationFrameSvc } = this.beans;
      const useAnimationFrame = (animationFrameSvc == null ? void 0 : animationFrameSvc.active) && afterScroll && !this.printLayout;
      if (useAnimationFrame) {
        animationFrameSvc.addDestroyTask(() => {
          this.destroyRowCtrls(rowsToRecycle, animate);
          this.updateAllRowCtrls();
          this.dispatchDisplayedRowsChanged();
        });
      } else {
        this.destroyRowCtrls(rowsToRecycle, animate);
      }
    }
    this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(afterScroll = false) {
    this.eventSvc.dispatchEvent({
      type: "displayedRowsChanged",
      afterScroll
    });
  }
  onDisplayedColumnsChanged() {
    const { visibleCols } = this.beans;
    const pinningLeft = visibleCols.isPinningLeft();
    const pinningRight = visibleCols.isPinningRight();
    const atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;
    if (atLeastOneChanged) {
      this.pinningLeft = pinningLeft;
      this.pinningRight = pinningRight;
      if (this.embedFullWidthRows) {
        this.redrawFullWidthEmbeddedRows();
      }
    }
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const rowsToRemove = [];
    this.getFullWidthRowCtrls().forEach((fullWidthCtrl) => {
      const rowIndex = fullWidthCtrl.rowNode.rowIndex;
      rowsToRemove.push(rowIndex.toString());
    });
    this.refreshFloatingRowComps();
    this.removeRowCtrls(rowsToRemove);
    this.redraw({ afterScroll: true });
  }
  getFullWidthRowCtrls(rowNodes) {
    const rowNodesMap = mapRowNodes(rowNodes);
    return this.getAllRowCtrls().filter((rowCtrl) => {
      if (!rowCtrl.isFullWidth()) {
        return false;
      }
      const rowNode = rowCtrl.rowNode;
      if (rowNodesMap != null && !isRowInMap(rowNode, rowNodesMap)) {
        return false;
      }
      return true;
    });
  }
  createOrUpdateRowCtrl(rowIndex, rowsToRecycle, animate, afterScroll) {
    let rowNode;
    let rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
    if (!rowCtrl) {
      rowNode = this.rowModel.getRow(rowIndex);
      if (_exists(rowNode) && _exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {
        rowCtrl = rowsToRecycle[rowNode.id];
        rowsToRecycle[rowNode.id] = null;
      }
    }
    const creatingNewRowCtrl = !rowCtrl;
    if (creatingNewRowCtrl) {
      if (!rowNode) {
        rowNode = this.rowModel.getRow(rowIndex);
      }
      if (_exists(rowNode)) {
        rowCtrl = this.createRowCon(rowNode, animate, afterScroll);
      } else {
        return;
      }
    }
    if (rowNode) {
      rowNode.alreadyRendered = true;
    }
    this.rowCtrlsByRowIndex[rowIndex] = rowCtrl;
    return rowCtrl;
  }
  destroyRowCtrls(rowCtrlsMap, animate) {
    const executeInAWhileFuncs = [];
    if (rowCtrlsMap) {
      for (const rowCtrl of Object.values(rowCtrlsMap)) {
        if (!rowCtrl) {
          continue;
        }
        if (this.cachedRowCtrls && rowCtrl.isCacheable()) {
          this.cachedRowCtrls.addRow(rowCtrl);
          continue;
        }
        rowCtrl.destroyFirstPass(!animate);
        if (animate) {
          const instanceId = rowCtrl.instanceId;
          this.zombieRowCtrls[instanceId] = rowCtrl;
          executeInAWhileFuncs.push(() => {
            rowCtrl.destroySecondPass();
            delete this.zombieRowCtrls[instanceId];
          });
        } else {
          rowCtrl.destroySecondPass();
        }
      }
    }
    if (animate) {
      executeInAWhileFuncs.push(() => {
        if (this.isAlive()) {
          this.updateAllRowCtrls();
          this.dispatchDisplayedRowsChanged();
        }
      });
      window.setTimeout(() => executeInAWhileFuncs.forEach((func) => func()), ROW_ANIMATION_TIMEOUT);
    }
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const rowsToBuffer = this.getRowBuffer();
    const defaultRowHeight = _getRowHeightAsNumber(this.beans);
    return rowsToBuffer * defaultRowHeight;
  }
  workOutFirstAndLastRowsToRender() {
    const { rowContainerHeight, pageBounds, rowModel } = this;
    rowContainerHeight.updateOffset();
    let newFirst;
    let newLast;
    if (!rowModel.isRowsToRender()) {
      newFirst = 0;
      newLast = -1;
    } else if (this.printLayout) {
      this.beans.environment.refreshRowHeightVariable();
      newFirst = pageBounds.getFirstRow();
      newLast = pageBounds.getLastRow();
    } else {
      const bufferPixels = this.getRowBufferInPixels();
      const scrollFeature = this.ctrlsSvc.getScrollFeature();
      const suppressRowVirtualisation = this.gos.get("suppressRowVirtualisation");
      let rowHeightsChanged = false;
      let firstPixel;
      let lastPixel;
      do {
        const paginationOffset = pageBounds.getPixelOffset();
        const { pageFirstPixel, pageLastPixel } = pageBounds.getCurrentPagePixelRange();
        const divStretchOffset = rowContainerHeight.divStretchOffset;
        const bodyVRange = scrollFeature.getVScrollPosition();
        const bodyTopPixel = bodyVRange.top;
        const bodyBottomPixel = bodyVRange.bottom;
        if (suppressRowVirtualisation) {
          firstPixel = pageFirstPixel + divStretchOffset;
          lastPixel = pageLastPixel + divStretchOffset;
        } else {
          firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;
          lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;
        }
        this.firstVisibleVPixel = Math.max(bodyTopPixel + paginationOffset, pageFirstPixel) + divStretchOffset;
        this.lastVisibleVPixel = Math.min(bodyBottomPixel + paginationOffset, pageLastPixel) + divStretchOffset;
        rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);
      } while (rowHeightsChanged);
      let firstRowIndex = rowModel.getRowIndexAtPixel(firstPixel);
      let lastRowIndex = rowModel.getRowIndexAtPixel(lastPixel);
      const pageFirstRow = pageBounds.getFirstRow();
      const pageLastRow = pageBounds.getLastRow();
      if (firstRowIndex < pageFirstRow) {
        firstRowIndex = pageFirstRow;
      }
      if (lastRowIndex > pageLastRow) {
        lastRowIndex = pageLastRow;
      }
      newFirst = firstRowIndex;
      newLast = lastRowIndex;
    }
    const rowLayoutNormal = _isDomLayout(this.gos, "normal");
    const suppressRowCountRestriction = this.gos.get("suppressMaxRenderedRowRestriction");
    const rowBufferMaxSize = Math.max(this.getRowBuffer(), 500);
    if (rowLayoutNormal && !suppressRowCountRestriction) {
      if (newLast - newFirst > rowBufferMaxSize) {
        newLast = newFirst + rowBufferMaxSize;
      }
    }
    const firstDiffers = newFirst !== this.firstRenderedRow;
    const lastDiffers = newLast !== this.lastRenderedRow;
    if (firstDiffers || lastDiffers) {
      this.firstRenderedRow = newFirst;
      this.lastRenderedRow = newLast;
      this.eventSvc.dispatchEvent({
        type: "viewportChanged",
        firstRow: newFirst,
        lastRow: newLast
      });
    }
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    if (this.dataFirstRenderedFired) {
      return;
    }
    this.dataFirstRenderedFired = true;
    _requestAnimationFrame(this.beans, () => {
      this.beans.eventSvc.dispatchEvent({
        type: "firstDataRendered",
        firstRow: this.firstRenderedRow,
        lastRow: this.lastRenderedRow
      });
    });
  }
  ensureAllRowsInRangeHaveHeightsCalculated(topPixel, bottomPixel) {
    var _a4, _b2;
    const pinnedRowHeightsChanged = (_a4 = this.pinnedRowModel) == null ? void 0 : _a4.ensureRowHeightsValid();
    const stickyHeightsChanged = (_b2 = this.stickyRowFeature) == null ? void 0 : _b2.ensureRowHeightsValid();
    const { pageBounds, rowModel } = this;
    const rowModelHeightsChanged = rowModel.ensureRowHeightsValid(
      topPixel,
      bottomPixel,
      pageBounds.getFirstRow(),
      pageBounds.getLastRow()
    );
    if (rowModelHeightsChanged || stickyHeightsChanged) {
      this.eventSvc.dispatchEvent({
        type: "recalculateRowBounds"
      });
    }
    if (stickyHeightsChanged || rowModelHeightsChanged || pinnedRowHeightsChanged) {
      this.updateContainerHeights();
      return true;
    }
    return false;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(rowCtrl) {
    var _a4;
    const REMOVE_ROW = false;
    const KEEP_ROW = true;
    const rowNode = rowCtrl.rowNode;
    const rowHasFocus = this.focusSvc.isRowFocused(rowNode.rowIndex, rowNode.rowPinned);
    const rowIsEditing = (_a4 = this.editSvc) == null ? void 0 : _a4.isEditing(rowCtrl);
    const rowIsDetail = rowNode.detail;
    const mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;
    if (!mightWantToKeepRow) {
      return REMOVE_ROW;
    }
    const rowNodePresent = this.isRowPresent(rowNode);
    return rowNodePresent ? KEEP_ROW : REMOVE_ROW;
  }
  isRowPresent(rowNode) {
    var _a4, _b2;
    if (!this.rowModel.isRowPresent(rowNode)) {
      return false;
    }
    return (_b2 = (_a4 = this.beans.pagination) == null ? void 0 : _a4.isRowInPage(rowNode.rowIndex)) != null ? _b2 : true;
  }
  createRowCon(rowNode, animate, afterScroll) {
    var _a4, _b2, _c;
    const rowCtrlFromCache = (_b2 = (_a4 = this.cachedRowCtrls) == null ? void 0 : _a4.getRow(rowNode)) != null ? _b2 : null;
    if (rowCtrlFromCache) {
      return rowCtrlFromCache;
    }
    const useAnimationFrameForCreate = afterScroll && !this.printLayout && !!((_c = this.beans.animationFrameSvc) == null ? void 0 : _c.active);
    const res = new RowCtrl(rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout);
    return res;
  }
  getRenderedNodes() {
    const viewportRows = Object.values(this.rowCtrlsByRowIndex).map((rowCtrl) => rowCtrl.rowNode);
    const stickyTopRows = this.getStickyTopRowCtrls().map((rowCtrl) => rowCtrl.rowNode);
    const stickyBottomRows = this.getStickyBottomRowCtrls().map((rowCtrl) => rowCtrl.rowNode);
    return [...stickyTopRows, ...viewportRows, ...stickyBottomRows];
  }
  getRowByPosition(rowPosition) {
    let rowCtrl;
    const { rowIndex } = rowPosition;
    switch (rowPosition.rowPinned) {
      case "top":
        rowCtrl = this.topRowCtrls[rowIndex];
        break;
      case "bottom":
        rowCtrl = this.bottomRowCtrls[rowIndex];
        break;
      default:
        rowCtrl = this.rowCtrlsByRowIndex[rowIndex];
        if (!rowCtrl) {
          rowCtrl = this.getStickyTopRowCtrls().find((ctrl) => ctrl.rowNode.rowIndex === rowIndex) || null;
          if (!rowCtrl) {
            rowCtrl = this.getStickyBottomRowCtrls().find((ctrl) => ctrl.rowNode.rowIndex === rowIndex) || null;
          }
        }
        break;
    }
    return rowCtrl;
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(startIndex, endIndex) {
    const parentClosed = startIndex == null || endIndex == null;
    if (parentClosed) {
      return false;
    }
    const blockAfterViewport = startIndex > this.lastRenderedRow;
    const blockBeforeViewport = endIndex < this.firstRenderedRow;
    const blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;
    return blockInsideViewport;
  }
};
var RowCtrlCache = class {
  constructor(maxCount) {
    this.entriesMap = {};
    this.entriesList = [];
    this.maxCount = maxCount;
  }
  addRow(rowCtrl) {
    this.entriesMap[rowCtrl.rowNode.id] = rowCtrl;
    this.entriesList.push(rowCtrl);
    rowCtrl.setCached(true);
    if (this.entriesList.length > this.maxCount) {
      const rowCtrlToDestroy = this.entriesList[0];
      rowCtrlToDestroy.destroyFirstPass();
      rowCtrlToDestroy.destroySecondPass();
      this.removeFromCache(rowCtrlToDestroy);
    }
  }
  getRow(rowNode) {
    if (rowNode == null || rowNode.id == null) {
      return null;
    }
    const res = this.entriesMap[rowNode.id];
    if (!res) {
      return null;
    }
    this.removeFromCache(res);
    res.setCached(false);
    const rowNodeMismatch = res.rowNode != rowNode;
    return rowNodeMismatch ? null : res;
  }
  has(rowNode) {
    return this.entriesMap[rowNode.id] != null;
  }
  removeRow(rowNode) {
    const rowNodeId = rowNode.id;
    const ctrl = this.entriesMap[rowNodeId];
    delete this.entriesMap[rowNodeId];
    _removeFromArray(this.entriesList, ctrl);
  }
  removeFromCache(rowCtrl) {
    const rowNodeId = rowCtrl.rowNode.id;
    delete this.entriesMap[rowNodeId];
    _removeFromArray(this.entriesList, rowCtrl);
  }
  getEntries() {
    return this.entriesList;
  }
};
function mapRowNodes(rowNodes) {
  if (!rowNodes) {
    return;
  }
  const res = {
    top: {},
    bottom: {},
    normal: {}
  };
  rowNodes.forEach((rowNode) => {
    const id = rowNode.id;
    switch (rowNode.rowPinned) {
      case "top":
        res.top[id] = rowNode;
        break;
      case "bottom":
        res.bottom[id] = rowNode;
        break;
      default:
        res.normal[id] = rowNode;
        break;
    }
  });
  return res;
}
function isRowInMap(rowNode, rowIdsMap) {
  const id = rowNode.id;
  const floating = rowNode.rowPinned;
  switch (floating) {
    case "top":
      return rowIdsMap.top[id] != null;
    case "bottom":
      return rowIdsMap.bottom[id] != null;
    default:
      return rowIdsMap.normal[id] != null;
  }
}
var RowNodeSorter = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "rowNodeSorter";
  }
  postConstruct() {
    const { gos } = this;
    this.isAccentedSort = gos.get("accentedSort");
    this.primaryColumnsSortGroups = _isColumnsSortingCoupledToGroup(gos);
    this.addManagedPropertyListener(
      "accentedSort",
      (propChange) => this.isAccentedSort = propChange.currentValue
    );
    this.addManagedPropertyListener(
      "autoGroupColumnDef",
      () => this.primaryColumnsSortGroups = _isColumnsSortingCoupledToGroup(gos)
    );
  }
  doFullSort(rowNodes, sortOptions) {
    const sortedRowNodes = rowNodes.map((rowNode, currentPos) => ({
      currentPos,
      rowNode
    }));
    sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));
    return sortedRowNodes.map((item) => item.rowNode);
  }
  compareRowNodes(sortOptions, sortedNodeA, sortedNodeB) {
    const nodeA = sortedNodeA.rowNode;
    const nodeB = sortedNodeB.rowNode;
    for (let i = 0, len = sortOptions.length; i < len; i++) {
      const sortOption = sortOptions[i];
      const isDescending = sortOption.sort === "desc";
      const valueA = this.getValue(nodeA, sortOption.column);
      const valueB = this.getValue(nodeB, sortOption.column);
      let comparatorResult;
      const providedComparator = this.getComparator(sortOption, nodeA);
      if (providedComparator) {
        comparatorResult = providedComparator(valueA, valueB, nodeA, nodeB, isDescending);
      } else {
        comparatorResult = _defaultComparator(valueA, valueB, this.isAccentedSort);
      }
      const validResult = !isNaN(comparatorResult);
      if (validResult && comparatorResult !== 0) {
        return sortOption.sort === "asc" ? comparatorResult : comparatorResult * -1;
      }
    }
    return sortedNodeA.currentPos - sortedNodeB.currentPos;
  }
  getComparator(sortOption, rowNode) {
    const column = sortOption.column;
    const comparatorOnCol = column.getColDef().comparator;
    if (comparatorOnCol != null) {
      return comparatorOnCol;
    }
    if (!column.getColDef().showRowGroup) {
      return;
    }
    const groupLeafField = !rowNode.group && column.getColDef().field;
    if (!groupLeafField) {
      return;
    }
    const primaryColumn = this.beans.colModel.getColDefCol(groupLeafField);
    if (!primaryColumn) {
      return;
    }
    return primaryColumn.getColDef().comparator;
  }
  getValue(node, column) {
    var _a4, _b2;
    const { valueSvc, colModel, showRowGroupCols, gos } = this.beans;
    if (!this.primaryColumnsSortGroups) {
      return valueSvc.getValue(column, node, false);
    }
    const isNodeGroupedAtLevel = node.rowGroupColumn === column;
    if (isNodeGroupedAtLevel) {
      const isGroupRows = _isGroupUseEntireRow(gos, colModel.isPivotActive());
      if (isGroupRows) {
        const leafChild = (_a4 = node.allLeafChildren) == null ? void 0 : _a4[0];
        if (leafChild) {
          return valueSvc.getValue(column, leafChild, false);
        }
        return void 0;
      }
      const displayCol = showRowGroupCols == null ? void 0 : showRowGroupCols.getShowRowGroupCol(column.getId());
      if (!displayCol) {
        return void 0;
      }
      return (_b2 = node.groupData) == null ? void 0 : _b2[displayCol.getId()];
    }
    if (node.group && column.getColDef().showRowGroup) {
      return void 0;
    }
    return valueSvc.getValue(column, node, false);
  }
};
function onSortChanged(beans) {
  var _a4;
  (_a4 = beans.sortSvc) == null ? void 0 : _a4.onSortChanged("api");
}
var SortModule = {
  moduleName: "Sort",
  version: VERSION,
  beans: [SortService, RowNodeSorter],
  apiFunctions: {
    onSortChanged
  },
  userComponents: {
    agSortIndicator: SortIndicatorComp
  },
  icons: {
    // show on column header when column is sorted ascending
    sortAscending: "asc",
    // show on column header when column is sorted descending
    sortDescending: "desc",
    // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
    sortUnSort: "none"
  }
};
var SyncService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "syncSvc";
    this.waitingForColumns = false;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (event) => this.setColumnDefs(event));
  }
  start() {
    this.beans.ctrlsSvc.whenReady(this, () => {
      const columnDefs = this.gos.get("columnDefs");
      if (columnDefs) {
        this.setColumnsAndData(columnDefs);
      } else {
        this.waitingForColumns = true;
      }
      this.gridReady();
    });
  }
  setColumnsAndData(columnDefs) {
    const { colModel, rowModel } = this.beans;
    colModel.setColumnDefs(columnDefs != null ? columnDefs : [], "gridInitializing");
    rowModel.start();
  }
  gridReady() {
    const { eventSvc, gos } = this;
    eventSvc.dispatchEvent({
      type: "gridReady"
    });
    _logIfDebug(gos, `initialised successfully, enterprise = ${gos.isModuleRegistered("EnterpriseCore")}`);
  }
  setColumnDefs(event) {
    const columnDefs = this.gos.get("columnDefs");
    if (!columnDefs) {
      return;
    }
    if (this.waitingForColumns) {
      this.waitingForColumns = false;
      this.setColumnsAndData(columnDefs);
      return;
    }
    this.beans.colModel.setColumnDefs(columnDefs, _convertColumnEventSourceType(event.source));
  }
};
var SOURCE_PASTE = "paste";
var ChangeDetectionService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "changeDetectionSvc";
    this.clientSideRowModel = null;
  }
  postConstruct() {
    const { gos, rowModel } = this.beans;
    if (_isClientSideRowModel(gos, rowModel)) {
      this.clientSideRowModel = rowModel;
    }
    this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
  }
  onCellValueChanged(event) {
    const { gos, rowRenderer } = this.beans;
    if (event.source === SOURCE_PASTE || gos.get("suppressChangeDetection")) {
      return;
    }
    const rowNode = event.node;
    const nodesToRefresh = [rowNode];
    const clientSideRowModel = this.clientSideRowModel;
    const rootNode = clientSideRowModel == null ? void 0 : clientSideRowModel.rootNode;
    if (rootNode && !rowNode.isRowPinned()) {
      const onlyChangedColumns = gos.get("aggregateOnlyChangedColumns");
      const changedPath = new ChangedPath(onlyChangedColumns, rootNode);
      changedPath.addParentNode(rowNode.parent, [event.column]);
      clientSideRowModel.doAggregate(changedPath);
      changedPath.forEachChangedNodeDepthFirst((rowNode2) => {
        nodesToRefresh.push(rowNode2);
        if (rowNode2.sibling) {
          nodesToRefresh.push(rowNode2.sibling);
        }
      });
    }
    rowRenderer.refreshCells({ rowNodes: nodesToRefresh });
  }
};
var ExpressionService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "expressionSvc";
    this.cache = {};
  }
  evaluate(expression, params) {
    if (typeof expression === "string") {
      return this.evaluateExpression(expression, params);
    } else {
      _error(15, { expression });
    }
  }
  evaluateExpression(expression, params) {
    try {
      const javaScriptFunction = this.createExpressionFunction(expression);
      const result = javaScriptFunction(
        params.value,
        params.context,
        params.oldValue,
        params.newValue,
        params.value,
        params.node,
        params.data,
        params.colDef,
        params.rowIndex,
        params.api,
        params.getValue,
        params.column,
        params.columnGroup
      );
      return result;
    } catch (e) {
      _error(16, { expression, params, e });
      return null;
    }
  }
  createExpressionFunction(expression) {
    const expressionToFunctionCache = this.cache;
    if (expressionToFunctionCache[expression]) {
      return expressionToFunctionCache[expression];
    }
    const functionBody = this.createFunctionBody(expression);
    const theFunction = new Function(
      "x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup",
      functionBody
    );
    expressionToFunctionCache[expression] = theFunction;
    return theFunction;
  }
  createFunctionBody(expression) {
    if (expression.indexOf("return") >= 0) {
      return expression;
    } else {
      return "return " + expression + ";";
    }
  }
};
var ExpressionModule = {
  moduleName: "Expression",
  version: VERSION,
  beans: [ExpressionService]
};
var ChangeDetectionModule = {
  moduleName: "ChangeDetection",
  version: VERSION,
  beans: [ChangeDetectionService]
};
var ValueService = class extends BeanStub {
  constructor() {
    super(...arguments);
    this.beanName = "valueSvc";
    this.hasEditSvc = false;
    this.initialised = false;
    this.isSsrm = false;
  }
  wireBeans(beans) {
    this.expressionSvc = beans.expressionSvc;
    this.colModel = beans.colModel;
    this.valueCache = beans.valueCache;
    this.dataTypeSvc = beans.dataTypeSvc;
    this.editSvc = beans.editSvc;
    this.hasEditSvc = !!beans.editSvc;
  }
  postConstruct() {
    if (!this.initialised) {
      this.init();
    }
  }
  init() {
    this.executeValueGetter = this.valueCache ? this.executeValueGetterWithValueCache.bind(this) : this.executeValueGetterWithoutValueCache.bind(this);
    this.isSsrm = _isServerSideRowModel(this.gos);
    this.cellExpressions = this.gos.get("enableCellExpressions");
    this.isTreeData = this.gos.get("treeData");
    this.initialised = true;
    const listener = (event) => this.callColumnCellValueChangedHandler(event);
    this.eventSvc.addListener("cellValueChanged", listener, true);
    this.addDestroyFunc(() => this.eventSvc.removeListener("cellValueChanged", listener, true));
    this.addManagedPropertyListener("treeData", (propChange) => this.isTreeData = propChange.currentValue);
  }
  /**
   * Use this function to get a displayable cell value.
   * The values from this function are not used for sorting, filtering, or aggregation purposes.
   * Handles: groupHideOpenParents, showOpenedGroup and groupSuppressBlankHeader behaviours
   */
  getValueForDisplay(column, node, includeValueFormatted = false, exporting = false, source = "ui") {
    const { showRowGroupColValueSvc } = this.beans;
    const isFullWidthGroup = !column && node.group;
    const isGroupCol = column == null ? void 0 : column.colDef.showRowGroup;
    const processTreeDataAsGroup = !this.isTreeData || node.footer;
    if (showRowGroupColValueSvc && processTreeDataAsGroup && (isFullWidthGroup || isGroupCol)) {
      const groupValue = showRowGroupColValueSvc.getGroupValue(node, column);
      if (groupValue == null) {
        return {
          value: null,
          valueFormatted: null
        };
      }
      if (!includeValueFormatted) {
        return {
          value: groupValue.value,
          valueFormatted: null
        };
      }
      const valueFormatted = showRowGroupColValueSvc.formatAndPrefixGroupColValue(groupValue, column, exporting);
      return {
        value: groupValue.value,
        valueFormatted
      };
    }
    if (!column) {
      return {
        value: node.key,
        valueFormatted: null
      };
    }
    const isPivotLeaf = node.leafGroup && this.colModel.isPivotMode();
    const isOpenedGroup = node.group && node.expanded && !node.footer && !isPivotLeaf;
    const groupShowsAggData = this.gos.get("groupSuppressBlankHeader") || !node.sibling;
    const ignoreAggData = isOpenedGroup && !groupShowsAggData;
    const value = this.getValue(column, node, ignoreAggData, source);
    const format = includeValueFormatted && !(exporting && column.colDef.useValueFormatterForExport === false);
    return {
      value,
      valueFormatted: format ? this.formatValue(column, node, value) : null
    };
  }
  getValue(column, rowNode, ignoreAggData = false, source = "ui") {
    var _a4, _b2;
    if (!this.initialised) {
      this.init();
    }
    if (!rowNode) {
      return;
    }
    const colDef = column.getColDef();
    const field = colDef.field;
    const colId = column.getColId();
    const data = rowNode.data;
    if (this.hasEditSvc && source === "ui") {
      const editSvc = this.editSvc;
      if (editSvc.isEditing()) {
        const newValue = editSvc.getCellDataValue({ rowNode, column }, true);
        if (newValue !== void 0) {
          return newValue;
        }
      }
    }
    let result;
    const rowGroupColId = colDef.showRowGroup;
    if (typeof rowGroupColId === "string") {
      const colRowGroupIndex = (_b2 = (_a4 = this.beans.rowGroupColsSvc) == null ? void 0 : _a4.getColumnIndex(rowGroupColId)) != null ? _b2 : -1;
      if (colRowGroupIndex > rowNode.level) {
        return null;
      }
    }
    const allowUserValuesForCell = typeof rowGroupColId !== "string" || !rowNode.group;
    const groupDataExists = rowNode.groupData && colId in rowNode.groupData;
    const aggDataExists = !ignoreAggData && rowNode.aggData && rowNode.aggData[colId] !== void 0;
    const ignoreSsrmAggData = this.isSsrm && ignoreAggData && !!colDef.aggFunc;
    const ssrmFooterGroupCol = this.isSsrm && rowNode.footer && rowNode.field && (colDef.showRowGroup === true || colDef.showRowGroup === rowNode.field);
    if (this.isTreeData && aggDataExists) {
      result = rowNode.aggData[colId];
    } else if (this.isTreeData && colDef.valueGetter) {
      result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
    } else if (this.isTreeData && field && data) {
      result = _getValueUsingField(data, field, column.isFieldContainsDots());
    } else if (groupDataExists) {
      result = rowNode.groupData[colId];
    } else if (aggDataExists) {
      result = rowNode.aggData[colId];
    } else if (colDef.valueGetter && !ignoreSsrmAggData) {
      if (!allowUserValuesForCell) {
        return result;
      }
      result = this.executeValueGetter(colDef.valueGetter, data, column, rowNode);
    } else if (ssrmFooterGroupCol) {
      result = _getValueUsingField(data, rowNode.field, column.isFieldContainsDots());
    } else if (field && data && !ignoreSsrmAggData) {
      if (!allowUserValuesForCell) {
        return result;
      }
      result = _getValueUsingField(data, field, column.isFieldContainsDots());
    }
    if (this.cellExpressions && typeof result === "string" && result.indexOf("=") === 0) {
      const cellValueGetter = result.substring(1);
      result = this.executeValueGetter(cellValueGetter, data, column, rowNode);
    }
    return result;
  }
  parseValue(column, rowNode, newValue, oldValue) {
    var _a4;
    const colDef = column.getColDef();
    const valueParser = colDef.valueParser;
    if (_exists(valueParser)) {
      const params = _addGridCommonParams(this.gos, {
        node: rowNode,
        data: rowNode == null ? void 0 : rowNode.data,
        oldValue,
        newValue,
        colDef,
        column
      });
      if (typeof valueParser === "function") {
        return valueParser(params);
      }
      return (_a4 = this.expressionSvc) == null ? void 0 : _a4.evaluate(valueParser, params);
    }
    return newValue;
  }
  getDeleteValue(column, rowNode) {
    var _a4;
    if (_exists(column.getColDef().valueParser)) {
      return (_a4 = this.parseValue(column, rowNode, "", this.getValueForDisplay(column, rowNode).value)) != null ? _a4 : null;
    }
    return null;
  }
  formatValue(column, node, value, suppliedFormatter, useFormatterFromColumn = true) {
    const { expressionSvc } = this.beans;
    let result = null;
    let formatter;
    const colDef = column.getColDef();
    if (suppliedFormatter) {
      formatter = suppliedFormatter;
    } else if (useFormatterFromColumn) {
      formatter = colDef.valueFormatter;
    }
    if (formatter) {
      const data = node ? node.data : null;
      const params = _addGridCommonParams(this.gos, {
        value,
        node,
        data,
        colDef,
        column
      });
      if (typeof formatter === "function") {
        result = formatter(params);
      } else {
        result = expressionSvc ? expressionSvc.evaluate(formatter, params) : null;
      }
    } else if (colDef.refData) {
      return colDef.refData[value] || "";
    }
    if (result == null && Array.isArray(value)) {
      result = value.join(", ");
    }
    return result;
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(rowNode, colKey, newValue, eventSource) {
    var _a4, _b2;
    const column = this.colModel.getColDefCol(colKey);
    if (!rowNode || !column) {
      return false;
    }
    if (_missing(rowNode.data)) {
      rowNode.data = {};
    }
    const { field, valueSetter } = column.getColDef();
    if (_missing(field) && _missing(valueSetter)) {
      _warn(17);
      return false;
    }
    if (this.dataTypeSvc && !this.dataTypeSvc.checkType(column, newValue)) {
      _warn(135);
      return false;
    }
    const params = _addGridCommonParams(this.gos, {
      node: rowNode,
      data: rowNode.data,
      oldValue: this.getValue(column, rowNode, void 0, eventSource),
      newValue,
      colDef: column.getColDef(),
      column
    });
    params.newValue = newValue;
    let valueWasDifferent;
    if (_exists(valueSetter)) {
      if (typeof valueSetter === "function") {
        valueWasDifferent = valueSetter(params);
      } else {
        valueWasDifferent = (_a4 = this.expressionSvc) == null ? void 0 : _a4.evaluate(valueSetter, params);
      }
    } else {
      valueWasDifferent = this.setValueUsingField(rowNode.data, field, newValue, column.isFieldContainsDots());
    }
    if (valueWasDifferent === void 0) {
      valueWasDifferent = true;
    }
    if (!valueWasDifferent) {
      return false;
    }
    rowNode.resetQuickFilterAggregateText();
    (_b2 = this.valueCache) == null ? void 0 : _b2.onDataChanged();
    const savedValue = this.getValue(column, rowNode);
    this.dispatchCellValueChangedEvent(rowNode, params, savedValue, eventSource);
    if (rowNode.pinnedSibling) {
      this.dispatchCellValueChangedEvent(rowNode.pinnedSibling, params, savedValue, eventSource);
    }
    return true;
  }
  dispatchCellValueChangedEvent(rowNode, params, value, source) {
    this.eventSvc.dispatchEvent({
      type: "cellValueChanged",
      event: null,
      rowIndex: rowNode.rowIndex,
      rowPinned: rowNode.rowPinned,
      column: params.column,
      colDef: params.colDef,
      data: rowNode.data,
      node: rowNode,
      oldValue: params.oldValue,
      newValue: value,
      value,
      source
    });
  }
  callColumnCellValueChangedHandler(event) {
    const onCellValueChanged = event.colDef.onCellValueChanged;
    if (typeof onCellValueChanged === "function") {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        onCellValueChanged({
          node: event.node,
          data: event.data,
          oldValue: event.oldValue,
          newValue: event.newValue,
          colDef: event.colDef,
          column: event.column,
          api: event.api,
          context: event.context
        });
      });
    }
  }
  setValueUsingField(data, field, newValue, isFieldContainsDots) {
    if (!field) {
      return false;
    }
    let valuesAreSame = false;
    if (!isFieldContainsDots) {
      valuesAreSame = data[field] === newValue;
      if (!valuesAreSame) {
        data[field] = newValue;
      }
    } else {
      const fieldPieces = field.split(".");
      let currentObject = data;
      while (fieldPieces.length > 0 && currentObject) {
        const fieldPiece = fieldPieces.shift();
        if (fieldPieces.length === 0) {
          valuesAreSame = currentObject[fieldPiece] === newValue;
          if (!valuesAreSame) {
            currentObject[fieldPiece] = newValue;
          }
        } else {
          currentObject = currentObject[fieldPiece];
        }
      }
    }
    return !valuesAreSame;
  }
  executeValueGetterWithValueCache(valueGetter, data, column, rowNode) {
    const colId = column.getColId();
    const valueFromCache = this.valueCache.getValue(rowNode, colId);
    if (valueFromCache !== void 0) {
      return valueFromCache;
    }
    const result = this.executeValueGetterWithoutValueCache(valueGetter, data, column, rowNode);
    this.valueCache.setValue(rowNode, colId, result);
    return result;
  }
  executeValueGetterWithoutValueCache(valueGetter, data, column, rowNode) {
    var _a4;
    const params = _addGridCommonParams(this.gos, {
      data,
      node: rowNode,
      column,
      colDef: column.getColDef(),
      getValue: this.getValueCallback.bind(this, rowNode)
    });
    let result;
    if (typeof valueGetter === "function") {
      result = valueGetter(params);
    } else {
      result = (_a4 = this.expressionSvc) == null ? void 0 : _a4.evaluate(valueGetter, params);
    }
    return result;
  }
  getValueCallback(node, field) {
    const otherColumn = this.colModel.getColDefCol(field);
    if (otherColumn) {
      return this.getValue(otherColumn, node);
    }
    return null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(col, rowNode) {
    const value = this.getValue(col, rowNode);
    const keyCreator = col.getColDef().keyCreator;
    let result = value;
    if (keyCreator) {
      const keyParams = _addGridCommonParams(this.gos, {
        value,
        colDef: col.getColDef(),
        column: col,
        node: rowNode,
        data: rowNode.data
      });
      result = keyCreator(keyParams);
    }
    if (typeof result === "string" || result == null) {
      return result;
    }
    result = String(result);
    if (result === "[object Object]") {
      _warn(121);
    }
    return result;
  }
};
var CommunityCoreModule = {
  moduleName: "CommunityCore",
  version: VERSION,
  beans: [
    GridDestroyService,
    ApiFunctionService,
    Registry,
    UserComponentFactory,
    RowContainerHeightService,
    VisibleColsService,
    EventService,
    GridOptionsService,
    ColumnModel,
    PageBoundsService,
    PageBoundsListener,
    RowRenderer,
    ValueService,
    FocusService,
    Environment,
    ScrollVisibleService,
    CtrlsService,
    SyncService,
    ColumnNameService,
    ColumnViewportService,
    IconService
  ],
  icons: {
    // icon on select dropdowns (select cell editor, charts tool panels)
    selectOpen: "small-down",
    /** @deprecated v33 */
    smallDown: "small-down",
    /** @deprecated v33 */
    colorPicker: "color-picker",
    /** @deprecated v33 */
    smallUp: "small-up",
    /** @deprecated v33 */
    checkboxChecked: "small-up",
    /** @deprecated v33 */
    checkboxIndeterminate: "checkbox-indeterminate",
    /** @deprecated v33 */
    checkboxUnchecked: "checkbox-unchecked",
    /** @deprecated v33 */
    radioButtonOn: "radio-button-on",
    /** @deprecated v33 */
    radioButtonOff: "radio-button-off",
    /** @deprecated v33 */
    smallLeft: "small-left",
    /** @deprecated v33 */
    smallRight: "small-right"
  },
  apiFunctions: {
    getGridId,
    destroy,
    isDestroyed,
    getGridOption,
    setGridOption,
    updateGridOptions,
    isModuleRegistered
  },
  dependsOn: [
    DataTypeModule,
    ColumnMoveModule,
    ColumnResizeModule,
    SortModule,
    ColumnHeaderCompModule,
    ColumnGroupModule,
    ColumnGroupHeaderCompModule,
    OverlayModule,
    ChangeDetectionModule,
    AnimationFrameModule,
    KeyboardNavigationModule,
    PinnedColumnModule,
    AriaModule,
    TouchModule,
    CellRendererFunctionModule,
    ColumnFlexModule,
    ExpressionModule,
    SkeletonCellRendererModule,
    ColumnDelayRenderModule
  ]
};
var ALL_COLUMN_FILTERS = [
  "TextFilter",
  "NumberFilter",
  "DateFilter",
  "SetFilter",
  "MultiFilter",
  "GroupFilter",
  "CustomFilter"
];
var RESOLVABLE_MODULE_NAMES = {
  EditCore: [
    "TextEditor",
    "NumberEditor",
    "DateEditor",
    "CheckboxEditor",
    "LargeTextEditor",
    "SelectEditor",
    "RichSelect",
    "CustomEditor"
  ],
  CheckboxCellRenderer: ["AllCommunity"],
  ClientSideRowModelHierarchy: ["RowGrouping", "Pivot", "TreeData"],
  ColumnFilter: ALL_COLUMN_FILTERS,
  ColumnGroupHeaderComp: ["AllCommunity"],
  ColumnGroup: ["AllCommunity"],
  ColumnHeaderComp: ["AllCommunity"],
  ColumnMove: ["AllCommunity"],
  ColumnResize: ["AllCommunity"],
  CommunityCore: ["AllCommunity"],
  CsrmSsrmSharedApi: ["ClientSideRowModelApi", "ServerSideRowModelApi"],
  RowModelSharedApi: ["ClientSideRowModelApi", "ServerSideRowModelApi"],
  EnterpriseCore: ["AllEnterprise"],
  FilterCore: [...ALL_COLUMN_FILTERS, "QuickFilter", "ExternalFilter", "AdvancedFilter"],
  GroupCellRenderer: ["RowGrouping", "Pivot", "TreeData", "MasterDetail", "ServerSideRowModel"],
  KeyboardNavigation: ["AllCommunity"],
  LoadingCellRenderer: ["ServerSideRowModel"],
  MenuCore: ["ColumnMenu", "ContextMenu"],
  MenuItem: ["ColumnMenu", "ContextMenu", "MultiFilter", "IntegratedCharts", "ColumnsToolPanel"],
  Overlay: ["AllCommunity"],
  PinnedColumn: ["AllCommunity"],
  SharedAggregation: ["RowGrouping", "Pivot", "TreeData", "ServerSideRowModel"],
  SharedDragAndDrop: ["AllCommunity"],
  SharedMasterDetail: ["MasterDetail", "ServerSideRowModel"],
  SharedMenu: [...ALL_COLUMN_FILTERS, "ColumnMenu", "ContextMenu"],
  SharedPivot: ["Pivot", "ServerSideRowModel"],
  SharedRowGrouping: ["RowGrouping", "ServerSideRowModel"],
  SharedRowSelection: ["RowSelection", "ServerSideRowModel"],
  SkeletonCellRenderer: ["ServerSideRowModel"],
  Sort: ["AllCommunity"],
  SsrmInfiniteSharedApi: ["InfiniteRowModel", "ServerSideRowModelApi"],
  SharedTreeData: ["TreeData", "ServerSideRowModel"]
};
var NoModulesRegisteredError = () => `No AG Grid modules are registered! It is recommended to start with all Community features via the AllCommunityModule:
                    
    import { ModuleRegistry, AllCommunityModule } from 'ag-grid-community';
    
    ModuleRegistry.registerModules([ AllCommunityModule ]);
    `;
function missingRowModelTypeError({
  moduleName,
  rowModelType
}) {
  return `To use the ${moduleName}Module you must set the gridOption "rowModelType='${rowModelType}'"`;
}
var _gridApiCache = /* @__PURE__ */ new WeakMap();
var _gridElementCache = /* @__PURE__ */ new WeakMap();
function createGrid(eGridDiv, gridOptions, params) {
  if (!gridOptions) {
    _error(11);
    return {};
  }
  const gridParams = params;
  let destroyCallback;
  if (!(gridParams == null ? void 0 : gridParams.setThemeOnGridDiv)) {
    const newGridDiv = _createElement({ tag: "div" });
    newGridDiv.style.height = "100%";
    eGridDiv.appendChild(newGridDiv);
    eGridDiv = newGridDiv;
    destroyCallback = () => eGridDiv.remove();
  }
  const api = new GridCoreCreator().create(
    eGridDiv,
    gridOptions,
    (context) => {
      const gridComp = new GridComp(eGridDiv);
      context.createBean(gridComp);
    },
    void 0,
    params,
    destroyCallback
  );
  return api;
}
var nextGridId = 1;
var GridCoreCreator = class {
  create(eGridDiv, providedOptions, createUi, acceptChanges, params, _destroyCallback) {
    var _a4;
    const gridOptions = GlobalGridOptions.applyGlobalGridOptions(providedOptions);
    const gridId = (_a4 = gridOptions.gridId) != null ? _a4 : String(nextGridId++);
    const registeredModules = this.getRegisteredModules(params, gridId, gridOptions.rowModelType);
    const beanClasses = this.createBeansList(gridOptions.rowModelType, registeredModules, gridId);
    const providedBeanInstances = this.createProvidedBeans(eGridDiv, gridOptions, params);
    if (!beanClasses) {
      return void 0;
    }
    const destroyCallback = () => {
      _gridElementCache.delete(api);
      _gridApiCache.delete(eGridDiv);
      _unRegisterGridModules(gridId);
      _destroyCallback == null ? void 0 : _destroyCallback();
    };
    const contextParams = {
      providedBeanInstances,
      beanClasses,
      id: gridId,
      beanInitComparator: gridBeanInitComparator,
      beanDestroyComparator: gridBeanDestroyComparator,
      derivedBeans: [createGridApi],
      destroyCallback
    };
    const context = new AgContext(contextParams);
    this.registerModuleFeatures(context, registeredModules);
    createUi(context);
    context.getBean("syncSvc").start();
    acceptChanges == null ? void 0 : acceptChanges(context);
    const api = context.getBean("gridApi");
    _gridApiCache.set(eGridDiv, api);
    _gridElementCache.set(api, eGridDiv);
    return api;
  }
  getRegisteredModules(params, gridId, rowModelType) {
    var _a4;
    _registerModule(CommunityCoreModule, void 0, true);
    (_a4 = params == null ? void 0 : params.modules) == null ? void 0 : _a4.forEach((m) => _registerModule(m, gridId));
    return _getRegisteredModules(gridId, getDefaultRowModelType(rowModelType));
  }
  registerModuleFeatures(context, registeredModules) {
    const registry = context.getBean("registry");
    const apiFunctionSvc = context.getBean("apiFunctionSvc");
    registeredModules.forEach((module2) => {
      registry.registerModule(module2);
      const apiFunctions = module2.apiFunctions;
      if (apiFunctions) {
        const names = Object.keys(apiFunctions);
        names.forEach((name) => {
          apiFunctionSvc == null ? void 0 : apiFunctionSvc.addFunction(name, apiFunctions[name]);
        });
      }
    });
  }
  createProvidedBeans(eGridDiv, gridOptions, params) {
    let frameworkOverrides = params ? params.frameworkOverrides : null;
    if (_missing(frameworkOverrides)) {
      frameworkOverrides = new VanillaFrameworkOverrides();
    }
    const seed = {
      gridOptions,
      eGridDiv,
      eRootDiv: eGridDiv,
      globalListener: params ? params.globalListener : null,
      globalSyncListener: params ? params.globalSyncListener : null,
      frameworkOverrides
    };
    if (params && params.providedBeanInstances) {
      Object.assign(seed, params.providedBeanInstances);
    }
    return seed;
  }
  createBeansList(userProvidedRowModelType, registeredModules, gridId) {
    const rowModelModuleNames = {
      clientSide: "ClientSideRowModel",
      infinite: "InfiniteRowModel",
      serverSide: "ServerSideRowModel",
      viewport: "ViewportRowModel"
    };
    const rowModelType = getDefaultRowModelType(userProvidedRowModelType);
    const rowModuleModelName = rowModelModuleNames[rowModelType];
    if (!rowModuleModelName) {
      _logPreInitErr(201, { rowModelType }, `Unknown rowModelType ${rowModelType}.`);
      return;
    }
    if (!_hasUserRegistered()) {
      _logPreInitErr(272, void 0, NoModulesRegisteredError());
      return;
    }
    if (!userProvidedRowModelType) {
      const registeredRowModelModules = Object.entries(rowModelModuleNames).filter(
        ([rowModelType2, module2]) => _isModuleRegistered(module2, gridId, rowModelType2)
      );
      if (registeredRowModelModules.length == 1) {
        const [userRowModelType, moduleName] = registeredRowModelModules[0];
        if (userRowModelType !== rowModelType) {
          const params = {
            moduleName,
            rowModelType: userRowModelType
          };
          _logPreInitErr(275, params, missingRowModelTypeError(params));
          return;
        }
      }
    }
    if (!_isModuleRegistered(rowModuleModelName, gridId, rowModelType)) {
      _logPreInitErr(
        200,
        {
          reasonOrId: `rowModelType = '${rowModelType}'`,
          moduleName: rowModuleModelName,
          gridScoped: _areModulesGridScoped(),
          gridId,
          rowModelType
        },
        `Missing module ${rowModuleModelName}Module for rowModelType ${rowModelType}.`
      );
      return;
    }
    const beans = /* @__PURE__ */ new Set();
    registeredModules.forEach((module2) => {
      var _a4;
      return (_a4 = module2.beans) == null ? void 0 : _a4.forEach((bean) => beans.add(bean));
    });
    return Array.from(beans);
  }
};
function getDefaultRowModelType(passedRowModelType) {
  return passedRowModelType != null ? passedRowModelType : "clientSide";
}
var STOP_EDIT_SOURCE_TRANSFORM = {
  paste: "api",
  rangeSvc: "api",
  fillHandle: "api",
  cellClear: "api",
  bulk: "api"
};
var STOP_EDIT_SOURCE_TRANSFORM_KEYS = new Set(Object.keys(STOP_EDIT_SOURCE_TRANSFORM));

// src/grid/AgGridAdapter.ts
var AgGridAdapter = class {
  constructor() {
    this.gridApi = null;
  }
  /**
   * 
   */
  mount(container, columns, rows) {
    const colDefs = columns.map((col) => ({
      field: col.field,
      headerName: col.headerName,
      editable: col.editable,
      flex: 1,
      // 
      sortable: true,
      // 
      filter: true,
      // 
      resizable: true
      // 
    }));
    const gridOptions = {
      columnDefs: colDefs,
      rowData: rows,
      // 
      editType: "fullRow",
      // 
      singleClickEdit: true,
      // 
      stopEditingWhenCellsLoseFocus: true,
      // 
      // 
      onCellEditingStopped: (event) => {
        this.handleCellEdit(event);
      },
      // 
      defaultColDef: {
        editable: true,
        sortable: true,
        filter: true,
        resizable: true
      },
      // 
      enableRangeSelection: true,
      // 
      enableCellTextSelection: true
    };
    this.gridApi = createGrid(container, gridOptions);
  }
  /**
   * 
   */
  handleCellEdit(event) {
    if (!this.cellEditCallback)
      return;
    const field = event.colDef.field;
    const rowIndex = event.node.rowIndex;
    const newValue = event.newValue;
    const oldValue = event.oldValue;
    if (newValue !== oldValue && field && rowIndex !== null && rowIndex !== void 0) {
      this.cellEditCallback({
        rowIndex,
        field,
        newValue: String(newValue || ""),
        oldValue: String(oldValue || "")
      });
    }
  }
  /**
   * 
   */
  updateData(rows) {
    if (this.gridApi) {
      this.gridApi.setGridOption("rowData", rows);
    }
  }
  /**
   * 
   */
  onCellEdit(callback) {
    this.cellEditCallback = callback;
  }
  /**
   * 
   *
   * AG Grid 
   * 
   *  Header Component 
   */
  onHeaderEdit(callback) {
    this.headerEditCallback = callback;
    console.warn("AgGridAdapter: \u8868\u5934\u7F16\u8F91\u529F\u80FD\u6682\u672A\u5B9E\u73B0");
  }
  /**
   * 
   */
  destroy() {
    if (this.gridApi) {
      this.gridApi.destroy();
      this.gridApi = null;
    }
  }
};

// src/TableView.ts
var TABLE_VIEW_TYPE = "tile-line-base-table";
var TableView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
    this.file = null;
    this.blocks = [];
    this.schema = null;
    this.saveTimeout = null;
    this.gridAdapter = null;
  }
  getViewType() {
    return TABLE_VIEW_TYPE;
  }
  getDisplayText() {
    var _a4;
    return ((_a4 = this.file) == null ? void 0 : _a4.basename) || "TileLineBase \u8868\u683C";
  }
  async setState(state, result) {
    const file = this.app.vault.getAbstractFileByPath(state.filePath);
    if (file instanceof import_obsidian.TFile) {
      this.file = file;
      await this.render();
    }
  }
  getState() {
    var _a4;
    return {
      filePath: ((_a4 = this.file) == null ? void 0 : _a4.path) || ""
    };
  }
  /**
   *  H2 
   */
  parseH2Blocks(content) {
    const lines = content.split("\n");
    const blocks = [];
    let currentBlock = null;
    for (const line of lines) {
      if (line.startsWith("## ")) {
        if (currentBlock) {
          blocks.push(currentBlock);
        }
        currentBlock = {
          title: line.substring(3).trim(),
          //  "## "
          paragraphs: []
        };
      } else if (currentBlock) {
        const trimmed = line.trim();
        if (trimmed.length > 0) {
          currentBlock.paragraphs.push(line);
        }
      }
    }
    if (currentBlock) {
      blocks.push(currentBlock);
    }
    return blocks;
  }
  /**
   *  H2  Schema
   */
  extractSchema(blocks) {
    if (blocks.length === 0) {
      return null;
    }
    const firstBlock = blocks[0];
    const columnNames = [
      firstBlock.title,
      //  = H2 
      ...firstBlock.paragraphs
      //  = 
    ];
    return { columnNames };
  }
  /**
   *  H2  RowData 
   */
  extractTableData(blocks, schema) {
    const data = [];
    for (let i = 1; i < blocks.length; i++) {
      const block = blocks[i];
      const row = {};
      row[schema.columnNames[0]] = block.title;
      for (let j = 1; j < schema.columnNames.length; j++) {
        const paragraph = block.paragraphs[j - 1];
        if (!paragraph || paragraph.trim() === ".") {
          row[schema.columnNames[j]] = "";
        } else {
          row[schema.columnNames[j]] = paragraph.trim();
        }
      }
      data.push(row);
    }
    return data;
  }
  /**
   *  blocks  Markdown 
   */
  blocksToMarkdown() {
    const lines = [];
    for (const block of this.blocks) {
      lines.push(`## ${block.title}`);
      for (const paragraph of block.paragraphs) {
        if (paragraph.trim()) {
          lines.push(paragraph);
        }
      }
      lines.push("");
    }
    return lines.join("\n");
  }
  /**
   * 500ms 
   */
  scheduleSave() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    this.saveTimeout = setTimeout(() => {
      this.saveToFile();
    }, 500);
  }
  /**
   * 
   */
  async saveToFile() {
    if (!this.file)
      return;
    try {
      const markdown = this.blocksToMarkdown();
      await this.app.vault.modify(this.file, markdown);
      console.log("\u2705 \u6587\u4EF6\u5DF2\u4FDD\u5B58:", this.file.path);
    } catch (error) {
      console.error("\u274C \u4FDD\u5B58\u5931\u8D25:", error);
    }
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.addClass("tile-line-base-view");
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    if (!this.file) {
      container.createDiv({ text: "\u672A\u9009\u62E9\u6587\u4EF6" });
      return;
    }
    const content = await this.app.vault.read(this.file);
    this.blocks = this.parseH2Blocks(content);
    if (this.blocks.length === 0) {
      container.createDiv({
        text: "\u6B64\u6587\u4EF6\u4E0D\u5305\u542B H2 \u5757\uFF0C\u65E0\u6CD5\u663E\u793A\u4E3A\u8868\u683C",
        cls: "tlb-warning"
      });
      return;
    }
    this.schema = this.extractSchema(this.blocks);
    if (!this.schema) {
      container.createDiv({ text: "\u65E0\u6CD5\u63D0\u53D6\u8868\u683C\u7ED3\u6784" });
      return;
    }
    const data = this.extractTableData(this.blocks, this.schema);
    const columns = this.schema.columnNames.map((name) => ({
      field: name,
      headerName: name,
      editable: true
    }));
    const tableContainer = container.createDiv({ cls: "tlb-table-container ag-theme-alpine" });
    if (this.gridAdapter) {
      this.gridAdapter.destroy();
    }
    this.gridAdapter = new AgGridAdapter();
    this.gridAdapter.mount(tableContainer, columns, data);
    this.gridAdapter.onCellEdit((event) => {
      this.onCellEdit(event.rowIndex, event.field, event.newValue);
    });
    this.gridAdapter.onHeaderEdit((event) => {
      console.log("\u8868\u5934\u7F16\u8F91:", event);
    });
    console.log(`TileLineBase \u8868\u683C\u5DF2\u6E32\u67D3\uFF08AG Grid\uFF09\uFF1A${this.file.path}`);
    console.log(`Schema:`, this.schema);
    console.log(`\u6570\u636E\u884C\u6570: ${data.length}`);
  }
  /**
   * 
   */
  onCellEdit(rowIndex, field, newValue) {
    if (!this.schema) {
      console.error("Schema not initialized");
      return;
    }
    const blockIndex = rowIndex + 1;
    if (blockIndex >= this.blocks.length) {
      console.error("Invalid block index:", blockIndex);
      return;
    }
    const colIndex = this.schema.columnNames.indexOf(field);
    if (colIndex === -1) {
      console.error("Invalid field:", field);
      return;
    }
    const block = this.blocks[blockIndex];
    if (colIndex === 0) {
      block.title = newValue;
      console.log(`\u66F4\u65B0 H2 \u6807\u9898 [${blockIndex}]:`, newValue);
    } else {
      const paragraphIndex = colIndex - 1;
      while (block.paragraphs.length <= paragraphIndex) {
        block.paragraphs.push("");
      }
      block.paragraphs[paragraphIndex] = newValue;
      console.log(`\u66F4\u65B0\u6BB5\u843D [${blockIndex}][${paragraphIndex}]:`, newValue);
    }
    console.log("Updated blocks:", this.blocks);
    this.scheduleSave();
  }
  /**
   * 
   */
  onHeaderEdit(colIndex, newValue) {
    if (!this.schema || this.blocks.length === 0) {
      console.error("Invalid schema or blocks");
      return;
    }
    this.schema.columnNames[colIndex] = newValue;
    const templateBlock = this.blocks[0];
    if (colIndex === 0) {
      templateBlock.title = newValue;
      console.log(`\u66F4\u65B0\u8868\u5934\uFF08\u6A21\u677F H2 \u6807\u9898\uFF09[${colIndex}]:`, newValue);
    } else {
      const paragraphIndex = colIndex - 1;
      while (templateBlock.paragraphs.length <= paragraphIndex) {
        templateBlock.paragraphs.push("");
      }
      templateBlock.paragraphs[paragraphIndex] = newValue;
      console.log(`\u66F4\u65B0\u8868\u5934\uFF08\u6A21\u677F\u6BB5\u843D\uFF09[${paragraphIndex}]:`, newValue);
    }
    this.scheduleSave();
  }
  async onClose() {
    if (this.gridAdapter) {
      this.gridAdapter.destroy();
      this.gridAdapter = null;
    }
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
      this.saveTimeout = null;
    }
  }
};

// src/main.ts
var TileLineBasePlugin = class extends import_obsidian2.Plugin {
  async onload() {
    console.log("\u52A0\u8F7D TileLineBase \u63D2\u4EF6");
    this.registerView(
      TABLE_VIEW_TYPE,
      (leaf) => new TableView(leaf)
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        menu.addItem((item) => {
          item.setTitle("\u4EE5 TileLineBase \u8868\u683C\u6253\u5F00").setIcon("table").onClick(async () => {
            await this.openTableView(file);
          });
        });
      })
    );
    this.addCommand({
      id: "toggle-table-view",
      name: "\u5207\u6362 TileLineBase \u8868\u683C\u89C6\u56FE",
      checkCallback: (checking) => {
        const activeLeaf = this.app.workspace.activeLeaf;
        if (!activeLeaf)
          return false;
        if (!checking) {
          this.toggleTableView(activeLeaf);
        }
        return true;
      }
    });
  }
  async onunload() {
    console.log("\u5378\u8F7D TileLineBase \u63D2\u4EF6");
    this.app.workspace.detachLeavesOfType(TABLE_VIEW_TYPE);
  }
  async openTableView(file) {
    const { workspace } = this.app;
    const leaf = workspace.getLeaf(false);
    await leaf.setViewState({
      type: TABLE_VIEW_TYPE,
      active: true,
      state: {
        filePath: file.path
      }
    });
    workspace.revealLeaf(leaf);
  }
  async toggleTableView(leaf) {
    const currentView = leaf.view;
    if (currentView.getViewType() === TABLE_VIEW_TYPE) {
      const tableView = currentView;
      const file = tableView.file;
      if (file) {
        await leaf.setViewState({
          type: "markdown",
          state: {
            file: file.path
          }
        });
      }
    } else {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        await leaf.setViewState({
          type: TABLE_VIEW_TYPE,
          active: true,
          state: {
            filePath: activeFile.path
          }
        });
      }
    }
  }
};
