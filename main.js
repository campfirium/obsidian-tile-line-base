/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TileLineBasePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/TableView.ts
var import_obsidian = require("obsidian");
var TABLE_VIEW_TYPE = "tile-line-base-table";
var TableView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
    this.file = null;
    this.blocks = [];
    this.schema = null;
    this.saveTimeout = null;
  }
  getViewType() {
    return TABLE_VIEW_TYPE;
  }
  getDisplayText() {
    var _a;
    return ((_a = this.file) == null ? void 0 : _a.basename) || "TileLineBase \u8868\u683C";
  }
  async setState(state, result) {
    const file = this.app.vault.getAbstractFileByPath(state.filePath);
    if (file instanceof import_obsidian.TFile) {
      this.file = file;
      await this.render();
    }
  }
  getState() {
    var _a;
    return {
      filePath: ((_a = this.file) == null ? void 0 : _a.path) || ""
    };
  }
  /**
   * 解析文件内容，提取所有 H2 块
   */
  parseH2Blocks(content) {
    const lines = content.split("\n");
    const blocks = [];
    let currentBlock = null;
    for (const line of lines) {
      if (line.startsWith("## ")) {
        if (currentBlock) {
          blocks.push(currentBlock);
        }
        currentBlock = {
          title: line.substring(3).trim(),
          // 去掉 "## "
          paragraphs: []
        };
      } else if (currentBlock) {
        const trimmed = line.trim();
        if (trimmed.length > 0) {
          currentBlock.paragraphs.push(line);
        }
      }
    }
    if (currentBlock) {
      blocks.push(currentBlock);
    }
    return blocks;
  }
  /**
   * 从第一个 H2 块提取 Schema
   */
  extractSchema(blocks) {
    if (blocks.length === 0) {
      return null;
    }
    const firstBlock = blocks[0];
    const columnNames = [
      firstBlock.title,
      // 第一列名 = H2 标题
      ...firstBlock.paragraphs
      // 后续列名 = 段落
    ];
    return { columnNames };
  }
  /**
   * 从 H2 块提取表格数据
   */
  extractTableData(blocks, schema) {
    const data = [];
    for (let i = 1; i < blocks.length; i++) {
      const block = blocks[i];
      const row = [block.title];
      for (let j = 0; j < schema.columnNames.length - 1; j++) {
        const paragraph = block.paragraphs[j];
        if (!paragraph || paragraph.trim() === ".") {
          row.push("");
        } else {
          row.push(paragraph.trim());
        }
      }
      data.push(row);
    }
    return data;
  }
  /**
   * 将 blocks 数组转换回 Markdown 格式
   */
  blocksToMarkdown() {
    const lines = [];
    for (const block of this.blocks) {
      lines.push(`## ${block.title}`);
      for (const paragraph of block.paragraphs) {
        if (paragraph.trim()) {
          lines.push(paragraph);
        }
      }
      lines.push("");
    }
    return lines.join("\n");
  }
  /**
   * 调度保存（500ms 防抖）
   */
  scheduleSave() {
    if (this.saveTimeout) {
      clearTimeout(this.saveTimeout);
    }
    this.saveTimeout = setTimeout(() => {
      this.saveToFile();
    }, 500);
  }
  /**
   * 保存到文件
   */
  async saveToFile() {
    if (!this.file)
      return;
    try {
      const markdown = this.blocksToMarkdown();
      await this.app.vault.modify(this.file, markdown);
      console.log("\u2705 \u6587\u4EF6\u5DF2\u4FDD\u5B58:", this.file.path);
    } catch (error) {
      console.error("\u274C \u4FDD\u5B58\u5931\u8D25:", error);
    }
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.addClass("tile-line-base-view");
  }
  async render() {
    const container = this.containerEl.children[1];
    container.empty();
    if (!this.file) {
      container.createDiv({ text: "\u672A\u9009\u62E9\u6587\u4EF6" });
      return;
    }
    const content = await this.app.vault.read(this.file);
    this.blocks = this.parseH2Blocks(content);
    if (this.blocks.length === 0) {
      container.createDiv({
        text: "\u6B64\u6587\u4EF6\u4E0D\u5305\u542B H2 \u5757\uFF0C\u65E0\u6CD5\u663E\u793A\u4E3A\u8868\u683C",
        cls: "tlb-warning"
      });
      return;
    }
    this.schema = this.extractSchema(this.blocks);
    if (!this.schema) {
      container.createDiv({ text: "\u65E0\u6CD5\u63D0\u53D6\u8868\u683C\u7ED3\u6784" });
      return;
    }
    const data = this.extractTableData(this.blocks, this.schema);
    const tableContainer = container.createDiv({ cls: "tlb-table-container" });
    const table = tableContainer.createEl("table", { cls: "tlb-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    this.schema.columnNames.forEach((colName, colIndex) => {
      const th = headerRow.createEl("th");
      th.textContent = colName;
      th.setAttribute("contenteditable", "true");
      th.setAttribute("data-col", String(colIndex));
      th.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          th.blur();
        }
      });
      th.addEventListener("blur", () => {
        const newValue = th.textContent || "";
        this.onHeaderEdit(colIndex, newValue);
      });
    });
    const tbody = table.createEl("tbody");
    data.forEach((row, rowIndex) => {
      const tr = tbody.createEl("tr");
      row.forEach((cellValue, colIndex) => {
        const td = tr.createEl("td");
        td.textContent = cellValue || "";
        td.setAttribute("contenteditable", "true");
        td.setAttribute("data-row", String(rowIndex));
        td.setAttribute("data-col", String(colIndex));
        td.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            td.blur();
          }
        });
        td.addEventListener("blur", () => {
          const newValue = td.textContent || "";
          this.onCellEdit(rowIndex, colIndex, newValue);
        });
      });
    });
    console.log(`TileLineBase \u8868\u683C\u5DF2\u6E32\u67D3\uFF1A${this.file.path}`);
    console.log(`Schema:`, this.schema);
    console.log(`\u6570\u636E\u884C\u6570: ${data.length}`);
  }
  /**
   * 处理单元格编辑
   */
  onCellEdit(rowIndex, colIndex, newValue) {
    const blockIndex = rowIndex + 1;
    if (blockIndex >= this.blocks.length) {
      console.error("Invalid block index:", blockIndex);
      return;
    }
    const block = this.blocks[blockIndex];
    if (colIndex === 0) {
      block.title = newValue;
      console.log(`\u66F4\u65B0 H2 \u6807\u9898 [${blockIndex}]:`, newValue);
    } else {
      const paragraphIndex = colIndex - 1;
      while (block.paragraphs.length <= paragraphIndex) {
        block.paragraphs.push("");
      }
      block.paragraphs[paragraphIndex] = newValue;
      console.log(`\u66F4\u65B0\u6BB5\u843D [${blockIndex}][${paragraphIndex}]:`, newValue);
    }
    console.log("Updated blocks:", this.blocks);
    this.scheduleSave();
  }
  /**
   * 处理表头编辑
   */
  onHeaderEdit(colIndex, newValue) {
    if (!this.schema || this.blocks.length === 0) {
      console.error("Invalid schema or blocks");
      return;
    }
    this.schema.columnNames[colIndex] = newValue;
    const templateBlock = this.blocks[0];
    if (colIndex === 0) {
      templateBlock.title = newValue;
      console.log(`\u66F4\u65B0\u8868\u5934\uFF08\u6A21\u677F H2 \u6807\u9898\uFF09[${colIndex}]:`, newValue);
    } else {
      const paragraphIndex = colIndex - 1;
      while (templateBlock.paragraphs.length <= paragraphIndex) {
        templateBlock.paragraphs.push("");
      }
      templateBlock.paragraphs[paragraphIndex] = newValue;
      console.log(`\u66F4\u65B0\u8868\u5934\uFF08\u6A21\u677F\u6BB5\u843D\uFF09[${paragraphIndex}]:`, newValue);
    }
    this.scheduleSave();
  }
  async onClose() {
  }
};

// src/main.ts
var TileLineBasePlugin = class extends import_obsidian2.Plugin {
  async onload() {
    console.log("\u52A0\u8F7D TileLineBase \u63D2\u4EF6");
    this.registerView(
      TABLE_VIEW_TYPE,
      (leaf) => new TableView(leaf)
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        menu.addItem((item) => {
          item.setTitle("\u4EE5 TileLineBase \u8868\u683C\u6253\u5F00").setIcon("table").onClick(async () => {
            await this.openTableView(file);
          });
        });
      })
    );
    this.addCommand({
      id: "toggle-table-view",
      name: "\u5207\u6362 TileLineBase \u8868\u683C\u89C6\u56FE",
      checkCallback: (checking) => {
        const activeLeaf = this.app.workspace.activeLeaf;
        if (!activeLeaf)
          return false;
        if (!checking) {
          this.toggleTableView(activeLeaf);
        }
        return true;
      }
    });
  }
  async onunload() {
    console.log("\u5378\u8F7D TileLineBase \u63D2\u4EF6");
    this.app.workspace.detachLeavesOfType(TABLE_VIEW_TYPE);
  }
  async openTableView(file) {
    const { workspace } = this.app;
    const leaf = workspace.getLeaf(false);
    await leaf.setViewState({
      type: TABLE_VIEW_TYPE,
      active: true,
      state: {
        filePath: file.path
      }
    });
    workspace.revealLeaf(leaf);
  }
  async toggleTableView(leaf) {
    const currentView = leaf.view;
    if (currentView.getViewType() === TABLE_VIEW_TYPE) {
      const tableView = currentView;
      const file = tableView.file;
      if (file) {
        await leaf.setViewState({
          type: "markdown",
          state: {
            file: file.path
          }
        });
      }
    } else {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        await leaf.setViewState({
          type: TABLE_VIEW_TYPE,
          active: true,
          state: {
            filePath: activeFile.path
          }
        });
      }
    }
  }
};
