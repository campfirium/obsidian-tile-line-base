# 拖拽泳道排序可行性（2025-11-09）

## 背景与目标
- Kanban 视图当前仅支持卡片拖拽，泳道排列顺序来自 `buildExpectedLaneNames()`（状态字段 → `lanePresets` → 运行中遇到的值），无法按用户偏好持续排序。
- 新需求：允许用户拖动泳道头部改变顺序，并写回 `KanbanBoardStore`，确保刷新、切换视图或多端同步后顺序保持一致。
- 约束：保持现有 `TableView`（≤250 行）的职责边界；沿用 SortableJS；兼顾状态列（Status）与自定义列；强调键盘/触屏可访问性。

## 现状梳理
1. **渲染管线**：`renderKanbanView()` → `KanbanViewController` → `buildKanbanBoardState()`。预期泳道列表由 `buildExpectedLaneNames()` 合并 `resolveExpectedStatusLanes()` 与 `lanePresets`，若无期望值则按 `Map` 插入顺序输出。
2. **数据存储**：`KanbanBoardStore` 仅持久化 `lanePresets`，没有额外顺序字段；`KanbanBoardModal` 在编辑时允许输入静态泳道列表。
3. **交互能力**：每个泳道头部是静态 `div`，卡片容器绑定 SortableJS；`KanbanToolbar` 暂无“排序模式”或拖拽提示。
4. **同步影响**：修改泳道顺序需触发 `plugin.saveKanbanBoardsForFile()`，并让 `KanbanViewController` 的 `lanePresets` 立即生效；同时要在 `KanbanBoardStore.updateBoard()` 的 `lanePresets` 分支内保持去重/清洗逻辑。

## 方案比较
### 方案 A：直接拖动泳道头部
- **实现**：为 `.tlb-kanban-board` 注册额外的 SortableJS 实例，`draggable` 设为 `.tlb-kanban-lane`，拖拽结束时读取 DOM 顺序 → 更新 `lanePresets`。在状态列场景下，需要将 `resolveExpectedStatusLanes()` 的结果写入新字段 `laneOrderOverrides` 并存储相对顺序。
- **优点**：交互直观、与卡片拖拽一致；无需额外面板；移动端体验好。
- **风险**：
  1. SortableJS 嵌套实例需隔离拖拽句柄，避免拖 lane 时触发卡片拖拽。可通过 `handle: '.tlb-kanban-lane__header'` 和在 lane 拖拽期间禁用卡片 Sortable。
  2. 状态列默认顺序（Todo/In Progress/Done）是可读性基线，若允许自由排列需在配置中记录完整自定义顺序，并在恢复默认时提供“重置排序”入口。
  3. 键盘可访问性：无鼠标时需提供“移动到左/右”按钮或在 `KanbanToolbar` 增加“排序模式”，通过按钮触发 reorder。

### 方案 B：在看板设置中提供排序列表
- **实现**：在 `KanbanBoardModal` 增加“泳道排序”区域，通过列表 + 上/下按钮或迷你拖拽器调整 `lanePresets` 顺序；仅在 `lanePresets` 不为空时允许。
- **优点**：复用现有 Dialog 基础，避免前端复杂 drag 互斥；易于提供键盘操作。
- **风险**：缺少所见即所得；当泳道值不在 `lanePresets` 中（由实际数据生成）时，用户仍无法控制。
- **结论**：当前迭代暂不实现该方案，保持为后续备选，聚焦泳道头部拖拽体验。

### 推荐
- 采用 **方案 A** 做主交互，并在 `KanbanBoardModal` 中同步展示可编辑的排序结果；必要时提供“手动排序备选模式”。这样兼顾直觉操作与可访问性，且减少双向同步成本。

## 技术要点
1. **状态建模**
   - `KanbanBoardDefinition` 新增 `laneOrderOverrides: string[] | null`（或复用 `lanePresets` 并在序列化时写入所有 lane 名字），并在 `KanbanBoardStore` 中提供 `applyLaneOrder(laneNames: string[])` 方法，写入去重后的数组。
   - `buildExpectedLaneNames()` 输入的 `lanePresets` 更名为 `laneOrder`，来源于 `laneOrderOverrides`，若为空则沿用 `lanePresets`/状态默认值。
2. **UI 与交互**
   - 在 `renderKanbanView()` 输出的 `laneEl` 上新增 `aria-grabbed`、`tabindex` 以及提示文本（i18n：`kanbanView.laneReorderHint`）。
   - `KanbanViewController` 创建第二个 Sortable 实例：
     ```ts
     this.laneSortable = this.sortableClass.create(this.boardEl!, {
       draggable: '.tlb-kanban-lane',
       handle: '.tlb-kanban-lane__header',
       direction: 'horizontal',
       onStart: () => this.toggleCardDrag(false),
       onEnd: (evt) => this.persistLaneOrder(evt.to)
     });
     ```
   - `persistLaneOrder(container)` 收集 `data-lane-name` 顺序，更新 `KanbanBoardStore.updateBoard(activeId, { lanePresets: orderedNames })`，并 `await persist()`；同时刷新 `view.renderKanban()`。
3. **可访问性**
   - 键盘操作：在 header 添加“移动到左/右”按钮，触发 `moveLane(laneName, offset)`，并复用 `persistLaneOrder()`。
   - 提示：在空泳道 placeholder 旁显示“拖拽泳道头部以重新排序（可在设置中重置）”。
4. **兼容性**
   - 当 lane 字段为 `status` 时，默认列表来自 `resolveExpectedStatusLanes()`；若用户排序一次，即写入 overrides，后续更新 `expectedLaneNames` 时应先读取 overrides，再补充遗漏状态。
   - Markdown 数据缺少目标泳道时，应保留 reorder 结果，仅在 lane 真实移除/重命名时清理。
5. **性能**
   - 泳道数一般远小于卡片数，额外 Sortable 实例影响有限，但需在 `destroySortables()` 中销毁 lane-level sortable，避免内存泄漏。

## 输出与后续
- 本文档结论：首阶段聚焦“可拖拽 + 即时持久化 + 键盘备选”组合，确保状态列与自定义列共用一套排序模型。
- 下一步：
  1. 在 `docs/specs/` 发布实现计划与动效稿，拆解为“UI/交互”“数据持久化”“回归测试”子任务。
  2. 为 i18n 新增 `kanbanView.laneReorderHint`、`kanbanView.resetLaneOrderLabel` 等字段，提前占位。
  3. 规划手工测试：多窗口同步、10k 行数据的重排体验、触控设备试用。
