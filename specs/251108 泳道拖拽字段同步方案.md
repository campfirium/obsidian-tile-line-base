# 251108 泳道拖拽字段同步方案

- 主题：看板
- 类型：基础
- 任务：T0154 泳道拖拽变更字段

## 背景

当前泳道拖拽依赖 `sortablejs` 在前端直接移动卡片 DOM，`KanbanViewController` 仅在 `handleDragEnd` 中为被拖拽卡片记录目标泳道，但表格字段的数据更新链路不完整。实际表现为：

1. 拖拽到其他泳道后，页面刷新或切换视图即回复原状，导致拖拽结果只是“临时态”。
2. 当泳道字段指向标准 `status` 列时，没有同步 `statusChanged` 时间戳，破坏既有流程中对状态更新时间的依赖。

## 目标

1. 拖拽跨泳道后立即持久化对应字段，确保回到表格视图或刷新后仍保留新泳道。
2. 若泳道字段为 `status`（SchemaBuilder 已将别名收敛到该字段），同时刷新 `statusChanged`，与格子编辑逻辑保持一致。
3. 保留撤销/重做能力，并复用现有 `TableHistoryManager`、`persistenceService`、`filterOrchestrator` 链路。
4. 控制改动范围在 `kanban` 子模块，避免 `TableView`、`GridController` 额外复杂度。

## 方案

### 数据更新流程

1. `Sortable.onEnd` 仍由 `KanbanViewController.handleDragEnd` 捕获。
2. 将 rowIndex → 新泳道 的映射存入 `RowUpdate`，只跟踪被移动卡片，避免无谓遍历。
3. 新增 `RowUpdate.statusTimestamp` 字段，留给 `applyUpdates` 统一写入。

### 字段写入逻辑

1. `applyUpdates` 根据 `laneField` 判断是否为 `status`。若是，则在发现目标泳道与现值不同且 drag 可写时，调用 `getCurrentLocalDateTime()` 生成时间戳并将 `statusChanged` 一并加入 `captureCellChanges` 的字段列表。
2. `captureCellChanges` 负责生成历史快照并在 `applyChange` 中调用 `persistenceService.scheduleSave()`，无需额外手工保存。
3. 若未产生任何字段变化（例如拖回原泳道），`captureCellChanges` 返回 `false`，沿用现有 `renderBoard()` 回滚 DOM。

### 可维护性

- 所有新增逻辑仍封装在 `KanbanViewController` 内，若后续需要抽离，可独立成 `KanbanLaneMutationService`。
- 通过 `getAvailableFields()` 维持显示字段列表，无需调整 Schema。
- 依赖 `t('kanbanView...')` 的 UI 文案未改动，保持国际化一致。

## 验证计划

1. 自动：`npm run build`，保证 TS 编译及打包通过。
2. 自动：`npm run deploy`，同步到 Obsidian 插件目录。
3. 手工：在示例 Vault 中切换到 Kanban 视图，跨泳道拖拽卡片，切回表格或刷新视图确认字段已经更新；若泳道字段为 `status`，同时确认 `statusChanged` 字段更新为当前时间。
